<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="ch02">
  <?dbhtml stop-chunking?>

  <title>Dart 语言概览</title>

  <para>本章介绍 Dart 语言的主要特性 -- 变量、操作符、类和库 等。
      本章假设你具有其他编程语言的背景知识。</para>

  <note>
    <para>你可以按照 <xref linkend="ch01-editor" /> 中介绍的方法创建个命令行应用来
        动手演示这些特性。</para>
  </note>

  <para>如果你想了解某个特性的详细信息，可以参考
       <ulink url="http://www.dartlang.cc/docs/spec/">Dart
  语言规范</ulink> 。</para>

  <sect1 id="main-print">
    <title>一个基本的 Dart 程序</title>

    <para>下面的代码使用很多 Dart 语言的基本特性：</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>// 定义一个方法
printNumber(num aNumber) {
  print('The number is $aNumber.'); // 在控制台打印信息
}

// 应用开始执行的入口
main() {
  var number = 42;           // 定义并初始化一个变量
  printNumber(number);       // 调用一个方法
}</programlisting>

    <para>下面是上面的代码使用到的可以应用其他（几乎）所有 Dart 应用的
        特性：</para>

    <variablelist>
      <varlistentry>
        <term><literal moreinfo="none">// <replaceable>这是一个注释。
            </replaceable></literal></term>

        <listitem>
          <para>使用 // 表明后面的文字为注释。
          另外还可以用 /* ... */。详细信息，参考 <xref
          linkend="comments" />。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">num</literal></term>

        <listitem>
          <para>一种类型。其他内建的类型有 String、int、和 bool。
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">42</literal></term>

        <listitem>
          <para>一个数字 <firstterm>literal（字面量）</firstterm>。
              字面量是一种编译期常量。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">print()</literal></term>

        <listitem>
          <para>一种打印结果的助手方法。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">'...'</literal> (或者 <literal
        moreinfo="none">"..."</literal>)</term>

        <listitem>
          <para>声明 String 的 字面量。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal
        moreinfo="none">$<replaceable>variableName</replaceable></literal> (或者
        <literal
        moreinfo="none">${<replaceable>expression</replaceable></literal><literal
        moreinfo="none">}</literal>)</term>

        <listitem>
          <para>字符串插值（String interpolation）：在一个字符串字面量中包含
              一个变量或者表达式，最终该变量或者表达式的值将替换在字符串中。详细信息请参考：
           <xref linkend="strings" />。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">main()</literal></term>

        <listitem>
          <para>Dart 程序<emphasis>必需的</emphasis>顶级入口函数。
              Dart 程序从该函数开始执行。 详细信息请参考： <xref
          linkend="ch02-main" />。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">var</literal></term>

        <listitem>
          <para>一种定义无类型变量的方法。</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <note>
      <para>我们的代码遵守 <ulink
      url="http://www.dartlang.cc/articles/style-guide/">Dart 风格指南
      </ulink> 中介绍的格式。例如，我们用了两个空格的缩进。</para>
    </note>
  </sect1>

  <sect1 id="ch02-concepts">
    <title>重要的概念</title>

    <para>在学习 Dart 语言的时候，请记住如下概念：</para>

    <itemizedlist>
      <listitem>
        <para>变量引用的任意内容都是一个
        <emphasis>对象（object）</emphasis>，任意对象都是一个
        <emphasis>类（class）</emphasis> 的实例。甚至 数字（ numbers）、方法（ functions）、 和<literal
        moreinfo="none">null</literal> 都是对象。所有的对象都从
         <ulink
        url="http://api.dartlang.org/dart_core/Object.html">Object</ulink>
        类继承下来。</para>
      </listitem>

      <listitem>
        <para>指定静态类型（例如前面示例的  <literal
        moreinfo="none">num</literal> ） 明确你的意图，并且可以使用
        工具的静态分析工具，但是类型是可选的。（在调试代码的时候，你可能已经注意到了，虽然你指定了静态类型，但是在调试的时候
        该变量并没有指定具体的类型，而是使用了一个特殊的类型： <literal
        moreinfo="none">dynamic</literal>）。</para>
      </listitem>

      <listitem>
        <para>Dart 在运行代码之前先解析代码。 你可以给 Dart 提供
            一些扑捉错误和帮助提高代码运行效率的建议，例如使用 类型、或者使用编译期常量。</para>
      </listitem>

      <listitem>
        <para>Dart 支持顶级方法（例如
        <literal>main()</literal>），也支持实例函数和类函数（静态函数）。
        你还可以在一个方法内创建另外一个方法（<emphasis>nested（嵌入方法）</emphasis> 或者 <emphasis>local
        functions（本地方法）</emphasis>）。 </para>
      </listitem>

      <listitem>
        <para>同样，Dart 也支持顶级
        <emphasis>变量</emphasis>，也支持实例变量和类变量（静态变量）。
        实例变量有时候被称之为 值域或者属性（<firstterm>fields</firstterm> 或者
        <firstterm>properties</firstterm>）。</para>
      </listitem>

      <listitem>
        <para>和 Java 不同， Dart 没有 <literal
        moreinfo="none">public</literal>、 <literal
        moreinfo="none">protected</literal>、 和 <literal
        moreinfo="none">private</literal> 关键字。如果名字
        以下划线（_）开头，则是库私有成员。详细信息请参考： <xref
        linkend="libraries" />。</para>
      </listitem>

      <listitem>
        <para><firstterm>标识符（名字）</firstterm> 可以以字母或者 下划线 开头，后面可以跟随
            任意的字母和数字的组合。</para>
      </listitem>

      <listitem>
        <para>有时候需要区分一个东西是
        <emphasis>expression（表达式）</emphasis> 还是一个 <emphasis>statement（语句）</emphasis>，
        所以我们将区分这两个词语。</para>
      </listitem>

      <listitem>
        <para>Dart 工具可以报告两种错误信息：警告和错误。
		警告只是提示你代码可能有潜在的问题，但是并不阻止代码执行。
		错误可能是编译时错误也可能是运行时错误。一个编译时错误阻止代码运行，而运行时
		错误在遇到的时候会抛出一个
        <link
        linkend="exceptions">exception</link> 。</para>
      </listitem>

      <listitem>
        <para>Dart 有两种 <firstterm>运行模式</firstterm>：
            生产模式和检测模式（ production
        and checked）。生产模式效率高，但是测试模式可以在开发的时候帮助调试代码。</para>
      </listitem>
    </itemizedlist>

    <sect2 id="ch02-keywords">
      <title>关键字</title>

      <para><xref linkend="keyword_table" /> 列出了  Dart 语言中的
          关键字。</para>

      <para><table class="keywordTable" id="keyword_table">
          <title>Dart 关键字</title>

          <tgroup cols="6">
            <tbody>
              <row>
                <entry>abstract *</entry>

                <entry>continue</entry>

                <entry>extends</entry>

                <entry>implements *</entry>

                <entry>part *</entry>

                <entry>throw</entry>
              </row>

              <row>
                <entry>as *</entry>

                <entry>default</entry>

                <entry>factory *</entry>

                <entry>import *</entry>

                <entry>rethrow</entry>

                <entry>true</entry>
              </row>

              <row>
                <entry>assert</entry>

                <entry>do</entry>

                <entry>false</entry>

                <entry>in</entry>

                <entry>return</entry>

                <entry>try</entry>
              </row>

              <row>
                <entry>break</entry>

                <entry>dynamic *</entry>

                <entry>final</entry>

                <entry>is</entry>

                <entry>set *</entry>

                <entry>typedef *</entry>
              </row>

              <row>
                <entry>case</entry>

                <entry>else</entry>

                <entry>finally</entry>

                <entry>library *</entry>

                <entry>static *</entry>

                <entry>var</entry>
              </row>

              <row>
                <entry>catch</entry>

                <entry>enum</entry>

                <entry>for</entry>

                <entry>new</entry>

                <entry>super</entry>

                <entry>void</entry>
              </row>

              <row>
                <entry>class</entry>

                <entry>export *</entry>

                <entry>get *</entry>

                <entry>null</entry>

                <entry>switch</entry>

                <entry>while</entry>
              </row>

              <row>
                <entry>const</entry>

                <entry>external *</entry>

                <entry>if</entry>

                <entry>operator *</entry>

                <entry>this</entry>

                <entry>with</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>

      <para>
          在上表中，带有星号（*）的关键字为
      <emphasis>内置的标识符（built-in identifiers）</emphasis>。
      虽然你应该把内置的标识符按照关键字对待，其实真正的限制是无法用内置的标识符作为类或者类型的名字。
	使用内置的标识符可以简化从 JavaScript 移植到 Dart 的过程。
	例如，有些 JavaScript 代码具有一个名字为 <literal>factory</literal> 的变量；
	当移植到 Dart 时无需重命名该变量。<remark> 13年十月更新：添加 enum、
      rethrow。 Dart 保留关键字：语言规范的 Section 16.1.1 列举了保留的关键字；  12.31 
      介绍了内置标识符的参考索引。</remark></para>
    </sect2>

    <sect2 id="ch02-runtime-modes">
      <title>运行时模式</title>

      <para>我们建议在检测模式开发，在生产模式部署。</para>

      <para><emphasis>生产模式</emphasis>是 Dart 程序的默认运行模式，优化了运行速度。
          生产模式忽略
       <link
      linkend="assert">assert statements（断言语句）</link> 和静态类型。</para>

      <para><emphasis>检测模式</emphasis> 是开发友好模式，
          可以在运行的时候帮助你捕获一些类型错误信息。例如，
          如果你给一个类型为 <literal
      moreinfo="none">num</literal> 的变量
      赋值为一个非数字的值，在检测模式会抛出一个异常。</para>
    </sect2>
  </sect1>

  <sect1 id="variables">
    <title>变量</title>

    <para>下面是创建变量并赋值的示例：</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>var name = 'Bob';</programlisting>

    <para>变量是引用。名字为 <literal
    moreinfo="none">name</literal> 的变量包含一个指向内容为
      <quote>Bob</quote> 的 String 对象。</para>

    <sect2 id="variables-default-value">
      <title>默认值</title>

      <para>没有初始化的变量的值为 <literal
      moreinfo="none">null</literal>。即使类型为数字的变量其值也是 null，不要忘了 数字在 Dart
      中也是对象。</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>int lineCount;
assert(lineCount == null); 
// 变量的初始值为 null。</programlisting>

      <note>
        <para>在生产模式下  <literal>assert()</literal> 方法不会被调用。在检测
            模式下，如果 <replaceable>判断条件</replaceable> 值为 false ，则 <literal
        moreinfo="none">assert(<replaceable>判断条件</replaceable>)</literal>
       抛出一个异常。详细信息请参考： <xref linkend="assert" />。</para>
      </note>
    </sect2>

    <sect2 id="variables-optional-types">
      <title>可选类型</title>

      <para>在声明变量的时候可以设置一个静态类型：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>String name = 'Bob';</programlisting>

      <para>添加类型可以明确表达你的意图，可以替代注释。有些工具（例如编译器和编辑器）可以
          使用类型信息帮助你编写代码。</para>

      <note>
        <para>本章内容按照 <ulink
        url="http://www.dartlang.cc/articles/style-guide/#type-annotations"> Dart 风格指南</ulink>
        推荐的方式用  <literal
        moreinfo="none">var</literal> 来定义
        局部变量。</para>
      </note>
    </sect2>

    <sect2 id="ch02-final-const">
      <title>Final 和 Const</title>

      <para>如果你重来不需要修改变量的值，则可以用  <literal
      moreinfo="none">final</literal> 或者 <literal
      moreinfo="none">const</literal> 来修饰该变量，可以替代 <literal
      moreinfo="none">var</literal> 关键字也可以用在类型声明之前。
    	一个 final 类型变量只能设置一次值，一个 const 变量是编译期常量。</para>

      <para>定义为 <literal
      moreinfo="none">final</literal> 的本地变量、顶级变量、或者类变量在第一次
      使用的时候初始化：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>final name = 'Bob';   // Or: final String name = 'Bob';
// name = 'Alice';    // 这行代码有错误</programlisting>

      <note>
        <para>懒加载 final 变量可以让应用启动速度加快。</para>
      </note>

      <para>用 <literal moreinfo="none">const</literal> 来定义
          编译期常量。 如果是类常量则用 <literal>static const</literal> 来定义。
          实例变量无法用 const 修饰。 在定义变量的时候，可以设置其值为编译期常量，例如：
          字符字面量、const 变量或者常量数字的数学运算结果：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>const bar = 1000000;       // 压力单位 (in dynes/cm2)
const atm = 1.01325 * bar; // 标准大气压</programlisting>
    </sect2>
  </sect1>

  <sect1 id="built-in-types">
    <title>内置类型</title>

    <para>Dart 语言对如下类型有特殊的支持：</para>

    <itemizedlist>
      <listitem>
        <para>numbers</para>
      </listitem>

      <listitem>
        <para>strings</para>
      </listitem>

      <listitem>
        <para>booleans</para>
      </listitem>

      <listitem>
        <para>lists (也被称之为 <emphasis>arrays</emphasis>)</para>
      </listitem>

      <listitem>
        <para>maps</para>
      </listitem>

      <listitem>
        <para>symbols</para>
      </listitem>
    </itemizedlist>

    <para>你可以用字符字面量来初始化上面这些类型。例如  <literal moreinfo="none">'this is a
    string'</literal> 是一个定义字符串的 字符字面量，而 <literal
    moreinfo="none">true</literal> 是一个布尔值字符字面量。</para>

    <para>由于 Dart 总的变量都是引用一个对象，所以可以使用
    <emphasis>构造函数</emphasis> 来初始化变量。
    一些内置类型有自己的构造函数。
    例如，可以用 
    <literal>Map()</literal> 构造函数来创建一个 map 对象：
    <literal moreinfo="none">new Map()</literal>。</para>

    <sect2 id="numbers">
      <title>Numbers</title>

      <para>Dart 支持两种类型数字：</para>

      <variablelist>
        <varlistentry>
          <term><ulink url="http://api.dartlang.org/dart_core/int.html">
          <literal moreinfo="none">int</literal> </ulink></term>

          <listitem>
            <para>整数值</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><ulink url="http://api.dartlang.org/dart_core/double.html">
          <literal moreinfo="none">double</literal> </ulink></term>

          <listitem>
            <para>IEEE 754 标准定义的 64-bit (双精度) 浮点数。</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para> <literal moreinfo="none">int</literal> 和 <literal
      moreinfo="none">double</literal> 都是  <ulink
      url="http://api.dartlang.org/dart_core/num.html"><literal
      moreinfo="none">num</literal> 的子类。</ulink>
      num 类定义了基础的操作符，例如 +、 -、 /、 和 *、，以及位操作符，例如 
      &gt;&gt;。同时还定义了一些常用函数：
      <literal>abs()</literal>、<literal> ceil()</literal>、 和
      <literal>floor()</literal> 等。
      如果 nub 和子类没有你需要的功能，请查找
      <ulink
      url="http://api.dartlang.org/dart_math.html">Math</ulink> 库。
      (在 Dart 代码生成的 JavaScript 中，<ulink
      url="http://dartbug.com/1533">大整数</ulink> 和在 
      Dart VM 中执行的  Dart 代码有点区别。)</para>

      <para>Integer 是没有小数点的整数。下面是定义 integer 的一些示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var x = 1;
var hex = 0xDEADBEEF;
var bigInt = 346534658346524376592384765923749587398457294759347029438709349347;</programlisting>

      <para>如果包含小数点，则为 double。
          下面是定义 double 的示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var y = 1.1;
var exponents = 1.42e5;</programlisting>

      <para>下面是字符串和数字之间的转换示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>// String -&gt; int
var one = int.parse('1');
assert(one == 1);

// String -&gt; double
var onePointOne = double.parse('1.1');
assert(onePointOne == 1.1);

// int -&gt; String
String oneAsString = 1.toString();
assert(oneAsString == '1');

// double -&gt; String
String piAsString = 3.14159.toStringAsFixed(2);
assert(piAsString == '3.14');</programlisting>

      <para>int 定义了常用的位移操作符 (&lt;&lt;,
      &gt;&gt;), AND (&amp;), 或者 OR (|) 。示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>assert((3 &lt;&lt; 1) == 6);  // 0011 &lt;&lt; 1 == 0110
assert((3 &gt;&gt; 1) == 1);  // 0011 &gt;&gt; 1 == 0001
assert((3 | 4)  == 7);  // 0011 | 0100 == 0111</programlisting>
    </sect2>

    <sect2 id="strings">
      <title>Strings</title>

      <para>Dart 字符串是一个 UTF-16 编码单元序列。 可以用单引号或者双引号定义
          一个 String：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var s1 = 'Single quotes work well for string literals.';
var s2 = "Double quotes work just as well.";
var s3 = 'It\'s easy to escape the string delimiter.';
var s4 = "It's even easier to just use the other string delimiter.";</programlisting>

      <para>通过使用 
      <literal>${</literal><emphasis><literal>表达式</literal></emphasis><literal>}</literal>
      语法可以把表达式放到字符串中间。
      如果表达式为一个标识符，则可以省略 {}。 Dart 调用
      对象的
      <literal>toString()</literal> 函数来获取该对象的字符串值。</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var s = 'string interpolation';

assert('Dart has $s, which is very handy.' ==
       'Dart has string interpolation, which is very handy.');
assert('That deserves all caps. ${s.toUpperCase()} is very handy!' ==
       'That deserves all caps. STRING INTERPOLATION is very handy!');</programlisting>

      <note>
        <para> <literal moreinfo="none">==</literal> 操作符测试两个对象是否相等。
            具有同样字符的字符串是相等的。</para>
      </note>

      <para>可以通过相邻字符串字面量或者 
      <literal><literal>+</literal></literal> 操作符来连接字符串：</para>

      <programlisting format="linespecific"><remark>lang-dart
adjacent_string_literals.dart
</remark>var s1 = 'String ' 'concatenation'
         " works even over line breaks.";
assert(s1 == 'String concatenation works even over line breaks.');

var s2 = 'The addition operator '
         + 'works, as well.';
assert(s2 == 'The addition operator works, as well.');</programlisting>

      <para>使用三个双引号或者单引号可以创建多行字符串：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var s1 = '''
You can create
multi-line strings like this one.
''';

var s2 = """This is also a
multi-line string.""";</programlisting>

      <para>在前面添加一个 
      <literal moreinfo="none">r</literal> 可以创建  <quote>raw（未转义）</quote> 字符串：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var s = r"In a raw string, even \n isn't special.";</programlisting>

      <para>在字符串中也可以使用 Unicode 转义：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/quoting.dart
</remark>print('Unicode escapes work: \u2665'); // Unicode escapes work: [heart]</programlisting>

      <para>关于使用 String 的更多信息，请参考  <xref
      linkend="ch03-strings-and-regular-expressions" />。</para>
    </sect2>

    <sect2 id="booleans">
      <title>Booleans</title>

      <para>Dart 用 <literal
      moreinfo="none">bool</literal> 类型代表布尔值。类型 bool 只有两个对象：
      布尔字面量 <literal moreinfo="none">true</literal> 和 <literal
      moreinfo="none">false</literal>。</para>

      <para>当 Dart 需要布尔值的时候， 只有  <literal
      moreinfo="none">true</literal> 被认为是 true。
      其他所有的值都认为是 false。和 JavaScript 不同，
      像  <literal
      moreinfo="none">1</literal>、 <literal
      moreinfo="none">"aString"</literal>、和 <literal
      moreinfo="none">someObject</literal> 在 Dart 中都是 false。</para>

      <para>例如 下面的代码在 JavaScript 和 Dart 中都是合法的：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var name = 'Bob';
if (name) {
  print('You have a name!'); // 在 JavaScript 中会执行该语句 ，而 Dart 中不会执行。
}</programlisting>

      <para>由于 <literal moreinfo="none">name</literal> 不是
          一个 null 对象，所以在 JavaScript 运行上面代码则会打印出 <quote>You have a
      name!</quote>。而 在 Dart 的 <emphasis>生产模式
       </emphasis>下，不会输出任何内容，原因在于，
        <literal
      moreinfo="none">name</literal> 被转换成了 <literal
      moreinfo="none">false</literal> (因为 <literal moreinfo="none">name
      != true</literal>)。在 Dart 的 <emphasis>检测模式
       </emphasis>下，由于
       <literal
      moreinfo="none">name</literal> 变量不是一个布尔值 会导致抛出异常。
       </para>

      <para>下面是另外一个 
      JavaScript 和 Dart 代码行为不一致的示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>if (1) {
  print('JavaScript prints this line because it thinks 1 is true.');
} else {
  print('Dart in production mode prints this line.');
  // 在 Dart 的检测模式下 if (1) 会抛出异常。
}</programlisting>

      <note>
        <para>上面的两个示例只有在生产模式下能够运行。在检测模式下，如果把非布尔值当做布尔值用
            会抛出异常。</para>
      </note>

      <para>Dart 只把 true 当做 true，而不是其他对象，可以避免很多不可预料的问题。你不应该这样用：<literal
      moreinfo="none">if&nbsp;(<replaceable>nonbooleanValue</replaceable>)</literal>，而
      应该用你期望的值。例如：
      </para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>// 检测空字符串
var fullName = '';
assert(fullName.isEmpty);

// 检测是否为 0
var hitPoints = 0;
assert(hitPoints &lt;= 0);

// 检测 null.
var unicorn;
assert(unicorn == null);

// 检测  NaN.
var iMeantToDoThis = 0/0;
assert(iMeantToDoThis.isNaN);</programlisting>
    </sect2>

    <sect2 id="lists">
      <title>Lists</title>

      <para> <emphasis>array</emphasis>（数组）也许是大多数编程语言中最常用的集合。
          在 Dart 中，  数组为 <ulink
      url="http://api.dartlang.org/dart_core/List.html">List</ulink> 对象，
      所以一般我们都称之为  <emphasis>lists（列表）</emphasis>。</para>

      <para>Dart 列表字面量定义和 JavaScript 中的 数组定义类似。下面
          是一个定义 Dart 列表的示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var list = [1,2,3];</programlisting>

      <para>列表的索引从 0 开始， 0 是第一个元素而
      <literal moreinfo="none">list.length - 1</literal> 是最后一个元素。
      获取列表的长度和元素与 JavaScript 中的操作一样：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var list = [1,2,3];
assert(list.length == 3);
assert(list[1] == 2);</programlisting>

      <para>List 类定义了很多操作列表的函数。详细信息请参考  <xref linkend="generics" /> 和 <xref
      linkend="ch03-collections" />。</para>
    </sect2>

    <sect2 id="maps">
      <title>Maps</title>

      <para>一般来说，一个 map 是一个把键（key）和值（value）关联起来的对象。
          键和值都可以为任意类型的对象。一个
      <emphasis>键</emphasis> 只能出现一次，但是一个
      <emphasis>值</emphasis> 可以设置到多个键上。 Dart 通过
      map 字面量和  <ulink
      url="http://api.dartlang.org/dart_core/Map.html">Map</ulink>
      类型支持 Map。</para>

      <para>下面是用 map 字面量创建 Map 对象的一些示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var gifts = {
// Keys       Values
  'first'  : 'partridge',
  'second' : 'turtledoves',
  'fifth'  : 'golden rings'
};

var nobleGases = {
// Keys  Values
   2  : 'helium',
   10 : 'neon',
   18 : 'argon',
};
</programlisting>

      <para>也可以用 Map 构造函数创建这些对象：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/map_constructor.dart
</remark>var gifts = new Map();
gifts['first'] = 'partridge';
gifts['second'] = 'turtledoves';
gifts['fifth'] = 'golden rings';

var nobleGases = new Map();
nobleGases[2] = 'helium';
nobleGases[10] = 'neon';
nobleGases[18] = 'argon';</programlisting>

      <para>往 map 对象中添加 键-值 对和 JavaScript 中的操作一样:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var gifts = { 'first': 'partridge' };
gifts['fourth'] = 'calling birds';    // Add a key-value pair</programlisting>

      <para>从 map 中获取值也和 JavaScript 一样：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var gifts = { 'first': 'partridge' };
assert(gifts['first'] == 'partridge');</programlisting>

      <para>如果一个 键 不在 map 中，则返回的值为 null：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var gifts = { 'first': 'partridge' };
assert(gifts['fifth'] == null);</programlisting>

      <para>用 <literal moreinfo="none">.length</literal> 来获取 map 中
          键值对的个数：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var gifts = { 'first': 'partridge' };
gifts['fourth'] = 'calling birds';
assert(gifts.length == 2);</programlisting>

      <para>关于 map 的详细信息请参考：<xref linkend="generics" />
      和 <xref linkend="ch03-maps-aka-dictionaries-or-hashes" />。</para>
    </sect2>

    <sect2 id="ch02-symbols">
      <title>Symbols（符号）</title>

      <para>一个 <ulink
      url="http://api.dartlang.org/dart_core/Symbol.html">Symbol</ulink>
      对象代表 Dart 代码中的一个操作符或者一个标识符。你可能无需使用 Symbol，但是对于需要访问 标识符 名字的 API 来说，
      Symbol 是非常有用的，对于混淆过的代码， Symbol 也返回混淆之前的标识符名字。</para>

      <para>要获取一个标识符的 Symbol，可以 用 symbol 字面量定义：
      一个 <literal>#</literal>后面跟着标识符的名字 </para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>#radix  // The symbol literal for an identifier named 'radix'.
#bar    // The symbol literal for an identifier named 'bar'.</programlisting>

      <para>关于 symbol 的详细信息，请参考  <xref
      linkend="ch03-mirrors" />。</para>
    </sect2>
  </sect1>

  <sect1 id="functions">
    <title>Functions（方法）</title>

    <para>下面是实现一个方法的示例：</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>void printNumber(num number) {
  print('The number is $number.');
}</programlisting>

    <para>虽然风格指南中建议设置参数和返回值的类型，但是你也可以不这么做：</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>printNumber(number) {          // 不设置类型也可以
  print('The number is $number.');
}</programlisting>

    <para>对于只有一个表达式的方法，你可以用缩写形式：</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>printNumber(number) =&gt; print('The number is $number.');</programlisting>

    <para> <literal moreinfo="none">=&gt;
    <replaceable>expr</replaceable>;</literal> 语法是
    <literal moreinfo="none">{ return
    <replaceable>expr</replaceable>;}</literal> 的缩写形式。
    在上面的
    <literal>printNumber()</literal> 方法中，表达式为
    顶级方法 <literal>print()</literal>。</para>

    <note>
      <para>
      在 <phrase
      role="keep-together">arrow (=&gt;)</phrase> 和 分号 (;) 之间只能是
      <emphasis>expression（表达式）</emphasis>，不能用 <emphasis>statement（语句）</emphasis> 。
      例如，不能用
       <link linkend="if-else"><phrase
      role="keep-together">if statement</phrase></link>，但是可以用
      <link linkend="op-other">条件 (<literal>?:</literal>)
      表达式</link>。</para>
    </note>

    <para> =&gt; 也可以使用参数类型（代码风格指南不建议使用类型）：</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>printNumber(num number) =&gt; print('The number is $number.'); // Types are OK.</programlisting>

    <para>调用方法的示例：</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>printNumber(123);</programlisting>

    <para>方法参数有两种类型：必需的和可选的。
        必需的参数出现在可选参数前面。</para>

    <sect2 id="functions-optional-parameters">
      <title>可选参数</title>

      <para>可选参数可以是命名参数或者位置参数。但是不能同时使用这两种类型。</para>

      <para>可选参数可以有默认值。默认值必需为编译期常量，例如 字面量定义。
          如果没有提供默认值，则默认值为 
       <literal
      moreinfo="none">null</literal>。</para>

      <sect3 id="functions-optional-named-parameters">
        <title>可选命名参数</title>

        <para>使用
        <literal moreinfo="none"><replaceable>paramName</replaceable>:
        <replaceable>value</replaceable></literal> 可以设置方法的命名参数。例如：</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark>enableFlags(bold: true, hidden: false);</programlisting>

        <para>用  <literal
        moreinfo="none">{<replaceable>param1</replaceable>,
        <replaceable>param2</replaceable>, …}</literal> 来定义方法的 命名参数：</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark>/// Sets the [bold] and [hidden] flags to the values you specify.
enableFlags({bool bold, bool hidden}) {
  // ...
}</programlisting>

        <para>使用冒号 (<literal moreinfo="none">:</literal>) 来设置默认值：</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark>/**
 * Sets the [bold] and [hidden] flags to the values you specify,
 * defaulting to false.
 */
enableFlags({bool bold: false, bool hidden: false}) {
  // ...
}

enableFlags(bold: true); // bold 的值为 true; hidden 没指定则为默认值 false.</programlisting>
      </sect3>

      <sect3 id="functions-optional-positional-parameters">
        <title>可选位置参数</title>

        <para>位于 <literal
        moreinfo="none">[]</literal> 中间的参数为可选位置  <phrase
        role="keep-together">参数</phrase>：</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark>String say(String from, String msg, [String device]) {
  var result = '$from says $msg';
  if (device != null) {
    result = '$result with a $device';
  }
  return result;
}</programlisting>

        <para>下面是没有设置可选位置参数的调用示例：</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark>assert(say('Bob', 'Howdy') == 'Bob says Howdy');</programlisting>

        <para>下面是设置了可选位置参数的示例：</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark>assert(say('Bob', 'Howdy', 'smoke signal') ==
  'Bob says Howdy with a smoke signal');</programlisting>

        <para>用 <literal moreinfo="none">=</literal> 设置默认值：</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark>String say(String from, String msg,
  [String device='carrier pigeon', String mood]) {
  var result = '$from says $msg';
  if (device != null) {
    result = '$result with a $device';
  }
  if (mood != null) {
    result = '$result (in a $mood mood)';
  }
  return result;
}

assert(say('Bob', 'Howdy') == 'Bob says Howdy with a carrier pigeon');</programlisting>
      </sect3>
    </sect2>

    <sect2 id="ch02-main">
      <title> main() 方法</title>

      <para>每个应用都有一个顶级的 <literal>main()</literal> 方法，
          该方法为程序的执行入口。
      <literal>main()</literal> 方法的返回值为 <literal>void</literal> 并有个可选
       <literal>List&lt;String&gt;</literal> 参数来接收程序参数。</para>

      <para>下面是一个 web 应用中的 <literal>main()</literal> 方法示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>main() {
  querySelector("#sample_text_id")
    ..text = "Click me!"
    ..onClick.listen(reverseText);
}</programlisting>

      <para>下面是带有两个参数的命令行程序 <literal>main()</literal> 方法示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
ch02/args.dart
</remark>// 通过命令运行该程序： dart args.dart 1 test
void main(List&lt;String&gt; arguments) {
  print(arguments);

  assert(arguments.length == 2); 
  assert(int.parse(arguments[0]) == 1);
  assert(arguments[1] == 'test'); 
}</programlisting>

      <para>可以用 <ulink
      url="http://api.dartlang.org/args.html">args 库</ulink> 
      来定义和解析命令行参数。</para>
    </sect2>

    <sect2 id="ch02-functions-first-class">
      <title>（方法作为一等对象）Functions as First-Class Objects</title>

      <para>可以把方法作为方法的参数使用：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>printElement(element) {
  print(element);
}
  
var list = [1,2,3];
list.forEach(printElement); // 把 printElement 方法当做参数来用</programlisting>

      <para>还可以用一个变量来保存方法引用：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var loudify = (msg) =&gt; '!!! ${msg.toUpperCase()} !!!';
assert(loudify('hello') == '!!! HELLO !!!');</programlisting>
    </sect2>

    <sect2 id="ch02-lexical-scope">
      <title>（语法作用域）Lexical Scope</title>

      <para>Dart 是一种语法作用域语言，也就是说 变量的作用域
          是根据代码布局静态判断的。
          可以根据“变量位于花括号内外”来判断一个变量是否在作用域中。
      </para>

      <para>下面是一个嵌套函数变量作用域示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var topLevel = true;
main() {
    var insideMain = true;
    
    myFunction() {
      var insideFunction = true;
      
      nestedFunction() {
        var insideNestedFunction = true;
        assert(topLevel);
        assert(insideMain);
        assert(insideFunction);
        assert(insideNestedFunction);
      }
    }
}</programlisting>

      <para>注意 <literal>nestedFunction()</literal> 可以
          使用外面所有花括号内的变量。</para>
    </sect2>

    <sect2 id="ch02-functions-lexical-closures">
      <title>（语法闭包）Lexical Closures</title>

      <para>一个 <emphasis>closure（闭包）</emphasis> 是一个可以
          访问位于其语法作用域内变量的方法对象，即时该方法用在其定义的作用域之外，也可以访问这些变量。
      </para>

      <para>方法可以覆盖定义在附近作用域的变量
          （Functions can close over variables defined in surrounding scopes）。
          在下面的示例中，
       <literal>adder()</literal> 捕获变量
        <literal moreinfo="none">addBy</literal>。
        无论在哪里使用返回的 adder 函数，该函数都记得
       <literal
      moreinfo="none">addBy</literal> 参数的值。</para>

      <programlisting format="linespecific"><remark>lang-dart</remark><remark>
ch02/function_closure.dart
</remark>/// Returns a function that adds [addBy] to a number.
Function makeAdder(num addBy) {
  adder(num i) {
    return addBy + i;
  }
  return adder;
}

main() {
  var add2 = makeAdder(2); // Create a function that adds 2.
  var add4 = makeAdder(4); // Create a function that adds 4.

  assert(add2(3) == 5);
  assert(add4(3) == 7);
}</programlisting>
    </sect2>

    <sect2 id="ch02-function-equality">
      <title>判断函数相等</title>

      <para>下面是测试顶级方法、静态函数、和实例函数相等的示例：</para>

      <programlisting><remark>lang-dart
</remark><remark>ch02/function_equality_2.dart
</remark>foo() {}               // A top-level function

class SomeClass {
  static void bar() {} // A static method
  void baz() {}        // An instance method
}

main() {
  var x;
  
  // Comparing top-level functions.
  x = foo;
  assert(x == foo);
  
  // Comparing static methods.
  x = SomeClass.bar;
  assert(x == SomeClass.bar);
  
  // Comparing instance methods.
  var v = new SomeClass();
  var w = new SomeClass();
  var y = v;
  x = v.baz;
  
  assert(x == y.baz);
  assert(v.baz != w.baz);
}</programlisting>
    </sect2>

    <sect2 id="ch02-functions-return-values">
      <title>返回值</title>

      <para>每个方法都有一个返回值。如果没有指定返回值，则默认会在函数最后附加一个
      <literal moreinfo="none">return null;</literal> 的语句。</para>
    </sect2>
  </sect1>

  <sect1 id="operators">
    <title>操作符</title>

    <para>Dart 定义了  <xref
    linkend="operator_table" /> 表中的操作符。 很多操作符都可以重写，在
     <xref linkend="classes-operators" /> 介绍了如何重写操作符。</para>

    <table class="operatorTable" id="operator_table">
      <title>操作符和优先级</title>

      <tgroup cols="2">
        <thead>
          <row>
            <entry>描述</entry>

            <entry>操作符</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>一元后缀操作符</entry>

            <entry class="operatorList"><replaceable>expr</replaceable>++
            &nbsp;&nbsp; <replaceable>expr</replaceable>-- &nbsp;&nbsp; ()
            &nbsp;&nbsp; [] &nbsp;&nbsp; .</entry>
          </row>

          <row>
            <entry>一元前缀操作符</entry>

            <entry class="operatorList">-<replaceable>expr</replaceable>
            &nbsp;&nbsp; !<replaceable>expr</replaceable> &nbsp;&nbsp;
            ~<replaceable>expr</replaceable> &nbsp;&nbsp;
            ++<replaceable>expr</replaceable> &nbsp;&nbsp;
            --<replaceable>expr</replaceable> &nbsp;&nbsp;</entry>
          </row>

          <row>
            <entry>乘除</entry>

            <entry class="operatorList">* &nbsp;&nbsp; / &nbsp;&nbsp; %
            &nbsp;&nbsp; ~/</entry>
          </row>

          <row>
            <entry>加减</entry>

            <entry class="operatorList">+ &nbsp;&nbsp; -</entry>
          </row>

          <row>
            <entry>位移</entry>

            <entry class="operatorList">&lt;&lt; &nbsp;&nbsp; &gt;&gt;</entry>
          </row>

          <row>
            <entry>位与 AND</entry>

            <entry class="operatorList">&amp;</entry>
          </row>

          <row>
            <entry>位异或 XOR</entry>

            <entry class="operatorList">^</entry>
          </row>

          <row>
            <entry>位或 OR</entry>

            <entry class="operatorList">|</entry>
          </row>

          <row>
            <entry>关系和类型测试</entry>

            <entry class="operatorList">&gt;= &nbsp;&nbsp; &gt; &nbsp;&nbsp;
            &lt;= &nbsp;&nbsp; &lt; &nbsp;&nbsp; as &nbsp;&nbsp; is
            &nbsp;&nbsp; is!</entry>
          </row>

          <row>
            <entry>相等</entry>

            <entry class="operatorList">== &nbsp;&nbsp; !=
            &nbsp;&nbsp;</entry>
          </row>

          <row>
            <entry>逻辑与 AND</entry>

            <entry class="operatorList">&amp;&amp;</entry>
          </row>

          <row>
            <entry>逻辑或 OR</entry>

            <entry class="operatorList">||</entry>
          </row>

          <row>
            <entry>条件表达式</entry>

            <entry class="operatorList"><replaceable>expr1</replaceable> ?
            <replaceable>expr2</replaceable> :
            <replaceable>expr3</replaceable></entry>
          </row>

          <row>
            <entry>级联操作符</entry>

            <entry class="operatorList">..</entry>
          </row>

          <row>
            <entry>赋值</entry>

            <entry class="operatorList">= &nbsp;&nbsp; *= &nbsp;&nbsp; /=
            &nbsp;&nbsp; ~/= &nbsp;&nbsp; %= &nbsp;&nbsp; += &nbsp;&nbsp; -=
            &nbsp;&nbsp; &lt;&lt;= &nbsp;&nbsp; &gt;&gt;= &nbsp;&nbsp; &amp;=
            &nbsp;&nbsp; ^= &nbsp;&nbsp; |= &nbsp;&nbsp;</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>当使用操作符的时候，就会创建一个
    <firstterm>表达式</firstterm>。
    下面是一些操作符表达式的示例：</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>a++
a + b
a = b
a == b
a? b: c
a is T</programlisting>

    <para>在 <xref linkend="operator_table" /> 中，每一行操作符都比其下面的操作符优先级要高。
    例如，除法操作符 <literal moreinfo="none">%</literal> 比  <literal
    moreinfo="none">==</literal> 操作符优先级高，而  <literal
    moreinfo="none">==</literal> 又比
     <literal moreinfo="none">&amp;&amp;</literal> 优先级高。
     所以下面的两行代码是一样的：</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>if ((n % i == 0) &amp;&amp; (d % i == 0)) // 使用括号提高代码可读性
if (n % i == 0 &amp;&amp; d % i == 0)     // 虽然难读，但是效果一样</programlisting>

    <warning>
      <para>
          对于连接两个操作数的操作符来说，左边的操作数决定使用那个版本的操作符。例如
          ，如果你有一个 Vector 对象和一个 Point 对象， <literal
      moreinfo="none">aVector + aPoint</literal> 则用 Vector 
  版本的 + 操作符。</para>
    </warning>

    <sect2 id="op-arithmetic">
      <title>算术操作符</title>

      <para>Dart  支持常规的算术操作符，如  <xref
      linkend="arithmetic_operator_table" /> 表格所示：</para>

      <table class="operatorTable" id="arithmetic_operator_table"
             role="keep-together">
        <title>算术操作符</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>操作符</entry>

              <entry>描述</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry class="operator">+</entry>

              <entry>加号</entry>
            </row>

            <row>
              <entry class="operator">–</entry>

              <entry>减号</entry>
            </row>

            <row>
              <entry class="operator">-<replaceable>expr</replaceable></entry>

              <entry>负号</entry>
            </row>

            <row>
              <entry class="operator">*</entry>

              <entry>乘号</entry>
            </row>

            <row>
              <entry class="operator">/</entry>

              <entry>除号</entry>
            </row>

            <row>
              <entry class="operator">~/</entry>

              <entry>整除号</entry>
            </row>

            <row>
              <entry class="operator">%</entry>

              <entry>取余</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>示例：</para>

      <programlisting format="linespecific"><remark>lang-dart</remark><remark>
ch02/arithmetic_operators.dart
</remark>assert(2 + 3 == 5);
assert(2 - 3 == -1);
assert(2 * 3 == 6);
assert(5 / 2 == 2.5);   // Result is a double
assert(5 ~/ 2 == 2);    // Result is an integer
assert(5 % 2 == 1);     // Remainder

print('5/2 = ${5~/2} remainder ${5%2}'); // 5/2 = 2 remainder 1</programlisting>

      <para>Dart 也支持前缀和后缀 加和减 操作符。</para>

      <table class="operatorTable" id="pfix_operator_table">
        <title>加减操作符</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>操作符</entry>

              <entry>描述</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry class="operator">++<replaceable>var</replaceable></entry>

              <entry><replaceable>var</replaceable> =
              <replaceable>var</replaceable> + 1 (expression value is
              <replaceable>var</replaceable> + 1)</entry>
            </row>

            <row>
              <entry class="operator"><replaceable>var</replaceable>++</entry>

              <entry><replaceable>var</replaceable> =
              <replaceable>var</replaceable> + 1 (expression value is
              <replaceable>var</replaceable>)</entry>
            </row>

            <row>
              <entry class="operator">--<replaceable>var</replaceable></entry>

              <entry><replaceable>var</replaceable> =
              <replaceable>var</replaceable> – 1 (expression value is
              <replaceable>var</replaceable> – 1)</entry>
            </row>

            <row>
              <entry class="operator"><replaceable>var</replaceable>--</entry>

              <entry><replaceable>var</replaceable> =
              <replaceable>var</replaceable> – 1 (expression value is
              <replaceable>var</replaceable>)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var a, b;

a = 0;  
b = ++a;         // Increment a before b gets its value.
assert(a == b);  // 1 == 1  

a = 0;
b = a++;         // Increment a AFTER b gets its value.
assert(a != b);  // 1 != 0

a = 0;
b = --a;         // Decrement a before b gets its value.
assert(a == b);  // -1 == -1

a = 0;
b = a--;         // Decrement a AFTER b gets its value.
assert(a != b) ; // -1 != 0</programlisting>
    </sect2>

    <sect2 id="op-equality">
      <title>关系和相等操作符</title>

      <table class="operatorTable" id="equality_operator_table">
        <title>关系和相等操作符</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>操作符</entry>

              <entry>描述</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry class="operator">==</entry>

              <entry>相等</entry>
            </row>

            <row>
              <entry class="operator">!=</entry>

              <entry>不等</entry>
            </row>

            <row>
              <entry class="operator">&gt;</entry>

              <entry>大于</entry>
            </row>

            <row>
              <entry class="operator">&lt;</entry>

              <entry>小于</entry>
            </row>

            <row>
              <entry class="operator">&gt;=</entry>

              <entry>大于等于</entry>
            </row>

            <row>
              <entry class="operator">&lt;=</entry>

              <entry>小于等于</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>用 <literal
      moreinfo="none">==</literal> 来测试两个对象 <replaceable>x</replaceable> 和
      <replaceable>y</replaceable> 是否代表同一个东西。
      (在极少数情况下，你需要知道两个对象是否是同一个对象，则使用
      <literal><ulink
      url="http://api.dartlang.org/dart_core.html#identical">identical()</ulink></literal>
      函数。) 下面是 <literal moreinfo="none">==</literal>
      操作符工作原理：</para>

      <orderedlist continuation="restarts" inheritnum="ignore">
        <listitem>
          <para>如果 <replaceable>x</replaceable> 或者
          <replaceable>y</replaceable> 是 null，只有当另外一个也是 null 的时候才返回 true，
          否则只有一个为 null 则返回 false。</para>
        </listitem>

        <listitem>
          <para>然后执行 <literal
          moreinfo="none"><replaceable>x</replaceable>.==(<replaceable>y</replaceable>)</literal> 函数。
          (没错， <literal
          moreinfo="none">==</literal> 操作符就是第一个对象的函数。
          你也可以重写大部分操作符，包括 
          <literal>==</literal>，在  <xref
          linkend="classes-operators" /> 介绍如何重写操作符。)</para>
        </listitem>
      </orderedlist>

      <para>下面是使用关系和等于操作符的示例：</para>

      <programlisting format="linespecific"><remark>lang-dart</remark><remark>
ch02/op_equality.dart
</remark>assert(2 == 2);
assert(2 != 3);
assert(3 &gt; 2);
assert(2 &lt; 3);
assert(3 &gt;= 3);
assert(2 &lt;= 3);</programlisting>
    </sect2>

    <sect2 id="ch02-op-type-test">
      <title>类型测试操作符</title>

      <para> <literal moreinfo="none">as</literal>、 <literal
      moreinfo="none">is</literal>、和 <literal moreinfo="none">is!</literal>
      操作符是运行时判断类型的操作符。
      </para>

      <table class="typeTestTable" id="type_test_operator_table">
        <title>类型测试操作符</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>操作符</entry>

              <entry>描述</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>as</entry>

              <entry>Typecast（类型转换）</entry>
            </row>

            <row>
              <entry class="operator">is</entry>

              <entry>如果 对象是该类型 则返回 true</entry>
            </row>

            <row>
              <entry class="operator">is!</entry>

              <entry>如果 对象是该类型 则返回  false</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>
          只有当 <literal moreinfo="none">obj</literal> 实现了 <literal moreinfo="none">T</literal> 接口（类）
          的时候，  <literal moreinfo="none">obj is T</literal> 的结果才是 true 。 例如 <literal
      moreinfo="none">obj is Object</literal> 总是返回 true。</para>

      <para>用 <literal moreinfo="none">as</literal> 操作符把一个对象转换为
          另外一个类型。
          通常 用来替换 <literal moreinfo="none">is</literal> 判断后跟一个使用该 对象的表达式。
          例如，下面的示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>if (person is Person) {               // Type check
  person.firstName = 'Bob';
}</programlisting>

      <para>使用 <literal
      moreinfo="none">as</literal> 操作符可以简化代码：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>(person as Person).firstName = 'Bob';</programlisting>

      <note>
        <para>注意：上面的代码并不等同。如果 <literal>person</literal> 是 null
        或者 不是一个  Person，第一个示例 (使用 <literal>is</literal> 的) 不执行后面的代码；
        而第二个示例  (使用 <literal>as</literal> 的) 则会抛出一个 <phrase
        role="keep-together">异常</phrase>。</para>
      </note>
    </sect2>

    <sect2 id="op-assign">
      <title>赋值操作符</title>

      <para>前面已经见到过了，用 <literal
      moreinfo="none">=</literal> 来赋值。也可以用复合赋值操作符
      来赋值，例如 <literal moreinfo="none">+=</literal>。</para>

      <table id="assignment_operator_table" role="keep-together">
        <title>赋值操作符</title>

        <tgroup cols="6">
          <tbody>
            <row>
              <entry>=</entry>

              <entry>–=</entry>

              <entry>/=</entry>

              <entry>%=</entry>

              <entry>&gt;&gt;=</entry>

              <entry>^=</entry>
            </row>

            <row>
              <entry>+=</entry>

              <entry>*=</entry>

              <entry>~/=</entry>

              <entry>&lt;&lt;=</entry>

              <entry>&amp;=</entry>

              <entry>|=</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>下面是复合赋值操作符的工作原理</para>

      <informaltable id="assignment_operator_concepts_table">
        <tgroup cols="3">
          <thead>
            <row>
              <entry></entry>

              <entry>复合赋值操作符</entry>

              <entry>等同的表达式</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><emphasis role="bold">对于一个操作符
              <replaceable>op</replaceable>:</emphasis></entry>

              <entry><literal moreinfo="none">a <replaceable>op</replaceable>=
              b</literal></entry>

              <entry><literal moreinfo="none">a = a
              <replaceable>op</replaceable> b</literal></entry>
            </row>

            <row>
              <entry><emphasis role="bold">示例 </emphasis></entry>

              <entry><literal moreinfo="none">a += b</literal></entry>

              <entry><literal moreinfo="none">a = a + b</literal></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>下面示例使用了 赋值和复合赋值操作符：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var a = 2;           // Assign using =
a *= 3;              // Assign and multiply: a = a * 3
assert(a == 6);</programlisting>
    </sect2>

    <sect2 id="op-logical">
      <title>逻辑操作符（逻辑运算符）</title>

      <para>逻辑操作符可以组合和取反义操作。</para>

      <table class="operatorTable" id="logical_operator_table"
             role="keep-together">
        <title>逻辑操作符</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>操作符</entry>

              <entry>描述</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry class="operator">!<replaceable>expr</replaceable></entry>

              <entry>取表达式的反义 （如果表达式为 true，则结果为 false，反之亦然。）</entry>
            </row>

            <row>
              <entry class="operator">||</entry>

              <entry>逻辑或 OR</entry>
            </row>

            <row>
              <entry class="operator">&amp;&amp;</entry>

              <entry>逻辑与 AND</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>下面是使用逻辑操作符的示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>if (!done &amp;&amp; (col == 0 || col == 3)) {
  // ...Do something...
}</programlisting>
    </sect2>

    <sect2 id="op-bit">
      <title>位和移位操作符</title>

      <para>
          在 Dart 中可以操作每个数字的字节。
          通常在整数上使用 位和移位操作符。如下表所示 <xref linkend="bit_operator_table" /> 的操作符：</para>

      <table class="operatorTable" id="bit_operator_table">
        <title>位和移位操作符</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>操作符</entry>

              <entry>描述</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry class="operator">&amp;</entry>

              <entry>AND</entry>
            </row>

            <row>
              <entry class="operator">|</entry>

              <entry>OR</entry>
            </row>

            <row>
              <entry class="operator">^</entry>

              <entry>XOR</entry>
            </row>

            <row>
              <entry class="operator">~<replaceable>expr</replaceable></entry>

              <entry>一元位补码操作符 (0s 变为 1s； 1s 变为
              0s)</entry>
            </row>

            <row>
              <entry class="operator">&lt;&lt;</entry>

              <entry>左移</entry>
            </row>

            <row>
              <entry class="operator">&gt;&gt;</entry>

              <entry>右移</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>下面是使用位和移位操作符的示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>final value = 0x22;
final bitmask = 0x0f;

assert((value &amp; bitmask)  == 0x02);  // AND
assert((value &amp; ~bitmask) == 0x20);  // AND NOT
assert((value | bitmask)  == 0x2f);  // OR
assert((value ^ bitmask)  == 0x2d);  // XOR
assert((value &lt;&lt; 4)       == 0x220); // Shift left
assert((value &gt;&gt; 4)       == 0x02);  // Shift right</programlisting>
    </sect2>

    <sect2 id="op-other">
      <title>其他操作符</title>

      <para>其他一些没介绍的操作符，但是大部分你应该在其他地方都看到过了。</para>

      <table class="operatorTable" id="other_operator_table"
             role="keep-together">
        <title>其他操作符</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry style="text-align:center">操作符</entry>

              <entry>名字</entry>

              <entry>描述</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry class="operator">()</entry>

              <entry>方法调用</entry>

              <entry>代表调用一个方法</entry>
            </row>

            <row>
              <entry class="operator">[]</entry>

              <entry>List 访问</entry>

              <entry>获取 list 某个位置的内容</entry>
            </row>

            <row>
              <entry
              class="operator"><replaceable>expr1</replaceable>&nbsp;?&nbsp;<replaceable>expr2</replaceable>&nbsp;:&nbsp;<replaceable>expr3</replaceable></entry>

              <entry>条件表达式</entry>

              <entry>如果 <replaceable>expr1</replaceable> 是 true，执行 
              <replaceable>expr2</replaceable>；否则，执行
              <replaceable>expr3</replaceable></entry>
            </row>

            <row>
              <entry class="operator">.</entry>

              <entry>成员访问</entry>

              <entry>访问一个成员，例如 <literal
              moreinfo="none">foo.bar</literal> 选择属性 ，访问
              <literal
              moreinfo="none">foo</literal>
              对象的 <literal
              moreinfo="none">bar</literal> 属性 </entry>
            </row>

            <row>
              <entry class="operator">..</entry>

              <entry>级联操作符</entry>

              <entry>可以在同一个对象上执行多个炒作 ，参考  <xref
              linkend="classes" /></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect2>
  </sect1>

  <sect1 id="control-flow-statements">
    <title>控制流程语句</title>

    <para>使用如下控制语句可以控制 Dart 代码的执行流程：</para>

    <itemizedlist>
      <listitem>
        <para><literal moreinfo="none">if</literal> 和 <literal
        moreinfo="none">else</literal></para>
      </listitem>

      <listitem>
        <para><literal moreinfo="none">for</literal> 循环</para>
      </listitem>

      <listitem>
        <para><literal moreinfo="none">while</literal> 和 <literal
        moreinfo="none">do</literal>-<literal moreinfo="none">while</literal>
        循环</para>
      </listitem>

      <listitem>
        <para><literal moreinfo="none">break</literal> 和 <literal
        moreinfo="none">continue</literal></para>
      </listitem>

      <listitem>
        <para><literal moreinfo="none">switch</literal> 和 <literal
        moreinfo="none">case</literal></para>
      </listitem>

      <listitem>
        <para><literal moreinfo="none">assert</literal></para>
      </listitem>
    </itemizedlist>

    <para>使用  <literal
    moreinfo="none">try-catch</literal> 和 <literal
    moreinfo="none">throw</literal> 也可以影响执行流程，在 <xref
    linkend="exceptions" /> 中有详细介绍。</para>

    <sect2 id="if-else">
      <title>If 和 Else</title>

      <para>Dart 支持 <literal moreinfo="none">if</literal> 语句和可选的
      <literal moreinfo="none">else</literal> 语句。
      在  <xref linkend="op-other" /> 还介绍了条件表达式 (?:)。</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>if (isRaining()) {
  you.bringRainCoat();
} else if (isSnowing()) {
  you.wearJacket();
} else {
  car.putTopDown();
}</programlisting>

      <para>注意： Dart 和 JavaScript 不同， 在 Dart 中只有
      <literal moreinfo="none">true</literal> 才被当做 true，所有其他对象都是 <literal
      moreinfo="none">false</literal>。详细信息参考 <xref linkend="booleans" /> 。</para>
    </sect2>

    <sect2 id="for-loops">
      <title>For 循环</title>

      <para>如下是标准的 <literal
      moreinfo="none">for</literal> 循环示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/flow_for_loops.dart
</remark>var message = new StringBuffer("Dart is fun");
for (var i = 0; i &lt; 5; i++) {
  message.write('!');
}</programlisting>

      <para> Dart <literal moreinfo="none">for</literal>循环中的闭包捕获
          循环的索引，避免 JavaScript 中出现的弊端。例如：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/flow_for_loops.dart
</remark>var callbacks = [];
for (var i = 0; i &lt; 2; i++) {
  callbacks.add(() =&gt; print(i));
}
callbacks.forEach((c) =&gt; c());</programlisting>

      <para>打印的结果为  <literal moreinfo="none">0</literal> 然后是 
      <literal moreinfo="none">1</literal>，和预期的结果一样。
      而在 JavaScript 中，结果会是  <literal moreinfo="none">2</literal> 和
      <literal moreinfo="none">2</literal> 。</para>

      <para>如果循环的对象是一个 Iterable ，则可以用 <literal><ulink
      url="http://api.dartlang.org/dart_core/Iterable.html#forEach">forEach()</ulink></literal>
      函数。如果无需关心当前的循环索引，则使用 <literal>forEach()</literal>
      是更好的选择：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/flow_for_loops.dart
</remark>candidates.forEach((candidate) =&gt; candidate.interview());</programlisting>

      <para>像 List 和 Set 这种 Iterable 对象还支持 <literal
      moreinfo="none">for-in</literal> 循环，在
      <phrase lang="" role="">in <xref
      linkend="ch03-iteration" /> 有介绍：</phrase></para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/flow_for_loops.dart
</remark>var collection = [0, 1, 2];
for (var x in collection) {
  print(x);
}</programlisting>
    </sect2>

    <sect2 id="while">
      <title>While 和 Do-While</title>

      <para>一个 <literal moreinfo="none">while</literal> 循环会在循环开始之前先
          计算条件的值：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>while(!isDone()) {
  doSomething();
}</programlisting>

      <para>而 一个 <literal moreinfo="none">do</literal>-<literal
      moreinfo="none">while</literal>  循环会先循环后计算
      条件的值：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>do {
  printLine();
} while (!atEndOfPage());</programlisting>
    </sect2>

    <sect2 id="break">
      <title>Break 和 Continue</title>

      <para>使用 <literal moreinfo="none">break</literal> 来终止
          循环：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>while (true) {
  if (shutDownRequested()) break;
  processIncomingRequests();
}</programlisting>

      <para>使用 <literal moreinfo="none">continue</literal> 
	来跳到下一个循环：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>for (int i = 0; i &lt; candidates.length; i++) {
  var candidate = candidates[i];
  if (candidate.yearsExperience &lt; 5) {
    continue;
  }
  candidate.interview();
}</programlisting>

      <para>如果使用  list 或者 set 则实现方式可以有所不同：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>candidates.where((c) =&gt; c.yearsExperience &gt;= 5)
          .forEach((c) =&gt; c.interview());</programlisting>
    </sect2>

    <sect2 id="switch">
      <title>Switch 和 Case</title>

      <para>Dart 中的 Switch 语句用 <literal moreinfo="none">==</literal> 来比较 integer、 string、或者编译期常量
           。被比较的对象必须为同一个类的实例（子类型不可以），并且类必须没有重写 <literal
      moreinfo="none">==</literal> 操作符。</para>

      <para>规则需要每个非空 <literal moreinfo="none">case</literal> 块以
       <literal moreinfo="none">break</literal> 语句结尾。
      其他非空
      <literal
      moreinfo="none">case</literal> 块可以是一个
      <literal
      moreinfo="none">continue</literal>、 <literal
      moreinfo="none">throw</literal>、或者 <literal
      moreinfo="none">return</literal> 语句。</para>

      <para>使用一个 <literal moreinfo="none">default</literal> 语句来执行
          不匹配任何 <literal moreinfo="none">case</literal> 语句的情况：</para>

      <programlisting format="linespecific" role="keep-together"><remark>lang-dart
</remark>var command = 'OPEN';
switch (command) {
  case 'CLOSED':
    executeClosed();
    break;
  case 'PENDING':
    executePending();
    break;
  case 'APPROVED':
    executeApproved();
    break;
  case 'DENIED':
    executeDenied();
    break;
  case 'OPEN':
    executeOpen();
    break;
  default:
    executeUnknown();
}</programlisting>

      <para>下面的示例代码在 <literal
      moreinfo="none">case</literal> 块中忘记添加
       <literal
      moreinfo="none">break</literal> 语句了， 这样会产生一个错误：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var command = 'OPEN';
switch (command) {
  case 'OPEN':
    executeOpen();
    // ERROR: 丢掉 break 语句会抛出一个异常！！

  case 'CLOSED':
    executeClosed();
    break;
}</programlisting>

      <para>然而， Dart 支持空 <literal
      moreinfo="none">case</literal> 块，空快可以允许执行后面一个 case 块的功能：</para>

      <programlisting format="linespecific" role=""><remark>lang-dart
</remark>var command = 'CLOSED';
switch (command) {
  case 'CLOSED':     // 空块会漏到下个块执行
  case 'NOW_CLOSED':
    //  CLOSED 和 NOW_CLOSED 都会执行该代码
    executeNowClosed();
    break;
}</programlisting>

      <para>如果你真的需要执行下一个 case 块中的代码，则可以用一个  <literal
      moreinfo="none">continue</literal> 语句和一个 label 组合：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var command = 'CLOSED';
switch (command) {
  case 'CLOSED':
    executeClosed();
    continue nowClosed; // 继续执行 nowClosed label

nowClosed:
  case 'NOW_CLOSED':
    // CLOSED 和 NOW_CLOSED 都会执行该代码
    executeNowClosed();
    break;
}</programlisting>

      <para> <literal moreinfo="none">case</literal> 块可以有本地变量，
          该变量只在该 case 块中可见。</para>
    </sect2>

    <sect2 id="assert">
      <title>Assert（断言）</title>

      <para>使用 <literal moreinfo="none">assert</literal> 
      语句来检测执行条件，如果提供的条件是 false 则中断执行并抛出异常。下面是一个
      assert 示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>assert(text != null);  // 确保 text 不为 null
assert(number &lt; 100);  // 确保该值小于 100.
assert(urlString.startsWith('https')); // 确保字符串以 https 开头</programlisting>

      <note>
        <para>Assert 语句只在检测模式下有效。
            在生产模式下无任何效果。</para>
      </note>

      <para> <literal
      moreinfo="none">assert</literal> 的参数可以是任何结果为 布尔 值的表达式或者方法。
      如果表达式或者方法的返回值为 true， 则通过断言检测代码继续执行。否则，断言将抛出一个异常  (是一个 <ulink
      url="http://api.dartlang.org/dart_core/AssertionError.html">AssertionError</ulink>)。
      </para>
    </sect2>
  </sect1>

  <sect1 id="exceptions">
    <title>Exceptions（异常）</title>

    <para>
        Dart 代码可以抛出和捕获异常。异常代表不可预期的错误情况。如果没有捕获异常，
        则抛出该异常的 isolate 将被挂起，通常该 isolate 就退出执行了。</para>

    <para>和 Java 语言不同， Dart 的所有异常都是 非检查异常（unchecked exceptions）。
        函数不用声明其可能抛出的异常，并且你也无捕获任何 <phrase
    role="keep-together">exceptions（异常）</phrase>。</para>

    <para>Dart 提供了 <ulink
    url="http://api.dartlang.org/dart_core/Exception.html">Exception</ulink>
    和 <ulink
    url="http://api.dartlang.org/docs/continuous/dart_core/Error.html">Error</ulink>
    类型，和很多预定义的子类。你也可以定义自己的异常类型。
    然而，Dart 程序可以把任意非 null 对象当做异常抛出，而不仅仅是  Exception 和 Error 对象。</para>

    <sect2 id="ch02-exceptions-throw">
      <title>Throw</title>

      <para>下面是 <emphasis>抛出</emphasis> 异常的示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>throw new ExpectException('Value must be greater than zero');</programlisting>

      <para>还可以抛出其他任意对象：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>throw 'Out of llamas!';</programlisting>

      <para>
          由于抛出异常是一个表达式，所有在任意可以用表达式的地方都可以抛出异常，
          例如  =&gt; 语句。</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>distanceTo(Point other) =&gt; throw new UnimplementedError();</programlisting>
    </sect2>

    <sect2 id="ch02-exceptions-catch">
      <title>Catch</title>

      <para>捕获异常可以阻止异常继续传递下去。捕获异常提供了一个处理该异常的机会：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>try {
  breedMoreLlamas();
} on OutOfLlamasException {
  buyMoreLlamas();
}</programlisting>

      <para>
          要处理可能抛出多个类型异常的情况，你可以用多个
          catch 语句。 如果第一个 catch 语句不匹配该异常，则执行下一个。
          如果一个 catch 语句没有设置特殊的异常类型，则该 catch 语句可以处理
          所有 类型的异常：</para>

      <programlisting format="linespecific" role="keep-together"><remark>lang-dart
</remark>try {
  breedMoreLlamas();
} on OutOfLlamasException {           // 一个具体的异常
  buyMoreLlamas();
} on Exception catch(e) {             // 任意 Exception 异常
  print('Unknown exception: $e');
} catch(e) {                          // 处理所有异常
  print('Something really unknown: $e');
}</programlisting>

      <para>
          如上代码所示， 你可以用
           <literal
      moreinfo="none">on</literal> 或者 <literal moreinfo="none">catch</literal>
      ，也可以同时使用。当需要指定异常类型的时候，用 <literal moreinfo="none">on</literal>。
      当需要使用 异常 对象的时候，用  <literal moreinfo="none">catch</literal>
	。      </para>
    </sect2>

    <sect2 id="ch02-exceptions-finally">
      <title>Finally</title>

      <para>
           <literal moreinfo="none">finally</literal> 块中的代码不管是否出现异常
           都会执行。如果没有 <literal>catch</literal> 捕获异常，则异常会在执行
           完 <literal>finally</literal> 块之后继续传递下去：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>try {
  breedMoreLlamas();
} finally {
  cleanLlamaStalls();  // 总是清理现场，不管是否抛出异常
}</programlisting>

      <para><literal>finally</literal> 块在
      <literal>catch</literal> 块之后执行：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>try {
  breedMoreLlamas();
} catch(e) {
  print('Error: $e');  // 先处理异常
} finally {
  cleanLlamaStalls();  // 再执行清理
}</programlisting>

      <para>更多信息请参考 <xref linkend="ch03-exceptions" />。</para>
    </sect2>
  </sect1>

  <sect1 id="classes">
    <title>Classes</title>

    <para>Dart 是面向对象的语言，支持 类和单继承。
        每个对象都是一个类的实例，所有的类都是 
    <ulink
    url="http://api.dartlang.org/dart_core/Object.html">Object</ulink> 的子类。</para>

    <para>可以用 <literal
    moreinfo="none">new</literal> 关键字和 类的
    <firstterm>构造函数</firstterm> 创建对象。
    构造函数的名字可以为
      <emphasis><replaceable>ClassName</replaceable></emphasis> 或者
    <replaceable>ClassName.identifier</replaceable>。例如：</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>var jsonData = JSON.decode('{"x":1, "y":2}');

var p1 = new Point(2,2);               // 用 Point() 创建一个 Point 对象。
var p2 = new Point.fromJson(jsonData); // 用 Point.fromJson() 构造函数创建 Point 对象</programlisting>

    <para>对象有<firstterm>成员变量</firstterm> 构成的数据和方法 (<firstterm>函数</firstterm> 和 <firstterm> 
    实例变量</firstterm> )。 当调用一个函数的时候，
    该函数可以访问对象的数据：</para>

    <para>使用一个圆点 (.) 来访问对象的变量或者函数：</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>var p = new Point(2,2);

p.y = 3;             // 设置实例变量 y 的值
assert(p.y == 3);    // 访问实例变量 y 的值

num distance = p.distanceTo(new Point(4,4)); // 调用 p 的 distanceTo() 函数</programlisting>

    <para>当想在同一个对象上执行多个操作的时候，可以用级联操作符  (..) ：</para>

    <programlisting format="linespecific" role="keep-together"><remark>lang-dart
</remark>querySelector('#button')
    ..text = 'Click to Confirm'                        // Get an object. Use its
    ..classes.add('important')                         // instance variables
    ..onClick.listen((e) =&gt; window.alert('Confirmed!')); // and methods.</programlisting>

    <para>
        有些类提供了常量构造函数。可以用来创建编译期常量对象，用
         <literal
    moreinfo="none">const</literal> 关键字而不是  <literal
    moreinfo="none">new</literal> 来调用这种构造函数：</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>var p = const ImmutablePoint(2,2);</programlisting>

    <para>用常量构造函数创建两个一样的常量，这两个
        常量是 同一个 <phrase role="keep-together">实例：</phrase></para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>var a = const ImmutablePoint(1, 1);
var b = const ImmutablePoint(1, 1);

assert(identical(a,b)); // 同一个实例！</programlisting>

    <para>下面的小节介绍如何定义类</para>

    <sect2 id="ch02-instance-variables">
      <title>实例变量</title>

      <para>下面是定义实例变量的示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/instance_variables.dart
</remark>class Point {
  num x;      // 定义一个实例变量 (x)，初始值为 null。
  num y;      // 定义 y， 初始值为  null。
  num z = 0;  // 定义 z， 初始值为 0。
}</programlisting>

      <para>所有没有初始化的实例变量的值都是 <literal
      moreinfo="none">null</literal>。</para>

      <para>
          所有实例变量都自动生成一个隐含的
      <firstterm>getter</firstterm> 函数。非 final 实例变量也生成了一个隐含的
      <firstterm>setter</firstterm> 函数。详情请参考
        <xref linkend="classes-getters-and-setters" />。</para>

      <programlisting format="linespecific" role=""><remark>lang-dart
</remark><remark>ch02/instance_variables.dart
</remark>class Point {
  num x;
  num y;
}

main() {
  var point = new Point();
  point.x = 4;             // 调用 x 的 setter 函数
  assert(point.x == 4);    // 调用 x 的 getter 函数
  assert(point.y == null); // 默认值为 null。
}</programlisting>

      <para>
          如果你在定义实例变量的时候就设置她的值，而不是在构造函数或者其他函数中设置，则该实例创建的时候赋值变量的值。
	赋值操作发生在构造函数和初始化列表执行之前。</para>
    </sect2>

    <sect2 id="ch02-constructors">
      <title>构造函数</title>

      <para>
          构造函数的名字和类的名字一样（还可以附加其他关键字，<xref linkend="ch02-constructors-named" />）。
          常用的构造函数就是用来创建一个类的实例的：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/constructor_long_way.dart
</remark>class Point {
  num x;
  num y;

  Point(num x, num y) {
    // 这种初始化赋值操作还有更好的实现方式，请往下看！
    this.x = x;
    this.y = y;
  }
}</programlisting>

      <para>  <literal moreinfo="none">this</literal> 关键字引用当前实例。</para>

      <note>
        <para>只有在有名字冲突的时候才使用 <literal moreinfo="none">this</literal> 。
            其他情况， Dart 风格指南建议忽略
             <literal
        moreinfo="none">this</literal>。</para>
      </note>

      <para>
          把构造函数参数赋值给实例变量是如此的常见，所以 Dart 提供了一个语法糖让该操作更加便捷：</para>

      <programlisting format="linespecific" role="keep-together"><remark>lang-dart
</remark>class Point {
  num x;
  num y;

  // 在构造函数体执行之前设置实例变量的语法糖
  Point(this.x, this.y);
}</programlisting>

      <sect3 id="ch02-constructors-default">
        <title>默认构造函数</title>

        <para>如果没有定义构造函数，则会生成一个默认构造函数。
            默认构造函数没有参数，并调用没有参数的 <phrase
        role="keep-together">superclass（父类）</phrase> 构造函数。</para>
      </sect3>

      <sect3 id="ch02-constructors-not-inherited">
        <title>构造函数不支持继承</title>

        <para>
            子类并没有继承父类的构造函数。
            一个没有定义构造函数的子类只有无参数无名子的默认构造函数。</para>
      </sect3>

      <sect3 id="ch02-constructors-named">
        <title>命名构造函数</title>

        <para>
            用命名构造函数来提供多个构造函数或者提供更加清晰的信息：</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/named_constructor.dart
</remark>class Point {
  num x;
  num y;

  Point(this.x, this.y);

  // 命名构造函数
  Point.fromJson(Map json) {
    x = json['x'];
    y = json['y'];
  }
}</programlisting>

        <para>
            注意：构造函数不支持继承，所以子类也没有继承父类的命名构造函数。
            如果你想让子类也能用父类的命名构造函数，则你必需在子类中定义并实现该构造函数。</para>
      </sect3>

      <sect3 id="ch02-constructor-non-default-superclass">
        <title>调用不是默认的父类构造函数</title>

        <para>
            默认情况下，子类的构造函数会调用父类的默认构造函数。
            如果父类没有无名无参数的默认构造函数，则子类必需
            手工的调用一个父类构造函数。
           在冒号
        (<literal>:</literal>) 后面和构造函数体之前指定要调用的父类构造函数。</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/op_as.dart
</remark>class Person {
  Person.fromJson(Map data) {
    print('in Person');
  }
}

class Employee extends Person {
  // Person 没有默认构造函数
  // 所以必需指定 super.fromJson(data) 构造函数
  Employee.fromJson(Map data) : super.fromJson(data) {
    print('in Employee');
  }
}

main() {
  var emp = new Employee.fromJson({});

  // 打印结果：
  // in Person
  // in Employee
}</programlisting>

        <para>
            由于调用父类构造函数的参数在执行构造函数之前执行，
            所有可以用表达式作为参数，例如 用一个方法：</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/method_then_constructor.dart
</remark>class Employee extends Person {
  ...
  Employee() : super.fromJson(findDefaultData());
}</programlisting>

        <warning>
          <para>
              调用父类构造函数的参数无法访问 
          <literal moreinfo="none">this</literal> 对象。
          例如，参数可以访问静态函数当时无法访问实例函数。</para>
        </warning>
      </sect3>

      <sect3 id="ch02-constructor-initializer-list">
        <title>初始化列表</title>

        <para>
            除了调用父类构造函数外，也可以在执行构造函数体之前来初始化实例变量。
            用逗号分割多少初始化变量。</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/initializer_list.dart
</remark>class Point {
  num x;
  num y;

  Point(this.x, this.y);

  // 初始化列表在构造函数体执行之前设置实例变量
  Point.fromJson(Map json) : x = json['x'], y = json['y'] {
    print('In Point.fromJson(): ($x, $y)');
  }
}</programlisting>

        <warning>
          <para> 右边的初始化列表无法访问 
          <literal moreinfo="none">this</literal>.</para>
        </warning>
      </sect3>

      <sect3 id="ch02-constructor-redirecting">
        <title>重定向构造函数</title>

        <para>有些构造函数只是调用
         <phrase role="keep-together">同一个类</phrase> 的另外一个构造函数。
         重定向构造函数体是空的，被调用的构造函数放到冒号后面。</phrase></para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/along_x_axis.dart
</remark>class Point {
  num x;
  num y;

  Point(this.x, this.y);                // 该类的主要构造函数
  Point.alongXAxis(num x) : this(x, 0); // 调用主要构造函数
}</programlisting>
      </sect3>

      <sect3 id="ch02-constructor-constant">
        <title>常量构造函数</title>

        <para>
            如果你的类生成从来不改变的对象，则可以把这些对象定义为编译期常量。
            用一个 <literal
        moreinfo="none">const</literal> 
        构造函数并把实例变量设置为  <literal
        moreinfo="none">final</literal> 来实现该功能。</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/immutable_point.dart
</remark>class ImmutablePoint {
  final num x;
  final num y;
  const ImmutablePoint(this.x, this.y);
  static final ImmutablePoint origin = const ImmutablePoint(0, 0);
}</programlisting>
      </sect3>

      <sect3 id="ch02-constructor-factory">
        <title>工厂构造函数</title>

        <para>如果一个构造函数并不总是创建一个新的对象，则可以用
            <literal moreinfo="none">factory</literal> 关键字来实现构造函数。
            例如，一个工厂构造函数可以从缓存中返回一个实例，也可以返回一个子类型的实例。</para>

        <para>下面演示了从缓存返回实例的工厂构造函数：</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/factory_constructor.dart
</remark>class Logger {
  final String name;
  bool mute = false;

  // _cache is library-private, thanks to the _ in front of its name.
  static final Map&lt;String, Logger&gt; _cache = &lt;String, Logger&gt;{};
  
  factory Logger(String name) {
    if (_cache.containsKey(name)) {
      return _cache[name];
    } else {
      final logger = new Logger._internal(name);
      _cache[name] = logger;
      return logger;
    }
  }
  
  Logger._internal(this.name);
  
  void log(String msg) {
    if (!mute) {
      print(msg);
    }
  }
}</programlisting>

        <note>
          <para>工厂构造函数无法访问  <literal
          moreinfo="none">this</literal>。</para>
        </note>

        <para>用 <literal
        moreinfo="none">new</literal> 关键字调用工厂构造函数：</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/factory_constructor.dart
</remark>var logger = new Logger('UI');
logger.log('Button clicked');</programlisting>
      </sect3>
    </sect2>

    <sect2 id="ch02-methods">
      <title>函数</title>

      <para>
          函数定义了一个对象的行为。</para>

      <sect3 id="ch02-methods-instance">
        <title>实例函数</title>

        <para>对象的实例函数可以访问实例变量和 
        <literal moreinfo="none">this</literal>。
        下面示例的 
        <literal>distanceTo()</literal> 函数就是一个
        实例函数：</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/distance_to.dart
</remark>import 'dart:math';

class Point {
  num x;
  num y;
  Point(this.x, this.y);

  num distanceTo(Point other) {
    var dx = x - other.x;
    var dy = y - other.y;
    return sqrt(dx * dx + dy * dy);
  }
}</programlisting>
      </sect3>

      <sect3 id="classes-getters-and-setters">
        <title>Getters 和 setters</title>

        <para>Getters 和 setters 
            是特殊的用来设置和访问实例变量的函数。
            每个实例变量都有一个隐含的 getter，非 final 变量还有一个 setter 函数。
            通过显式的实现 getter 和 setter 可以附件额外的功能。
            用
        <literal moreinfo="none">get</literal> 和 <literal
        moreinfo="none">set</literal> 关键字实现 getter 和 setter：</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/rectangle.dart
</remark>class Rectangle {
  num left;
  num top;
  num width;
  num height;

  Rectangle(this.left, this.top, this.width, this.height);

  // 定义两个计算出来的属性：right 和 bottom.
  num get right             =&gt; left + width;
      set right(num value)  =&gt; left = value - width;
  num get bottom            =&gt; top + height;
      set bottom(num value) =&gt; top = value - height;
}

main() {
  var rect = new Rectangle(3, 4, 20, 15);
  assert(rect.left == 3);
  rect.right = 12;
  assert(rect.left == -8);
}</programlisting>

        <para>有了 getters 和 setters，你可以先直接用实例变量，
            当发现需要添加额外操作了再用 getter 和 setter 包起来，
            这样调用代码无需做任何修改。</para>

        <para><note>
            <para>
                对于 ++ 这种操作符而言，不管是否显式定义 getter 情况都有点特殊。
                为了避免其他副作用，操作符只调用一次 getter 并缓存该返回值。</para>
          </note></para>
      </sect3>

      <sect3 id="ch02-method-abstract">
        <title>抽象函数</title>

        <para>实例函数、 getter、 和 setter 都可以为抽象函数，
            只定义接口，由子类来实现该函数。
            用分号
           (;) 结尾 没有函数体的函数就是抽象函数：</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/doer.dart
</remark>abstract class Doer {
  // ...Define instance variables and methods...
 
  void doSomething(); // 定义一个抽象函数
}

class EffectiveDoer extends Doer {
  void doSomething() {
    // ...Provide an implementation, so the method is not abstract here...
  }
}</programlisting>

        <para>调用一个抽象函数在运行的时候会出现异常。</para>

        <para>参考 <xref linkend="ch02-class-abstract" />。</para>
      </sect3>

      <sect3 id="classes-operators">
        <title>重写操作符</title>

        <para>可以重新  <xref
        linkend="overridden_operator_table" /> 表中的操作符。例如，
        如果你定义一个
        Vector 类，则可以重写 <literal>+</literal> 函数来实现 vector 相加操作。</para>

        <table id="overridden_operator_table" role="keep-together">
          <title>可被重写的操作符</title>

          <tgroup cols="4">
            <tbody>
              <row>
                <entry>&lt;</entry>

                <entry>+</entry>

                <entry>|</entry>

                <entry>[]</entry>
              </row>

              <row>
                <entry>&gt;</entry>

                <entry>/</entry>

                <entry>^</entry>

                <entry>[]=</entry>
              </row>

              <row>
                <entry>&lt;=</entry>

                <entry>~/</entry>

                <entry>&amp;</entry>

                <entry>~</entry>
              </row>

              <row>
                <entry>&gt;=</entry>

                <entry>*</entry>

                <entry>&lt;&lt;</entry>

                <entry>==</entry>
              </row>

              <row>
                <entry>–</entry>

                <entry>%</entry>

                <entry>&gt;&gt;</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>下面是一个重写  <literal
        moreinfo="none">+</literal> 和 <literal moreinfo="none">-</literal>
        操作符的示例：</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/vector.dart
</remark>class Vector {
  final int x;
  final int y;
  const Vector(this.x, this.y);

  Vector operator +(Vector v) { // Overrides + (a + b).
    return new Vector(x + v.x, y + v.y);
  }

  Vector operator -(Vector v) { // Overrides - (a - b).
    return new Vector(x - v.x, y - v.y);
  }
}

main() {
  final v = new Vector(2,3);
  final w = new Vector(2,2);

  assert(v.x == 2 &amp;&amp; v.y == 3);         // v   == (2,3)
  assert((v+w).x == 4 &amp;&amp; (v+w).y == 5); // v+w == (4,5)
  assert((v-w).x == 0 &amp;&amp; (v-w).y == 1); // v-w == (0,1)
}</programlisting>

        <para>重写  <literal
        moreinfo="none">==</literal> 的示例在  <xref
        linkend="ch03-implementing-map-keys" /> 有介绍。
        关于重写的更多信息，参考 <xref
        linkend="ch02-class-extend" />。</para>
      </sect3>
    </sect2>

    <sect2 id="ch02-class-abstract">
      <title>抽象类</title>

      <para>使用 <literal moreinfo="none">abstract</literal>
          修饰符来定义一个  <firstterm>抽象类</firstterm>，抽象类无法被实例化。
          抽象类通常用于定义接口并具有一些基本行为实现。如果你想让你的抽象类看起来是可被实例化的，则可以提供一个
      <link
      linkend="ch02-constructor-factory">工厂构造函数</link>。</para>

      <para>抽象类一般都有 <link
      linkend="ch02-method-abstract">抽象函数</link>。
      下面是一个定义抽象类和抽象方法的示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/abstract.dart
</remark>// 该类为 abstract 的，所以无法实例化
abstract class AbstractContainer {
  // ...Define constructors, fields, methods...

  void updateChildren(); // 抽象函数
}</programlisting>

      <para>下面的类虽然有抽象函数，但是并不是抽象类，所以可以实例化：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/abstract.dart
</remark>class SpecializedContainer extends AbstractContainer {
  // ...Define more constructors, fields, methods...

  void updateChildren() {
    // ...Implement updateChildren()...
  }
// Abstract method causes a warning but doesn't prevent instantiatation.
  void doSomething(); 
}</programlisting>
    </sect2>

    <sect2 id="ch02-implicit-interfaces">
      <title>隐式接口（Implicit Interfaces）</title>

      <para>
          每个类都隐式的定义了一个包含所有实例变量和所实现所有接口的接口。
          如果你想创建一个类 A 支持 类 B 的 API，但是又不想继承类 B 的实现，则类 A 可以实现
          类 B 的隐式接口。</para>

      <para>
          类通过
      <literal moreinfo="none">implements</literal> 语句来定义其实现的其他类的接口，
      并实现需要的 API。 例如：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/imposter.dart
</remark>// 一个  person 类， 隐式接口包含  greet().
class Person {
  final _name;          // 该变量在隐式接口中，但是是库返回可见的
  Person(this._name);   // 这是个构造函数，不在隐式接口中
  String greet(who) =&gt; 'Hello, $who. I am $_name.'; // 在隐式接口中
}

// 实现 Person 的隐式接口。
class Imposter implements Person {
  final _name = "";      // We have to define this, but we don't use it.
  String greet(who) =&gt; 'Hi $who. Do you know who I am?';
}

greetBob(Person person) =&gt; person.greet('bob');

main() {
  print(greetBob(new Person('kathy')));
  print(greetBob(new Imposter()));
}</programlisting>

      <para>下面是实现多个接口的示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/point_interfaces.dart
</remark>class Point <emphasis role="bold">implements Comparable, Location</emphasis> {
  // ...
}</programlisting>
    </sect2>

    <sect2 id="ch02-class-extend">
      <title>继承一个类</title>

      <para>用 <literal moreinfo="none">extends</literal> 
      来继承类，在子类中用 <literal moreinfo="none">super</literal> 
      访问父类：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>smart_tv.dart
</remark>class Television {
  void turnOn() {
    _illuminateDisplay();
    _activateIrSensor();
  }
  ...
}

class SmartTelevision extends Television {
  void turnOn() {
    super.turnOn();
    _bootNetworkInterface();
    _initializeMemory();
    _upgradeApps();
  }
  ...
}</programlisting>

      <para>
          子类可以重写实例函数、getter 、和 setter。
          下面是一个重写 Object 类
      <literal>noSuchMethod()</literal> 函数的示例，该函数在
      调用一个不存在的函数或者实例变量时触发：</para>

      <programlisting><remark>lang-dart
</remark><remark>ch02/no_such_method.dart
</remark>class A {
  // Unless you override noSuchMethod, using a non-existent member
  // results in a NoSuchMethodError.
  void noSuchMethod(Invocation mirror) {
    print('You tried to use a non-existent member: ${mirror.memberName}');
  }
}</programlisting>

      <para>可以用 <literal>@override</literal> 注解来表明你需要
          重写该函数或者变量：</para>

      <programlisting><remark>lang-dart
</remark><remark>ch02/ch02_meta/bin/ch02_override.dart
</remark>class A {
  @override
  void noSuchMethod(Invocation mirror) {
    // ...
  }
}</programlisting>

      <para>如果用 <literal>noSuchMethod()</literal> 实现了所有可能的
        getter、 setter、 和一个类的函数，则可以用
      <literal>@proxy</literal> 注解来避免警告信息：</para>

      <programlisting><remark>lang-dart
</remark><remark>ch02/ch02_meta/bin/ch02_proxy.dart
</remark>@proxy
class A {
  void noSuchMethod(Invocation mirror) {
    // ...
  }
}</programlisting>

      <para>关于注解的详细信息，参考 <xref
      linkend="ch02-metadata" />。</para>
    </sect2>

    <sect2 id="ch02-mixins">
      <title>在类中添加功能： Mixins（混入）</title>

      <para>Mixins 是一种不用继承就可以在一个类中
          添加功能的方法。</para>

      <para>用  <literal>with</literal> 关键字后跟
          一个或者多个 mixin 名字来实现 mixin。
     下面的代码演示了 mixin 的两个示例：</para>

      <programlisting><remark>lang-dart
</remark><remark>ch02/mixins.dart
</remark>class Musician extends Performer with Musical {
  ...
}

class Maestro extends Person with Musical, Aggressive, Demented {
  Maestro(String maestroName) {
    name = maestroName;
    canConduct = true;
  }
}</programlisting>

      <para>
          如何创建 mixin：定义一个继承 Object 的类，不定义构造函数也不调用
          <literal>super</literal> 即可。例如：</para>

      <programlisting><remark>lang-dart
</remark><remark>ch02/mixins.dart
</remark>abstract class Musical {
  bool canPlayPiano = false;
  bool canCompose = false;
  bool canConduct = false;
  
  void entertainMe() {
    if (canPlayPiano) {
      print('Playing piano');
    } else if (canConduct) {
      print('Waving hands');
    } else {
      print('Humming to self');
    }
  }
}</programlisting>

      <para>详细信息请参考  <ulink
      url="http://www.dartlang.cc/articles/mixins/">Mixins in
      Dart</ulink> 文章。</para>
    </sect2>

    <sect2 id="ch02-class-vars-and-methods">
      <title>类（静态）变量和函数</title>

      <para>用 <literal moreinfo="none">static</literal> 关键字实现类
          变量和函数。</para>

      <sect3 id="ch02-static-variables">
        <title>静态变量</title>

        <para>静态变量 (类变量) 用于类范围的状态和常量：</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/color.dart
</remark>class Color {
  static const RED = const Color('red'); // 一个静态常量
  final String name;                     // 一个实例变量
  const Color(this.name);                // 一个常量构造函数
}

main() {
  assert(Color.RED.name == 'red');
}</programlisting>

        <para>静态变量在使用的时候才初始化。</para>
      </sect3>

      <sect3 id="ch02-static-methods">
        <title>静态函数</title>

        <para>静态函数 (类函数) 没有在实例上操作，也无法访问
         <literal
        moreinfo="none">this</literal>。例如：</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/point.dart
</remark>import 'dart:math';

class Point {
  num x;
  num y;
  Point(this.x, this.y);

  static num distanceBetween(Point a, Point b) {
    var dx = a.x - b.x;
    var dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
  }
}

main() {
  var a = new Point(2, 2);
  var b = new Point(4, 4);
  var distance = Point.distanceBetween(a,b);
  assert(distance &lt; 2.9 &amp;&amp; distance &gt; 2.8);
}</programlisting>

        <note>
          <para>
              对于常用的工具类函数，可以用顶级函数来替代静态函数。</para>
        </note>

        <para>
            可以把静态函数当做编译期常量。
            例如，你可以把静态函数当做参数传递给常量构造函数。</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="generics">
    <title>Generics（泛型）</title>

    <para>如果你查看 
    <ulink url="http://api.dartlang.org/dart_core/List.html">List </ulink>
    的 API 文档，你会发现其类型定义为
    <literal
    moreinfo="none">List&lt;E&gt;</literal>。  &lt;...&gt; 说明
    List 是一个 <emphasis>generic（泛型）</emphasis> (或者
    <emphasis>parameterized（可参数化的）</emphasis>) 类型 。
    习惯上用一个字母来表达类型定义，例如  E、 T、 S、 K、和 V。</para>

    <sect2 id="ch02-generics-why">
      <title>为何使用泛型？</title>

      <para>
          由于 Dart 的类型是可选的，所以你可以从来不用泛型。
          泛型可以帮助你注释你的代码，让你的意图表达的更清晰。</para>

      <para>例如，如果你想让一个 list 里面只包含 string，
          你可以通过  <literal moreinfo="none">List&lt;String&gt;</literal>
      (读作 <quote>string 类型的列表 </quote>) 来表达你的意图。
      这样，你的同事或者 IDE 以及运行在检测模式下的 Dart VM 可以检测是否保存该
      list 中的对象为 string。如果不是，则会提醒你可能出错了。
      下面是一个示例：</para>

      <programlisting format="linespecific"><remark>lang-dart</remark><remark>
ch02/generics.dart
</remark>var names = new List&lt;String&gt;();
names.addAll(['Seth', 'Kathy', 'Lars']);
// ...
names.add(42); // 在检测模式会出错 (生产模式可以运行).</programlisting>

      <para>
          另外用泛型也可以减少重复代码。
          泛型可以让你实现在多个类型之间公用的操作，
          同时还没丧失代码静态分析和检测模式提醒的优势。
          例如，你想创建一个缓存对象的接口：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>abstract class ObjectCache {
  Object getByKey(String key);
  setByKey(String key, Object value);
}</programlisting>

      <para>后来你又需要一个 String 类型的缓存，所以你又创建一个：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>abstract class StringCache {
  String getByKey(String key);
  setByKey(String key, String value);
}</programlisting>

      <para>后来，你又需要一个其他类型的缓存，所以你想到一个办法。</para>

      <para>
          泛型可以完美的解决该问题。</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>abstract class Cache&lt;T&gt; {
  T getByKey(String key);
  setByKey(String key, T value);
}</programlisting>

      <para>
          在上面的代码中，T 是一个占位符类型。 
          你可以认为这是一个调用者在使用的时候会设置的类型。</para>
    </sect2>

    <sect2 id="generics-literals">
      <title>使用集合字面量</title>

      <para>List 和 map 的字面量定义也可以泛型化。
          只需要在字面量前面添加一个 
      <literal
      moreinfo="none">&lt;<replaceable>泛型类型</replaceable>&gt;</literal> (
      用于 lists ) 或者 <literal
      moreinfo="none">&lt;<replaceable>keyType</replaceable>,
      <replaceable>valueType</replaceable>&gt;</literal> (用于 maps) 即可。
      如果你想在检测模式使用类型警告提示，则可以使用泛型字面量来定义集合。
      下面是一个示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var names = &lt;String&gt;['Seth', 'Kathy', 'Lars'];
var pages = &lt;String, String&gt;{
    'index.html':'Homepage',
    'robots.txt':'Hints for web robots',
    'humans.txt':'We are people, not machines' };</programlisting>
    </sect2>

    <sect2 id="generics-constructors">
      <title>使用泛型构造函数</title>

      <para>
          在构造函数类名后面放一个尖括号和类型（<literal moreinfo="none">&lt;...&gt;</literal>）
          可以使用泛型构造函数。例如：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var names = new List&lt;String&gt;();
names.addAll(['Seth', 'Kathy', 'Lars']);
var nameSet = new Set&lt;String&gt;.from(names);</programlisting>

      <para>下面的代码创建了一个 key 为 int，value 为 View 对象的 map：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var views = new Map&lt;int, View&gt;();</programlisting>
    </sect2>

    <sect2 id="generics-collections">
      <title>泛型集合和类型</title>

      <para>Dart 的泛型类型被 <emphasis>固化了</emphasis>，
          这表明在运行时也带有类型信息。
          例如，你可以在生产模式下测试集合类型：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var names = new List&lt;String&gt;();
names.addAll(['Seth', 'Kathy', 'Lars']);
print(names is List&lt;String&gt;); // true</programlisting>

      <para><literal moreinfo="none">is</literal> 表达式只检查
       <emphasis>集合</emphasis> 的类型而不检查里面的对象类型。
       在生产模式下，一个
      <literal>List&lt;String&gt;</literal> 集合可能包含非 stirng 对象。
      可以通过检查每个集合里面的对象类型或者在一个异常处理器中处理每个集合元素
      (参考 <xref
      linkend="exceptions" />)。</para>

      <note>
        <para>和 Java 不同， Java 中的泛型信息被 <emphasis>清除了</emphasis>，
            所以在运行时是没有类型参数的。
            在 Java 中 你可以测试一个 对象是否为 List，但是没法测试一个对象是否为
         <literal>List&lt;String&gt;</literal>。</para>
      </note>

      <para>关于泛型的更多信息，请参考 <ulink
      url="http://www.dartlang.cc/articles/optional-types/">Optional Types in
      Dart</ulink> 文章。</para>
    </sect2>
  </sect1>

  <sect1 id="libraries">
    <title>库和可见性</title>

    <para>使用 <literal moreinfo="none">import</literal>、 <literal
    moreinfo="none">part</literal>、 和 <literal
    moreinfo="none">library</literal> 指令可以帮助创建模块化和可共享的代码库。
    库不仅仅只包含 API，还包含可见性：以下划线(_)开头的标识符只能在库内访问。
     <emphasis>每一个 Dart 应用都是一个库</emphasis>。</para>

    <para>库可以用 package（包） 来发布。参考  <xref
    linkend="ch04-tools-pub" /> 了解  pub 的信息。</para>

    <sect2 id="libraries-import">
      <title>使用库</title>

      <para>用 <literal moreinfo="none">import</literal> 
      来定义一个库的命名空间并使用一个库。    
      </para>

      <para>例如， Dart web 应用通常都使用  <ulink
      url="http://api.dartlang.org/html.html">dart:html</ulink> 库，可以这样导入该库：
      </para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/libraries/using_libraries.dart
</remark>import 'dart:html';</programlisting>

      <para>  <literal
      moreinfo="none">import</literal> 必需的一个参数为库的  URI<footnote id="ch02-footnote-1">
          <para>URI 代表 <firstterm>uniform resource
          identifier（统一资源标识符）</firstterm>。 URLs (<firstterm>uniform resource
          locators（统一资源定位符）</firstterm>) 是一种常见的 URI。</para>
        </footnote>。对于 内置的库， URI 用
      特殊的 <literal moreinfo="none">dart:</literal> 协议。
      其他库，可以用文件路径或者
       <literal
      moreinfo="none">package:</literal> 协议。 <literal
      moreinfo="none">package:</literal> 
      协议的库由包管理器管理，例如 pub 工具。示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/libraries/using_schemes.dart, mylib, utils
</remark>import 'dart:io';
import 'package:mylib/mylib.dart';
import 'package:utils/utils.dart';</programlisting>

      <sect3 id="libraries-prefix">
        <title>设置库的前缀</title>

        <para>
            如果两个库具有同样的标识符，则会出现命名冲突，可以用库前缀解决命名冲突。
        </para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/libraries/library_prefix.dart, lib1, lib2
</remark>import 'package:lib1/lib1.dart';
import 'package:lib2/lib2.dart' as lib2;
// ...
var element1 = new Element();      // 用 lib1 的 Element
var element2 = new lib2.Element(); // 用 lib2 的 Element</programlisting>
      </sect3>

      <sect3 id="ch02-library-import-part">
        <title>只导入库的一部分</title>

        <para>如果你只使用库的一部分，可以导入只使用的功能。</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/libraries/library_partil.dart, lib1, lib2
</remark>import 'package:lib1/lib1.dart' show foo; // Import only foo.
import 'package:lib2/lib2.dart' hide foo; // Import all names EXCEPT foo.</programlisting>
      </sect3>
    </sect2>

    <sect2 id="libraries-implementing">
      <title>实现一个库</title>

      <para>用 <literal moreinfo="none">library</literal> 指令来命名一个库，
      用 <literal moreinfo="none">part</literal> 来设置库中的其他文件。</para>

      <note>
        <para>在一个应用（包含 顶级 main() 方法的文件 ）中无需用 <literal>library</literal> 
            ，但是使用 library 可以在多个文件中实现你的应用。</para>
      </note>

      <sect3 id="libraries-library">
        <title>定义一个库</title>

        <para>用  <literal moreinfo="none">library
        <replaceable>标识符</replaceable></literal> 指定当前库的名字：</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/ballgame.dart
</remark>library ballgame;   // 定义这是一个名字为 ballgame 的库

import 'dart:html'; // 该应用使用 html 库
// ...Code goes here...
</programlisting>
      </sect3>

      <sect3 id="libraries-source">
        <title>关联库中的文件</title>

        <para>在往库中添加文件，在带有  <literal>library</literal> 指令的文件中用  <literal>part
        <replaceable>fileUri</replaceable></literal>
        ，
        <emphasis>fileUri</emphasis> 是要包含的文件路径。
        然后在该文件的实现中用 
     <literal>part of
        <replaceable>identifier</replaceable></literal> 语句定义（ <emphasis>identifier</emphasis> 是
        库的名字）。
        下面的示例中，用 <literal>part</literal> 和 <literal>part
        of</literal> 实现一个包含三个文件的库。</para>

        <para>第一个文件  <literal>ballgame.dart</literal> 定义了 
        ballgame 库，导入其他需要的库并指定
        <literal>ball.dart</literal> 和 <literal>util.dart</literal> 文件也属于该库：</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/ballgame.dart
</remark>library ballgame;

import 'dart:html';
// ...Other imports go here...

part 'ball.dart';
part 'util.dart';

// ...Code might go here...</programlisting>

        <para>第二个文件  <literal>ball.dart</literal> 定义了 part of ballgame 语句，
            并实现了 ballgame 的一部分代码:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/ball.dart
</remark>part of ballgame;

// ...Code goes here...</programlisting>

        <para>第三个文件 <literal>util.dart</literal> 同样
            实现了 ballgame 的其他代码：</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/util.dart
</remark>part of ballgame;

// ...Code goes here...</programlisting>
      </sect3>

      <sect3 id="ch02-library-reexport">
        <title>重新定义库（export）</title>

        <para>
            使用从重新定义库功能（export 指令） 可以组合和重新打包库（可以包含所有代码也可以只包含部分代码）。
            例如，你有一个非常大的库，里面包含了一堆小库。或者你想创建一个只包含其他库中一部分功能的库。</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/french.dart, togo.dart, french_togo.dart
</remark><emphasis>// In french.dart:</emphasis>
library french;
hello() =&gt; print('Bonjour!');
goodbye() =&gt; print('Au Revoir!');

<emphasis>// In togo.dart:</emphasis>
library togo;
import 'french.dart';
export 'french.dart' show hello;

<emphasis>// In another .dart file:
</emphasis>import 'togo.dart';

void main() {
  hello();   //print bonjour
  goodbye(); //FAIL
}</programlisting>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="isolates">
    <title>Isolates</title>

    <para>
        很多流行的浏览器，甚至是移动平台的浏览器，都运行在多核 CPU 上。
        为了使用多核优势，开发者通常都使用共享内存的方式来运行多个线程。
        但是，共享状态并发编程是非常容易出错的，并且导致代码更加复杂。</para>

    <para>而 Dart 的代码都是运行在 
    <emphasis>isolates</emphasis> 中而不是线程中。
    每个 isolate 具有自己的内存堆，确保每个 isolate 堆之
    无法共享状态。</para>
  </sect1>

  <sect1 id="typedefs">
    <title>Typedefs</title>

    <para>在 Dart 中， 方法也是对象。
    用  <emphasis>typedef</emphasis> 或者 <emphasis>function-type
    alias</emphasis> 可以给一个方法类型设置一个名字，并定义参数和返回值。
    当方法类型赋值到一个变量时， typedef 保留类型信息。</para>

    <para>如下是一个没有用 typedef 的示例：</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/sorted_collection.dart
</remark>class SortedCollection {
  Function compare;

  SortedCollection(int f(Object a, Object b)) {
    compare = f;
  }
}

int sort(Object a, Object b) =&gt; ... ; // Initial, broken implementation.

main() {
  SortedCollection collection = new SortedCollection(sort);

  // 我们只知道 compare 是一个方法，但是不知道是什么类型的方法
  assert(collection.compare is Function);
}</programlisting>

    <para>当把 <literal
    moreinfo="none">f</literal> 赋值给  <literal moreinfo="none">compare</literal>
    时类型信息丢失了。
    
     <literal moreinfo="none">f</literal> 的类型是 <literal
    moreinfo="none">(Object, </literal><phrase role="keep-together"><literal
    moreinfo="none">Object)</literal> <phrase role="unicode">→</phrase>
    <literal moreinfo="none">int</literal></phrase> (这里的 <phrase
    role="unicode">→</phrase> 代表返回值类型)，当然 
     <literal
    moreinfo="none">compare</literal> 也是  Function 类型。
    如果用显式的名字和返回值来定义该方法，则开发者和工具都可以使用该信息。</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark><emphasis role="">typedef int Compare(Object a, Object b);</emphasis>

class SortedCollection {
  Compare compare;

  SortedCollection(this.compare);
}

int sort(Object a, Object b) =&gt; ... ; // Initial, broken implementation.

main() {
  SortedCollection collection = new SortedCollection(sort);
  assert(collection.compare is Function);
  assert(collection.compare is Compare);
}</programlisting>

    <note>
      <para>
          当前，typedef 只能定义方法类型。
          我们希望能够增强该功能。</para>
    </note>

    <para>由于 typedef 只是简单的别名，并提供了一种检测方法类型的方式。
 例如：</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>typedef int Compare(int a, int b);

int sort(int a, int b) =&gt; a - b;

main() {
  assert(sort is Compare);  // True!
}</programlisting>
  </sect1>

  <sect1 id="ch02-metadata">
    <title>Metadata（元数据）</title>

    <para>
        用元数据给你的代码提供额外的信息。元数据注解
        使用 <literal>@</literal> 字符开头，后面跟着一个引用合作
        编译期常量（例如 <literal>deprecated</literal>）或者调用一个
        常量构造函数。
    </para>

    <para>下面三个注解，所有的 Dart 代码都可以使用：
    <literal>@deprecated</literal>、 <literal>@override</literal>、 和
    <literal>@proxy</literal>。参考
   <xref
    linkend="ch02-class-extend" /> 查看使用 <literal>@override</literal> 和 <literal>@proxy</literal>
    的示例。下面是一个使用 
    <literal>@deprecated</literal> 注解的示例：</para>

    <programlisting format="linespecific"><remark>lang-dart
ch02/ch02_meta/bin/ch02_meta.dart
</remark>class Television {
  /// _Deprecated: Use [turnOn] instead._
  @deprecated      // Metadata; makes Dart Editor warn about using activate().
  void activate() {
    turnOn();
  }

  /// Turns the TV's power on.
  void turnOn() {
    print('on!');
  }
}</programlisting>

    <para>可以定义自己的注解，下面是定义一个带有两个参数的  @todo 注解：</para>

    <programlisting><remark>lang-dart
</remark><remark>ch02/ch02_meta_create/todo.dart
</remark>library todo;

class todo {
  final String who;
  final String what;
  
  const todo(this.who, this.what);
}</programlisting>

    <para>下面是使用  @todo 的示例：</para>

    <programlisting><remark>lang-dart</remark><remark>
ch02/ch02_meta_create/metadata_user.dart
</remark>import 'todo.dart';

@todo('seth', 'make this do something')
void doSomething() {
  print('do something');
}</programlisting>

    <para>Metadata 可以出现在 library、 class、 typedef、 type
    parameter、 constructor、factory、 function、 field、 parameter、或者 variable
    declaration 、import 或者 export 之前。 
    以后，可以通过反射来获取元数据信息。
    <remark>
    状态跟踪： <ulink
    url="https://code.google.com/p/dart/issues/detail?id=6614">issue
    #6614</ulink>。</remark></para>
  </sect1>

  <sect1 id="comments">
    <title>注释</title>

    <para>Dart 支持单行注释、多行注释和文档注释。
        </para>

    <sect2 id="ch02-comments-single-line">
      <title>单行注释</title>

      <para>单行注释以 <literal
      moreinfo="none">//</literal> 开头。位于  <literal
      moreinfo="none">//</literal> 之后的字符都会被 Dart 编译器
      忽略掉。</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>main() {
  // TODO: refactor into an AbstractLlamaGreetingFactory?
  print('Welcome to my Llama farm!');
}</programlisting>
    </sect2>

    <sect2 id="ch02-comments-multi-line">
      <title>多行注释</title>

      <para>多行注释以 <literal
      moreinfo="none">/*</literal> 开头，以  <literal
      moreinfo="none">*/</literal>结尾。位于 <literal
      moreinfo="none">/*</literal> 和 <literal moreinfo="none">*/</literal>
      之间的 内容被编译器忽略（文档注释除外）。</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/multi_line_comments.dart
</remark>main() {
  /*
   * This is a lot of work. Consider raising chickens.

  Llama larry = new Llama();
  larry.feed();
  larry.exercise();
  larry.clean();
   */
}</programlisting>
    </sect2>

    <sect2 id="comments-doc">
      <title>文档注释</title>

      <para>文档注释是以  <literal moreinfo="none">/**</literal> 或者 <literal
      moreinfo="none">///</literal> 开头的多行或者单行注释。 连续多行使用 <literal
      moreinfo="none">///</literal> 和多行文档注释效果一样。</para>

      <para>
          在文档注释中，Dart 编译器只处理位于方括号之间的内容。
          可以用方括号引用 类、函数、变量、顶级变量、方法、和参数。
          方括号内的参数在词法范围内查找代码中对于的标示符。</para>

      <para>下面是一个引用其他类的文档注释。</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/doc_comments.dart
</remark>/**
 * A domesticated South American camelid (Lama glama).
 * 
 * Andean cultures have used llamas as meat and pack animals
 * since pre-Hispanic times.
 */
class Llama {
  String name;

  /**
   * Feeds your llama [Food].
   * 
   * The typical llama eats one bale of hay per week.
   */
  void feed(Food food) {
    // ...
  }

  /// Exercises your llama with an [activity] for
  /// [timeLimit] minutes.
  void exercise(Activity activity, int timeLimit) {
    // ...
  }
}</programlisting>

      <para>在生成的文档中， <literal
      moreinfo="none">[Food]</literal> 变成链接到 
      Food 类 API 文档的超级链接。</para>

      <para>
          可以用 Dart 编辑器来解析 Dart 代码并生成 HTML 文档，编辑器使用的是 SDK 中的 dartdoc 工具。
          生成的文档请参考 <ulink
      url="http://api.dartlang.org">Dart API 文档</ulink>。
      关于如何组织注释结构的建议，请参考  <ulink
      url="http://www.dartlang.cc/articles/doc-comment-guidelines/">Dart 文档注释指南。</ulink></para>
    </sect2>
  </sect1>

  <sect1 id="ch02-summary">
    <title>总结</title>

    <para>本章总结了 Dart 语言常用的特性。
         为了避免打破现有代码，更多的特性作为 minxin 实现 <ulink
    url="http://www.dartlang.cc/articles/mixins/"></ulink>。详细信息
    参考 <ulink
    url="http://www.dartlang.cc/docs/spec/">Dart 语言
    规范</ulink> 和 <ulink
    url="http://www.dartlang.cc/articles/">相关文章</ulink> 例如 <ulink
    url="http://www.dartlang.cc/articles/idiomatic-dart/"
    userlevel=""> Dart 习惯用法。</ulink></para>
  </sect1>
</chapter>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="ch02">
  <?dbhtml stop-chunking?>

  <title>Dart 语言概览</title>

  <para>本章介绍 Dart 语言的主要特性 -- 变量、操作符、类和库 等。
      本章假设你具有其他编程语言的背景知识。</para>

  <note>
    <para>你可以按照 <xref linkend="ch01-editor" /> 中介绍的方法创建个命令行应用来
        动手演示这些特性。</para>
  </note>

  <para>如果你想了解某个特性的详细信息，可以参考
       <ulink url="http://www.dartlang.cc/docs/spec/">Dart
  语言规范</ulink> 。</para>

  <sect1 id="main-print">
    <title>一个基本的 Dart 程序</title>

    <para>下面的代码使用很多 Dart 语言的基本特性：</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>// 定义一个方法
printNumber(num aNumber) {
  print('The number is $aNumber.'); // 在控制台打印信息
}

// 应用开始执行的入口
main() {
  var number = 42;           // 定义并初始化一个变量
  printNumber(number);       // 调用一个方法
}</programlisting>

    <para>下面是上面的代码使用到的可以应用其他（几乎）所有 Dart 应用的
        特性：</para>

    <variablelist>
      <varlistentry>
        <term><literal moreinfo="none">// <replaceable>这是一个注释。
            </replaceable></literal></term>

        <listitem>
          <para>使用 // 表明后面的文字为注释。
          另外还可以用 /* ... */。详细信息，参考 <xref
          linkend="comments" />。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">num</literal></term>

        <listitem>
          <para>一种类型。其他内建的类型有 String、int、和 bool。
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">42</literal></term>

        <listitem>
          <para>一个数字 <firstterm>literal（字面量）</firstterm>。
              字面量是一种编译期常量。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">print()</literal></term>

        <listitem>
          <para>一种打印结果的助手方法。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">'...'</literal> (或者 <literal
        moreinfo="none">"..."</literal>)</term>

        <listitem>
          <para>声明 String 的 字面量。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal
        moreinfo="none">$<replaceable>variableName</replaceable></literal> (或者
        <literal
        moreinfo="none">${<replaceable>expression</replaceable></literal><literal
        moreinfo="none">}</literal>)</term>

        <listitem>
          <para>字符串插值（String interpolation）：在一个字符串字面量中包含
              一个变量或者表达式，最终该变量或者表达式的值将替换在字符串中。详细信息请参考：
           <xref linkend="strings" />。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">main()</literal></term>

        <listitem>
          <para>Dart 程序<emphasis>必需的</emphasis>顶级入口函数。
              Dart 程序从该函数开始执行。 详细信息请参考： <xref
          linkend="ch02-main" />。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">var</literal></term>

        <listitem>
          <para>一种定义无类型变量的方法。</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <note>
      <para>我们的代码遵守 <ulink
      url="http://www.dartlang.org/articles/style-guide/">Dart 风格指南
      </ulink> 中介绍的格式。例如，我们用了两个空格的缩进。</para>
    </note>
  </sect1>

  <sect1 id="ch02-concepts">
    <title>重要的概念</title>

    <para>在学习 Dart 语言的时候，请记住如下概念：</para>

    <itemizedlist>
      <listitem>
        <para>变量引用的任意内容都是一个
        <emphasis>对象（object）</emphasis>，任意对象都是一个
        <emphasis>类（class）</emphasis> 的实例。甚至 数字（ numbers）、方法（ functions）、 和<literal
        moreinfo="none">null</literal> 都是对象。所有的对象都从
         <ulink
        url="http://api.dartlang.org/dart_core/Object.html">Object</ulink>
        类继承下来。</para>
      </listitem>

      <listitem>
        <para>指定静态类型（例如前面示例的  <literal
        moreinfo="none">num</literal> ） 明确你的意图，并且可以使用
        工具的静态分析工具，但是类型是可选的。（在调试代码的时候，你可能已经注意到了，虽然你指定了静态类型，但是在调试的时候
        该变量并没有指定具体的类型，而是使用了一个特殊的类型： <literal
        moreinfo="none">dynamic</literal>）。</para>
      </listitem>

      <listitem>
        <para>Dart 在运行代码之前先解析代码。 你可以给 Dart 提供
            一些扑捉错误和帮助提高代码运行效率的建议，例如使用 类型、或者使用编译期常量。</para>
      </listitem>

      <listitem>
        <para>Dart 支持顶级方法（例如
        <literal>main()</literal>），也支持实例函数和类函数（静态函数）。
        你还可以在一个方法内创建另外一个方法（<emphasis>nested（嵌入方法）</emphasis> 或者 <emphasis>local
        functions（本地方法）</emphasis>）。 </para>
      </listitem>

      <listitem>
        <para>同样，Dart 也支持顶级
        <emphasis>变量</emphasis>，也支持实例变量和类变量（静态变量）。
        实例变量有时候被称之为 值域或者属性（<firstterm>fields</firstterm> 或者
        <firstterm>properties</firstterm>）。</para>
      </listitem>

      <listitem>
        <para>和 Java 不同， Dart 没有 <literal
        moreinfo="none">public</literal>、 <literal
        moreinfo="none">protected</literal>、 和 <literal
        moreinfo="none">private</literal> 关键字。如果名字
        以下划线（_）开头，则是库私有成员。详细信息请参考： <xref
        linkend="libraries" />。</para>
      </listitem>

      <listitem>
        <para><firstterm>标识符（名字）</firstterm> 可以以字母或者 下划线 开头，后面可以跟随
            任意的字母和数字的组合。</para>
      </listitem>

      <listitem>
        <para>有时候需要区分一个东西是
        <emphasis>expression（表达式）</emphasis> 还是一个 <emphasis>statement（语句）</emphasis>，
        所以我们将区分这两个词语。</para>
      </listitem>

      <listitem>
        <para>Dart 工具可以报告两种错误信息：警告和错误。
		警告只是提示你代码可能有潜在的问题，但是并不阻止代码执行。
		错误可能是编译时错误也可能是运行时错误。一个编译时错误阻止代码运行，而运行时
		错误在遇到的时候会抛出一个
        <link
        linkend="exceptions">exception</link> 。</para>
      </listitem>

      <listitem>
        <para>Dart 有两种 <firstterm>运行模式</firstterm>：
            生产模式和检测模式（ production
        and checked）。生产模式效率高，但是测试模式可以在开发的时候帮助调试代码。</para>
      </listitem>
    </itemizedlist>

    <sect2 id="ch02-keywords">
      <title>关键字</title>

      <para><xref linkend="keyword_table" /> 列出了  Dart 语言中的
          关键字。</para>

      <para><table class="keywordTable" id="keyword_table">
          <title>Dart 关键字</title>

          <tgroup cols="6">
            <tbody>
              <row>
                <entry>abstract *</entry>

                <entry>continue</entry>

                <entry>extends</entry>

                <entry>implements *</entry>

                <entry>part *</entry>

                <entry>throw</entry>
              </row>

              <row>
                <entry>as *</entry>

                <entry>default</entry>

                <entry>factory *</entry>

                <entry>import *</entry>

                <entry>rethrow</entry>

                <entry>true</entry>
              </row>

              <row>
                <entry>assert</entry>

                <entry>do</entry>

                <entry>false</entry>

                <entry>in</entry>

                <entry>return</entry>

                <entry>try</entry>
              </row>

              <row>
                <entry>break</entry>

                <entry>dynamic *</entry>

                <entry>final</entry>

                <entry>is</entry>

                <entry>set *</entry>

                <entry>typedef *</entry>
              </row>

              <row>
                <entry>case</entry>

                <entry>else</entry>

                <entry>finally</entry>

                <entry>library *</entry>

                <entry>static *</entry>

                <entry>var</entry>
              </row>

              <row>
                <entry>catch</entry>

                <entry>enum</entry>

                <entry>for</entry>

                <entry>new</entry>

                <entry>super</entry>

                <entry>void</entry>
              </row>

              <row>
                <entry>class</entry>

                <entry>export *</entry>

                <entry>get *</entry>

                <entry>null</entry>

                <entry>switch</entry>

                <entry>while</entry>
              </row>

              <row>
                <entry>const</entry>

                <entry>external *</entry>

                <entry>if</entry>

                <entry>operator *</entry>

                <entry>this</entry>

                <entry>with</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>

      <para>
          在上表中，带有星号（*）的关键字为
      <emphasis>内置的标识符（built-in identifiers）</emphasis>。
      虽然你应该把内置的标识符按照关键字对待，其实真正的限制是无法用内置的标识符作为类或者类型的名字。
	使用内置的标识符可以简化从 JavaScript 移植到 Dart 的过程。
	例如，有些 JavaScript 代码具有一个名字为 <literal>factory</literal> 的变量；
	当移植到 Dart 时无需重命名该变量。<remark> 13年十月更新：添加 enum、
      rethrow。 Dart 保留关键字：语言规范的 Section 16.1.1 列举了保留的关键字；  12.31 
      介绍了内置标识符的参考索引。</remark></para>
    </sect2>

    <sect2 id="ch02-runtime-modes">
      <title>运行时模式</title>

      <para>我们建议在检测模式开发，在生产模式部署。</para>

      <para><emphasis>生产模式</emphasis>是 Dart 程序的默认运行模式，优化了运行速度。
          生产模式忽略
       <link
      linkend="assert">assert statements（断言语句）</link> 和静态类型。</para>

      <para><emphasis>检测模式</emphasis> 是开发友好模式，
          可以在运行的时候帮助你捕获一些类型错误信息。例如，
          如果你给一个类型为 <literal
      moreinfo="none">num</literal> 的变量
      赋值为一个非数字的值，在检测模式会抛出一个异常。</para>
    </sect2>
  </sect1>

  <sect1 id="variables">
    <title>变量</title>

    <para>下面是创建变量并赋值的示例：</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>var name = 'Bob';</programlisting>

    <para>变量是引用。名字为 <literal
    moreinfo="none">name</literal> 的变量包含一个指向内容为
      <quote>Bob</quote> 的 String 对象。</para>

    <sect2 id="variables-default-value">
      <title>默认值</title>

      <para>没有初始化的变量的值为 <literal
      moreinfo="none">null</literal>。即使类型为数字的变量其值也是 null，不要忘了 数字在 Dart
      中也是对象。</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>int lineCount;
assert(lineCount == null); 
// 变量的初始值为 null。</programlisting>

      <note>
        <para>在生产模式下  <literal>assert()</literal> 方法不会被调用。在检测
            模式下，如果 <replaceable>判断条件</replaceable> 值为 false ，则 <literal
        moreinfo="none">assert(<replaceable>判断条件</replaceable>)</literal>
       抛出一个异常。详细信息请参考： <xref linkend="assert" />。</para>
      </note>
    </sect2>

    <sect2 id="variables-optional-types">
      <title>可选类型</title>

      <para>在声明变量的时候可以设置一个静态类型：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>String name = 'Bob';</programlisting>

      <para>添加类型可以明确表达你的意图，可以替代注释。有些工具（例如编译器和编辑器）可以
          使用类型信息帮助你编写代码。</para>

      <note>
        <para>本章内容按照 <ulink
        url="http://www.dartlang.cc/articles/style-guide/#type-annotations"> Dart 风格指南</ulink>
        推荐的方式用  <literal
        moreinfo="none">var</literal> 来定义
        局部变量。</para>
      </note>
    </sect2>

    <sect2 id="ch02-final-const">
      <title>Final 和 Const</title>

      <para>如果你重来不需要修改变量的值，则可以用  <literal
      moreinfo="none">final</literal> 或者 <literal
      moreinfo="none">const</literal> 来修饰该变量，可以替代 <literal
      moreinfo="none">var</literal> 关键字也可以用在类型声明之前。
    	一个 final 类型变量只能设置一次值，一个 const 变量是编译期常量。</para>

      <para>定义为 <literal
      moreinfo="none">final</literal> 的本地变量、顶级变量、或者类变量在第一次
      使用的时候初始化：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>final name = 'Bob';   // Or: final String name = 'Bob';
// name = 'Alice';    // 这行代码有错误</programlisting>

      <note>
        <para>懒加载 final 变量可以让应用启动速度加快。</para>
      </note>

      <para>用 <literal moreinfo="none">const</literal> 来定义
          编译期常量。 如果是类常量则用 <literal>static const</literal> 来定义。
          实例变量无法用 const 修饰。 在定义变量的时候，可以设置其值为编译期常量，例如：
          字符字面量、const 变量或者常量数字的数学运算结果：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>const bar = 1000000;       // 压力单位 (in dynes/cm2)
const atm = 1.01325 * bar; // 标准大气压</programlisting>
    </sect2>
  </sect1>

  <sect1 id="built-in-types">
    <title>内置类型</title>

    <para>Dart 语言对如下类型有特殊的支持：</para>

    <itemizedlist>
      <listitem>
        <para>numbers</para>
      </listitem>

      <listitem>
        <para>strings</para>
      </listitem>

      <listitem>
        <para>booleans</para>
      </listitem>

      <listitem>
        <para>lists (也被称之为 <emphasis>arrays</emphasis>)</para>
      </listitem>

      <listitem>
        <para>maps</para>
      </listitem>

      <listitem>
        <para>symbols</para>
      </listitem>
    </itemizedlist>

    <para>你可以用字符字面量来初始化上面这些类型。例如  <literal moreinfo="none">'this is a
    string'</literal> 是一个定义字符串的 字符字面量，而 <literal
    moreinfo="none">true</literal> 是一个布尔值字符字面量。</para>

    <para>由于 Dart 总的变量都是引用一个对象，所以可以使用
    <emphasis>构造函数</emphasis> 来初始化变量。
    一些内置类型有自己的构造函数。
    例如，可以用 
    <literal>Map()</literal> 构造函数来创建一个 map 对象：
    <literal moreinfo="none">new Map()</literal>。</para>

    <sect2 id="numbers">
      <title>Numbers</title>

      <para>Dart 支持两种类型数字：</para>

      <variablelist>
        <varlistentry>
          <term><ulink url="http://api.dartlang.org/dart_core/int.html">
          <literal moreinfo="none">int</literal> </ulink></term>

          <listitem>
            <para>整数值</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><ulink url="http://api.dartlang.org/dart_core/double.html">
          <literal moreinfo="none">double</literal> </ulink></term>

          <listitem>
            <para>IEEE 754 标准定义的 64-bit (双精度) 浮点数。</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para> <literal moreinfo="none">int</literal> 和 <literal
      moreinfo="none">double</literal> 都是  <ulink
      url="http://api.dartlang.org/dart_core/num.html"><literal
      moreinfo="none">num</literal> 的子类。</ulink>
      num 类定义了基础的操作符，例如 +、 -、 /、 和 *、，以及位操作符，例如 
      &gt;&gt;。同时还定义了一些常用函数：
      <literal>abs()</literal>、<literal> ceil()</literal>、 和
      <literal>floor()</literal> 等。
      如果 nub 和子类没有你需要的功能，请查找
      <ulink
      url="http://api.dartlang.org/dart_math.html">Math</ulink> 库。
      (在 Dart 代码生成的 JavaScript 中，<ulink
      url="http://dartbug.com/1533">大整数</ulink> 和在 
      Dart VM 中执行的  Dart 代码有点区别。)</para>

      <para>Integer 是没有小数点的整数。下面是定义 integer 的一些示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var x = 1;
var hex = 0xDEADBEEF;
var bigInt = 346534658346524376592384765923749587398457294759347029438709349347;</programlisting>

      <para>如果包含小数点，则为 double。
          下面是定义 double 的示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var y = 1.1;
var exponents = 1.42e5;</programlisting>

      <para>下面是字符串和数字之间的转换示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>// String -&gt; int
var one = int.parse('1');
assert(one == 1);

// String -&gt; double
var onePointOne = double.parse('1.1');
assert(onePointOne == 1.1);

// int -&gt; String
String oneAsString = 1.toString();
assert(oneAsString == '1');

// double -&gt; String
String piAsString = 3.14159.toStringAsFixed(2);
assert(piAsString == '3.14');</programlisting>

      <para>int 定义了常用的位移操作符 (&lt;&lt;,
      &gt;&gt;), AND (&amp;), 或者 OR (|) 。示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>assert((3 &lt;&lt; 1) == 6);  // 0011 &lt;&lt; 1 == 0110
assert((3 &gt;&gt; 1) == 1);  // 0011 &gt;&gt; 1 == 0001
assert((3 | 4)  == 7);  // 0011 | 0100 == 0111</programlisting>
    </sect2>

    <sect2 id="strings">
      <title>Strings</title>

      <para>Dart 字符串是一个 UTF-16 编码单元序列。 可以用单引号或者双引号定义
          一个 String：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var s1 = 'Single quotes work well for string literals.';
var s2 = "Double quotes work just as well.";
var s3 = 'It\'s easy to escape the string delimiter.';
var s4 = "It's even easier to just use the other string delimiter.";</programlisting>

      <para>通过使用 
      <literal>${</literal><emphasis><literal>表达式</literal></emphasis><literal>}</literal>
      语法可以把表达式放到字符串中间。
      如果表达式为一个标识符，则可以省略 {}。 Dart 调用
      对象的
      <literal>toString()</literal> 函数来获取该对象的字符串值。</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var s = 'string interpolation';

assert('Dart has $s, which is very handy.' ==
       'Dart has string interpolation, which is very handy.');
assert('That deserves all caps. ${s.toUpperCase()} is very handy!' ==
       'That deserves all caps. STRING INTERPOLATION is very handy!');</programlisting>

      <note>
        <para> <literal moreinfo="none">==</literal> 操作符测试两个对象是否相等。
            具有同样字符的字符串是相等的。</para>
      </note>

      <para>可以通过相邻字符串字面量或者 
      <literal><literal>+</literal></literal> 操作符来连接字符串：</para>

      <programlisting format="linespecific"><remark>lang-dart
adjacent_string_literals.dart
</remark>var s1 = 'String ' 'concatenation'
         " works even over line breaks.";
assert(s1 == 'String concatenation works even over line breaks.');

var s2 = 'The addition operator '
         + 'works, as well.';
assert(s2 == 'The addition operator works, as well.');</programlisting>

      <para>使用三个双引号或者单引号可以创建多行字符串：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var s1 = '''
You can create
multi-line strings like this one.
''';

var s2 = """This is also a
multi-line string.""";</programlisting>

      <para>在前面添加一个 
      <literal moreinfo="none">r</literal> 可以创建  <quote>raw（未转义）</quote> 字符串：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var s = r"In a raw string, even \n isn't special.";</programlisting>

      <para>在字符串中也可以使用 Unicode 转义：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/quoting.dart
</remark>print('Unicode escapes work: \u2665'); // Unicode escapes work: [heart]</programlisting>

      <para>关于使用 String 的更多信息，请参考  <xref
      linkend="ch03-strings-and-regular-expressions" />。</para>
    </sect2>

    <sect2 id="booleans">
      <title>Booleans</title>

      <para>Dart 用 <literal
      moreinfo="none">bool</literal> 类型代表布尔值。类型 bool 只有两个对象：
      布尔字面量 <literal moreinfo="none">true</literal> 和 <literal
      moreinfo="none">false</literal>。</para>

      <para>当 Dart 需要布尔值的时候， 只有  <literal
      moreinfo="none">true</literal> 被认为是 true。
      其他所有的值都认为是 false。和 JavaScript 不同，
      像  <literal
      moreinfo="none">1</literal>、 <literal
      moreinfo="none">"aString"</literal>、和 <literal
      moreinfo="none">someObject</literal> 在 Dart 中都是 false。</para>

      <para>例如 下面的代码在 JavaScript 和 Dart 中都是合法的：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var name = 'Bob';
if (name) {
  print('You have a name!'); // 在 JavaScript 中会执行该语句 ，而 Dart 中不会执行。
}</programlisting>

      <para>由于 <literal moreinfo="none">name</literal> 不是
          一个 null 对象，所以在 JavaScript 运行上面代码则会打印出 <quote>You have a
      name!</quote>。而 在 Dart 的 <emphasis>生产模式
       </emphasis>下，不会输出任何内容，原因在于，
        <literal
      moreinfo="none">name</literal> 被转换成了 <literal
      moreinfo="none">false</literal> (因为 <literal moreinfo="none">name
      != true</literal>)。在 Dart 的 <emphasis>检测模式
       </emphasis>下，由于
       <literal
      moreinfo="none">name</literal> 变量不是一个布尔值 会导致抛出异常。
       </para>

      <para>下面是另外一个 
      JavaScript 和 Dart 代码行为不一致的示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>if (1) {
  print('JavaScript prints this line because it thinks 1 is true.');
} else {
  print('Dart in production mode prints this line.');
  // 在 Dart 的检测模式下 if (1) 会抛出异常。
}</programlisting>

      <note>
        <para>上面的两个示例只有在生产模式下能够运行。在检测模式下，如果把非布尔值当做布尔值用
            会抛出异常。</para>
      </note>

      <para>Dart 只把 true 当做 true，而不是其他对象，可以避免很多不可预料的问题。你不应该这样用：<literal
      moreinfo="none">if&nbsp;(<replaceable>nonbooleanValue</replaceable>)</literal>，而
      应该用你期望的值。例如：
      </para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>// 检测空字符串
var fullName = '';
assert(fullName.isEmpty);

// 检测是否为 0
var hitPoints = 0;
assert(hitPoints &lt;= 0);

// 检测 null.
var unicorn;
assert(unicorn == null);

// 检测  NaN.
var iMeantToDoThis = 0/0;
assert(iMeantToDoThis.isNaN);</programlisting>
    </sect2>

    <sect2 id="lists">
      <title>Lists</title>

      <para> <emphasis>array</emphasis>（数组）也许是大多数编程语言中最常用的集合。
          在 Dart 中，  数组为 <ulink
      url="http://api.dartlang.org/dart_core/List.html">List</ulink> 对象，
      所以一般我们都称之为  <emphasis>lists（列表）</emphasis>。</para>

      <para>Dart 列表字面量定义和 JavaScript 中的 数组定义类似。下面
          是一个定义 Dart 列表的示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var list = [1,2,3];</programlisting>

      <para>列表的索引从 0 开始， 0 是第一个元素而
      <literal moreinfo="none">list.length - 1</literal> 是最后一个元素。
      获取列表的长度和元素与 JavaScript 中的操作一样：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var list = [1,2,3];
assert(list.length == 3);
assert(list[1] == 2);</programlisting>

      <para>List 类定义了很多操作列表的函数。详细信息请参考  <xref linkend="generics" /> 和 <xref
      linkend="ch03-collections" />。</para>
    </sect2>

    <sect2 id="maps">
      <title>Maps</title>

      <para>一般来说，一个 map 是一个把键（key）和值（value）关联起来的对象。
          键和值都可以为任意类型的对象。一个
      <emphasis>键</emphasis> 只能出现一次，但是一个
      <emphasis>值</emphasis> 可以设置到多个键上。 Dart 通过
      map 字面量和  <ulink
      url="http://api.dartlang.org/dart_core/Map.html">Map</ulink>
      类型支持 Map。</para>

      <para>下面是用 map 字面量创建 Map 对象的一些示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var gifts = {
// Keys       Values
  'first'  : 'partridge',
  'second' : 'turtledoves',
  'fifth'  : 'golden rings'
};

var nobleGases = {
// Keys  Values
   2  : 'helium',
   10 : 'neon',
   18 : 'argon',
};
</programlisting>

      <para>也可以用 Map 构造函数创建这些对象：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/map_constructor.dart
</remark>var gifts = new Map();
gifts['first'] = 'partridge';
gifts['second'] = 'turtledoves';
gifts['fifth'] = 'golden rings';

var nobleGases = new Map();
nobleGases[2] = 'helium';
nobleGases[10] = 'neon';
nobleGases[18] = 'argon';</programlisting>

      <para>往 map 对象中添加 键-值 对和 JavaScript 中的操作一样:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var gifts = { 'first': 'partridge' };
gifts['fourth'] = 'calling birds';    // Add a key-value pair</programlisting>

      <para>从 map 中获取值也和 JavaScript 一样：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var gifts = { 'first': 'partridge' };
assert(gifts['first'] == 'partridge');</programlisting>

      <para>如果一个 键 不在 map 中，则返回的值为 null：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var gifts = { 'first': 'partridge' };
assert(gifts['fifth'] == null);</programlisting>

      <para>用 <literal moreinfo="none">.length</literal> 来获取 map 中
          键值对的个数：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var gifts = { 'first': 'partridge' };
gifts['fourth'] = 'calling birds';
assert(gifts.length == 2);</programlisting>

      <para>关于 map 的详细信息请参考：<xref linkend="generics" />
      和 <xref linkend="ch03-maps-aka-dictionaries-or-hashes" />。</para>
    </sect2>

    <sect2 id="ch02-symbols">
      <title>Symbols（符号）</title>

      <para>一个 <ulink
      url="http://api.dartlang.org/dart_core/Symbol.html">Symbol</ulink>
      对象代表 Dart 代码中的一个操作符或者一个标识符。你可能无需使用 Symbol，但是对于需要访问 标识符 名字的 API 来说，
      Symbol 是非常有用的，对于混淆过的代码， Symbol 也返回混淆之前的标识符名字。</para>

      <para>要获取一个标识符的 Symbol，可以 用 symbol 字面量定义：
      一个 <literal>#</literal>后面跟着标识符的名字 </para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>#radix  // The symbol literal for an identifier named 'radix'.
#bar    // The symbol literal for an identifier named 'bar'.</programlisting>

      <para>关于 symbol 的详细信息，请参考  <xref
      linkend="ch03-mirrors" />。</para>
    </sect2>
  </sect1>

  <sect1 id="functions">
    <title>Functions（方法）</title>

    <para>下面是实现一个方法的示例：</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>void printNumber(num number) {
  print('The number is $number.');
}</programlisting>

    <para>虽然风格指南中建议设置参数和返回值的类型，但是你也可以不这么做：</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>printNumber(number) {          // 不设置类型也可以
  print('The number is $number.');
}</programlisting>

    <para>对于只有一个表达式的方法，你可以用缩写形式：</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>printNumber(number) =&gt; print('The number is $number.');</programlisting>

    <para> <literal moreinfo="none">=&gt;
    <replaceable>expr</replaceable>;</literal> 语法是
    <literal moreinfo="none">{ return
    <replaceable>expr</replaceable>;}</literal> 的缩写形式。
    在上面的
    <literal>printNumber()</literal> 方法中，表达式为
    顶级方法 <literal>print()</literal>。</para>

    <note>
      <para>
      在 <phrase
      role="keep-together">arrow (=&gt;)</phrase> 和 分号 (;) 之间只能是
      <emphasis>expression（表达式）</emphasis>，不能用 <emphasis>statement（语句）</emphasis> 。
      例如，不能用
       <link linkend="if-else"><phrase
      role="keep-together">if statement</phrase></link>，但是可以用
      <link linkend="op-other">条件 (<literal>?:</literal>)
      表达式</link>。</para>
    </note>

    <para> =&gt; 也可以使用参数类型（代码风格指南不建议使用类型）：</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>printNumber(num number) =&gt; print('The number is $number.'); // Types are OK.</programlisting>

    <para>调用方法的示例：</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>printNumber(123);</programlisting>

    <para>方法参数有两种类型：必需的和可选的。
        必需的参数出现在可选参数前面。</para>

    <sect2 id="functions-optional-parameters">
      <title>可选参数</title>

      <para>可选参数可以是命名参数或者位置参数。但是不能同时使用这两种类型。</para>

      <para>可选参数可以有默认值。默认值必需为编译期常量，例如 字面量定义。
          如果没有提供默认值，则默认值为 
       <literal
      moreinfo="none">null</literal>。</para>

      <sect3 id="functions-optional-named-parameters">
        <title>可选命名参数</title>

        <para>使用
        <literal moreinfo="none"><replaceable>paramName</replaceable>:
        <replaceable>value</replaceable></literal> 可以设置方法的命名参数。例如：</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark>enableFlags(bold: true, hidden: false);</programlisting>

        <para>用  <literal
        moreinfo="none">{<replaceable>param1</replaceable>,
        <replaceable>param2</replaceable>, …}</literal> 来定义方法的 命名参数：</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark>/// Sets the [bold] and [hidden] flags to the values you specify.
enableFlags({bool bold, bool hidden}) {
  // ...
}</programlisting>

        <para>使用冒号 (<literal moreinfo="none">:</literal>) 来设置默认值：</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark>/**
 * Sets the [bold] and [hidden] flags to the values you specify,
 * defaulting to false.
 */
enableFlags({bool bold: false, bool hidden: false}) {
  // ...
}

enableFlags(bold: true); // bold 的值为 true; hidden 没指定则为默认值 false.</programlisting>
      </sect3>

      <sect3 id="functions-optional-positional-parameters">
        <title>可选位置参数</title>

        <para>位于 <literal
        moreinfo="none">[]</literal> 中间的参数为可选位置  <phrase
        role="keep-together">参数</phrase>：</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark>String say(String from, String msg, [String device]) {
  var result = '$from says $msg';
  if (device != null) {
    result = '$result with a $device';
  }
  return result;
}</programlisting>

        <para>下面是没有设置可选位置参数的调用示例：</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark>assert(say('Bob', 'Howdy') == 'Bob says Howdy');</programlisting>

        <para>下面是设置了可选位置参数的示例：</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark>assert(say('Bob', 'Howdy', 'smoke signal') ==
  'Bob says Howdy with a smoke signal');</programlisting>

        <para>用 <literal moreinfo="none">=</literal> 设置默认值：</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark>String say(String from, String msg,
  [String device='carrier pigeon', String mood]) {
  var result = '$from says $msg';
  if (device != null) {
    result = '$result with a $device';
  }
  if (mood != null) {
    result = '$result (in a $mood mood)';
  }
  return result;
}

assert(say('Bob', 'Howdy') == 'Bob says Howdy with a carrier pigeon');</programlisting>
      </sect3>
    </sect2>

    <sect2 id="ch02-main">
      <title> main() 方法</title>

      <para>每个应用都有一个顶级的 <literal>main()</literal> 方法，
          该方法为程序的执行入口。
      <literal>main()</literal> 方法的返回值为 <literal>void</literal> 并有个可选
       <literal>List&lt;String&gt;</literal> 参数来接收程序参数。</para>

      <para>下面是一个 web 应用中的 <literal>main()</literal> 方法示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>main() {
  querySelector("#sample_text_id")
    ..text = "Click me!"
    ..onClick.listen(reverseText);
}</programlisting>

      <para>下面是带有两个参数的命令行程序 <literal>main()</literal> 方法示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
ch02/args.dart
</remark>// 通过命令运行该程序： dart args.dart 1 test
void main(List&lt;String&gt; arguments) {
  print(arguments);

  assert(arguments.length == 2); 
  assert(int.parse(arguments[0]) == 1);
  assert(arguments[1] == 'test'); 
}</programlisting>

      <para>可以用 <ulink
      url="http://api.dartlang.org/args.html">args 库</ulink> 
      来定义和解析命令行参数。</para>
    </sect2>

    <sect2 id="ch02-functions-first-class">
      <title>（方法作为一等对象）Functions as First-Class Objects</title>

      <para>可以把方法作为方法的参数使用：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>printElement(element) {
  print(element);
}
  
var list = [1,2,3];
list.forEach(printElement); // 把 printElement 方法当做参数来用</programlisting>

      <para>还可以用一个变量来保存方法引用：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var loudify = (msg) =&gt; '!!! ${msg.toUpperCase()} !!!';
assert(loudify('hello') == '!!! HELLO !!!');</programlisting>
    </sect2>

    <sect2 id="ch02-lexical-scope">
      <title>（语法作用域）Lexical Scope</title>

      <para>Dart 是一种语法作用域语言，也就是说 变量的作用域
          是根据代码布局静态判断的。
          可以根据“变量位于花括号内外”来判断一个变量是否在作用域中。
      </para>

      <para>下面是一个嵌套函数变量作用域示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var topLevel = true;
main() {
    var insideMain = true;
    
    myFunction() {
      var insideFunction = true;
      
      nestedFunction() {
        var insideNestedFunction = true;
        assert(topLevel);
        assert(insideMain);
        assert(insideFunction);
        assert(insideNestedFunction);
      }
    }
}</programlisting>

      <para>注意 <literal>nestedFunction()</literal> 可以
          使用外面所有花括号内的变量。</para>
    </sect2>

    <sect2 id="ch02-functions-lexical-closures">
      <title>（语法闭包）Lexical Closures</title>

      <para>一个 <emphasis>closure（闭包）</emphasis> 是一个可以
          访问位于其语法作用域内变量的方法对象，即时该方法用在其定义的作用域之外，也可以访问这些变量。
      </para>

      <para>方法可以覆盖定义在附近作用域的变量
          （Functions can close over variables defined in surrounding scopes）。
          在下面的示例中，
       <literal>adder()</literal> 捕获变量
        <literal moreinfo="none">addBy</literal>。
        无论在哪里使用返回的 adder 函数，该函数都记得
       <literal
      moreinfo="none">addBy</literal> 参数的值。</para>

      <programlisting format="linespecific"><remark>lang-dart</remark><remark>
ch02/function_closure.dart
</remark>/// Returns a function that adds [addBy] to a number.
Function makeAdder(num addBy) {
  adder(num i) {
    return addBy + i;
  }
  return adder;
}

main() {
  var add2 = makeAdder(2); // Create a function that adds 2.
  var add4 = makeAdder(4); // Create a function that adds 4.

  assert(add2(3) == 5);
  assert(add4(3) == 7);
}</programlisting>
    </sect2>

    <sect2 id="ch02-function-equality">
      <title>判断函数相等</title>

      <para>下面是测试顶级方法、静态函数、和实例函数相等的示例：</para>

      <programlisting><remark>lang-dart
</remark><remark>ch02/function_equality_2.dart
</remark>foo() {}               // A top-level function

class SomeClass {
  static void bar() {} // A static method
  void baz() {}        // An instance method
}

main() {
  var x;
  
  // Comparing top-level functions.
  x = foo;
  assert(x == foo);
  
  // Comparing static methods.
  x = SomeClass.bar;
  assert(x == SomeClass.bar);
  
  // Comparing instance methods.
  var v = new SomeClass();
  var w = new SomeClass();
  var y = v;
  x = v.baz;
  
  assert(x == y.baz);
  assert(v.baz != w.baz);
}</programlisting>
    </sect2>

    <sect2 id="ch02-functions-return-values">
      <title>返回值</title>

      <para>每个方法都有一个返回值。如果没有指定返回值，则默认会在函数最后附加一个
      <literal moreinfo="none">return null;</literal> 的语句。</para>
    </sect2>
  </sect1>

  <sect1 id="operators">
    <title>操作符</title>

    <para>Dart 定义了  <xref
    linkend="operator_table" /> 表中的操作符。 很多操作符都可以重写，在
     <xref linkend="classes-operators" /> 介绍了如何重写操作符。</para>

    <table class="operatorTable" id="operator_table">
      <title>操作符和优先级</title>

      <tgroup cols="2">
        <thead>
          <row>
            <entry>描述</entry>

            <entry>操作符</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>一元后缀操作符</entry>

            <entry class="operatorList"><replaceable>expr</replaceable>++
            &nbsp;&nbsp; <replaceable>expr</replaceable>-- &nbsp;&nbsp; ()
            &nbsp;&nbsp; [] &nbsp;&nbsp; .</entry>
          </row>

          <row>
            <entry>一元前缀操作符</entry>

            <entry class="operatorList">-<replaceable>expr</replaceable>
            &nbsp;&nbsp; !<replaceable>expr</replaceable> &nbsp;&nbsp;
            ~<replaceable>expr</replaceable> &nbsp;&nbsp;
            ++<replaceable>expr</replaceable> &nbsp;&nbsp;
            --<replaceable>expr</replaceable> &nbsp;&nbsp;</entry>
          </row>

          <row>
            <entry>乘除</entry>

            <entry class="operatorList">* &nbsp;&nbsp; / &nbsp;&nbsp; %
            &nbsp;&nbsp; ~/</entry>
          </row>

          <row>
            <entry>加减</entry>

            <entry class="operatorList">+ &nbsp;&nbsp; -</entry>
          </row>

          <row>
            <entry>位移</entry>

            <entry class="operatorList">&lt;&lt; &nbsp;&nbsp; &gt;&gt;</entry>
          </row>

          <row>
            <entry>位与 AND</entry>

            <entry class="operatorList">&amp;</entry>
          </row>

          <row>
            <entry>位异或 XOR</entry>

            <entry class="operatorList">^</entry>
          </row>

          <row>
            <entry>位或 OR</entry>

            <entry class="operatorList">|</entry>
          </row>

          <row>
            <entry>关系和类型测试</entry>

            <entry class="operatorList">&gt;= &nbsp;&nbsp; &gt; &nbsp;&nbsp;
            &lt;= &nbsp;&nbsp; &lt; &nbsp;&nbsp; as &nbsp;&nbsp; is
            &nbsp;&nbsp; is!</entry>
          </row>

          <row>
            <entry>相等</entry>

            <entry class="operatorList">== &nbsp;&nbsp; !=
            &nbsp;&nbsp;</entry>
          </row>

          <row>
            <entry>逻辑与 AND</entry>

            <entry class="operatorList">&amp;&amp;</entry>
          </row>

          <row>
            <entry>逻辑或 OR</entry>

            <entry class="operatorList">||</entry>
          </row>

          <row>
            <entry>条件表达式</entry>

            <entry class="operatorList"><replaceable>expr1</replaceable> ?
            <replaceable>expr2</replaceable> :
            <replaceable>expr3</replaceable></entry>
          </row>

          <row>
            <entry>级联操作符</entry>

            <entry class="operatorList">..</entry>
          </row>

          <row>
            <entry>赋值</entry>

            <entry class="operatorList">= &nbsp;&nbsp; *= &nbsp;&nbsp; /=
            &nbsp;&nbsp; ~/= &nbsp;&nbsp; %= &nbsp;&nbsp; += &nbsp;&nbsp; -=
            &nbsp;&nbsp; &lt;&lt;= &nbsp;&nbsp; &gt;&gt;= &nbsp;&nbsp; &amp;=
            &nbsp;&nbsp; ^= &nbsp;&nbsp; |= &nbsp;&nbsp;</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>当使用操作符的时候，就会创建一个
    <firstterm>表达式</firstterm>。
    下面是一些操作符表达式的示例：</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>a++
a + b
a = b
a == b
a? b: c
a is T</programlisting>

    <para>在 <xref linkend="operator_table" /> 中，每一行操作符都比其下面的操作符优先级要高。
    例如，除法操作符 <literal moreinfo="none">%</literal> 比  <literal
    moreinfo="none">==</literal> 操作符优先级高，而  <literal
    moreinfo="none">==</literal> 又比
     <literal moreinfo="none">&amp;&amp;</literal> 优先级高。
     所以下面的两行代码是一样的：</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>if ((n % i == 0) &amp;&amp; (d % i == 0)) // 使用括号提高代码可读性
if (n % i == 0 &amp;&amp; d % i == 0)     // 虽然难读，但是效果一样</programlisting>

    <warning>
      <para>
          对于连接两个操作数的操作符来说，左边的操作数决定使用那个版本的操作符。例如
          ，如果你有一个 Vector 对象和一个 Point 对象， <literal
      moreinfo="none">aVector + aPoint</literal> 则用 Vector 
  版本的 + 操作符。</para>
    </warning>

    <sect2 id="op-arithmetic">
      <title>算术操作符</title>

      <para>Dart  支持常规的算术操作符，如  <xref
      linkend="arithmetic_operator_table" /> 表格所示：</para>

      <table class="operatorTable" id="arithmetic_operator_table"
             role="keep-together">
        <title>算术操作符</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>操作符</entry>

              <entry>描述</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry class="operator">+</entry>

              <entry>加号</entry>
            </row>

            <row>
              <entry class="operator">–</entry>

              <entry>减号</entry>
            </row>

            <row>
              <entry class="operator">-<replaceable>expr</replaceable></entry>

              <entry>负号</entry>
            </row>

            <row>
              <entry class="operator">*</entry>

              <entry>乘号</entry>
            </row>

            <row>
              <entry class="operator">/</entry>

              <entry>除号</entry>
            </row>

            <row>
              <entry class="operator">~/</entry>

              <entry>整除号</entry>
            </row>

            <row>
              <entry class="operator">%</entry>

              <entry>取余</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>示例：</para>

      <programlisting format="linespecific"><remark>lang-dart</remark><remark>
ch02/arithmetic_operators.dart
</remark>assert(2 + 3 == 5);
assert(2 - 3 == -1);
assert(2 * 3 == 6);
assert(5 / 2 == 2.5);   // Result is a double
assert(5 ~/ 2 == 2);    // Result is an integer
assert(5 % 2 == 1);     // Remainder

print('5/2 = ${5~/2} remainder ${5%2}'); // 5/2 = 2 remainder 1</programlisting>

      <para>Dart 也支持前缀和后缀 加和减 操作符。</para>

      <table class="operatorTable" id="pfix_operator_table">
        <title>加减操作符</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>操作符</entry>

              <entry>描述</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry class="operator">++<replaceable>var</replaceable></entry>

              <entry><replaceable>var</replaceable> =
              <replaceable>var</replaceable> + 1 (expression value is
              <replaceable>var</replaceable> + 1)</entry>
            </row>

            <row>
              <entry class="operator"><replaceable>var</replaceable>++</entry>

              <entry><replaceable>var</replaceable> =
              <replaceable>var</replaceable> + 1 (expression value is
              <replaceable>var</replaceable>)</entry>
            </row>

            <row>
              <entry class="operator">--<replaceable>var</replaceable></entry>

              <entry><replaceable>var</replaceable> =
              <replaceable>var</replaceable> – 1 (expression value is
              <replaceable>var</replaceable> – 1)</entry>
            </row>

            <row>
              <entry class="operator"><replaceable>var</replaceable>--</entry>

              <entry><replaceable>var</replaceable> =
              <replaceable>var</replaceable> – 1 (expression value is
              <replaceable>var</replaceable>)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var a, b;

a = 0;  
b = ++a;         // Increment a before b gets its value.
assert(a == b);  // 1 == 1  

a = 0;
b = a++;         // Increment a AFTER b gets its value.
assert(a != b);  // 1 != 0

a = 0;
b = --a;         // Decrement a before b gets its value.
assert(a == b);  // -1 == -1

a = 0;
b = a--;         // Decrement a AFTER b gets its value.
assert(a != b) ; // -1 != 0</programlisting>
    </sect2>

    <sect2 id="op-equality">
      <title>关系和相等操作符</title>

      <table class="operatorTable" id="equality_operator_table">
        <title>关系和相等操作符</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>操作符</entry>

              <entry>描述</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry class="operator">==</entry>

              <entry>相等</entry>
            </row>

            <row>
              <entry class="operator">!=</entry>

              <entry>不等</entry>
            </row>

            <row>
              <entry class="operator">&gt;</entry>

              <entry>大于</entry>
            </row>

            <row>
              <entry class="operator">&lt;</entry>

              <entry>小于</entry>
            </row>

            <row>
              <entry class="operator">&gt;=</entry>

              <entry>大于等于</entry>
            </row>

            <row>
              <entry class="operator">&lt;=</entry>

              <entry>小于等于</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>用 <literal
      moreinfo="none">==</literal> 来测试两个对象 <replaceable>x</replaceable> 和
      <replaceable>y</replaceable> 是否代表同一个东西。
      (在极少数情况下，你需要知道两个对象是否是同一个对象，则使用
      <literal><ulink
      url="http://api.dartlang.org/dart_core.html#identical">identical()</ulink></literal>
      函数。) 下面是 <literal moreinfo="none">==</literal>
      操作符工作原理：</para>

      <orderedlist continuation="restarts" inheritnum="ignore">
        <listitem>
          <para>如果 <replaceable>x</replaceable> 或者
          <replaceable>y</replaceable> 是 null，只有当另外一个也是 null 的时候才返回 true，
          否则只有一个为 null 则返回 false。</para>
        </listitem>

        <listitem>
          <para>然后执行 <literal
          moreinfo="none"><replaceable>x</replaceable>.==(<replaceable>y</replaceable>)</literal> 函数。
          (没错， <literal
          moreinfo="none">==</literal> 操作符就是第一个对象的函数。
          你也可以重写大部分操作符，包括 
          <literal>==</literal>，在  <xref
          linkend="classes-operators" /> 介绍如何重写操作符。)</para>
        </listitem>
      </orderedlist>

      <para>下面是使用关系和等于操作符的示例：</para>

      <programlisting format="linespecific"><remark>lang-dart</remark><remark>
ch02/op_equality.dart
</remark>assert(2 == 2);
assert(2 != 3);
assert(3 &gt; 2);
assert(2 &lt; 3);
assert(3 &gt;= 3);
assert(2 &lt;= 3);</programlisting>
    </sect2>

    <sect2 id="ch02-op-type-test">
      <title>类型测试操作符</title>

      <para> <literal moreinfo="none">as</literal>、 <literal
      moreinfo="none">is</literal>、和 <literal moreinfo="none">is!</literal>
      操作符是运行时判断类型的操作符。
      </para>

      <table class="typeTestTable" id="type_test_operator_table">
        <title>类型测试操作符</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>操作符</entry>

              <entry>描述</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>as</entry>

              <entry>Typecast（类型转换）</entry>
            </row>

            <row>
              <entry class="operator">is</entry>

              <entry>如果 对象是该类型 则返回 true</entry>
            </row>

            <row>
              <entry class="operator">is!</entry>

              <entry>如果 对象是该类型 则返回  false</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>
          只有当 <literal moreinfo="none">obj</literal> 实现了 <literal moreinfo="none">T</literal> 接口（类）
          的时候，  <literal moreinfo="none">obj is T</literal> 的结果才是 true 。 例如 <literal
      moreinfo="none">obj is Object</literal> 总是返回 true。</para>

      <para>用 <literal moreinfo="none">as</literal> 操作符把一个对象转换为
          另外一个类型。
          通常 用来替换 <literal moreinfo="none">is</literal> 判断后跟一个使用该 对象的表达式。
          例如，下面的示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>if (person is Person) {               // Type check
  person.firstName = 'Bob';
}</programlisting>

      <para>使用 <literal
      moreinfo="none">as</literal> 操作符可以简化代码：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>(person as Person).firstName = 'Bob';</programlisting>

      <note>
        <para>注意：上面的代码并不等同。如果 <literal>person</literal> 是 null
        或者 不是一个  Person，第一个示例 (使用 <literal>is</literal> 的) 不执行后面的代码；
        而第二个示例  (使用 <literal>as</literal> 的) 则会抛出一个 <phrase
        role="keep-together">异常</phrase>。</para>
      </note>
    </sect2>

    <sect2 id="op-assign">
      <title>赋值操作符</title>

      <para>前面已经见到过了，用 <literal
      moreinfo="none">=</literal> 来赋值。也可以用复合赋值操作符
      来赋值，例如 <literal moreinfo="none">+=</literal>。</para>

      <table id="assignment_operator_table" role="keep-together">
        <title>赋值操作符</title>

        <tgroup cols="6">
          <tbody>
            <row>
              <entry>=</entry>

              <entry>–=</entry>

              <entry>/=</entry>

              <entry>%=</entry>

              <entry>&gt;&gt;=</entry>

              <entry>^=</entry>
            </row>

            <row>
              <entry>+=</entry>

              <entry>*=</entry>

              <entry>~/=</entry>

              <entry>&lt;&lt;=</entry>

              <entry>&amp;=</entry>

              <entry>|=</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>下面是复合赋值操作符的工作原理</para>

      <informaltable id="assignment_operator_concepts_table">
        <tgroup cols="3">
          <thead>
            <row>
              <entry></entry>

              <entry>复合赋值操作符</entry>

              <entry>等同的表达式</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><emphasis role="bold">对于一个操作符
              <replaceable>op</replaceable>:</emphasis></entry>

              <entry><literal moreinfo="none">a <replaceable>op</replaceable>=
              b</literal></entry>

              <entry><literal moreinfo="none">a = a
              <replaceable>op</replaceable> b</literal></entry>
            </row>

            <row>
              <entry><emphasis role="bold">示例 </emphasis></entry>

              <entry><literal moreinfo="none">a += b</literal></entry>

              <entry><literal moreinfo="none">a = a + b</literal></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>下面示例使用了 赋值和复合赋值操作符：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var a = 2;           // Assign using =
a *= 3;              // Assign and multiply: a = a * 3
assert(a == 6);</programlisting>
    </sect2>

    <sect2 id="op-logical">
      <title>逻辑操作符（逻辑运算符）</title>

      <para>逻辑操作符可以组合和取反义操作。</para>

      <table class="operatorTable" id="logical_operator_table"
             role="keep-together">
        <title>逻辑操作符</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>操作符</entry>

              <entry>描述</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry class="operator">!<replaceable>expr</replaceable></entry>

              <entry>取表达式的反义 （如果表达式为 true，则结果为 false，反之亦然。）</entry>
            </row>

            <row>
              <entry class="operator">||</entry>

              <entry>逻辑或 OR</entry>
            </row>

            <row>
              <entry class="operator">&amp;&amp;</entry>

              <entry>逻辑与 AND</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>下面是使用逻辑操作符的示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>if (!done &amp;&amp; (col == 0 || col == 3)) {
  // ...Do something...
}</programlisting>
    </sect2>

    <sect2 id="op-bit">
      <title>位和移位操作符</title>

      <para>
          在 Dart 中可以操作每个数字的字节。
          通常在整数上使用 位和移位操作符。如下表所示 <xref linkend="bit_operator_table" /> 的操作符：</para>

      <table class="operatorTable" id="bit_operator_table">
        <title>位和移位操作符</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>操作符</entry>

              <entry>描述</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry class="operator">&amp;</entry>

              <entry>AND</entry>
            </row>

            <row>
              <entry class="operator">|</entry>

              <entry>OR</entry>
            </row>

            <row>
              <entry class="operator">^</entry>

              <entry>XOR</entry>
            </row>

            <row>
              <entry class="operator">~<replaceable>expr</replaceable></entry>

              <entry>一元位补码操作符 (0s 变为 1s； 1s 变为
              0s)</entry>
            </row>

            <row>
              <entry class="operator">&lt;&lt;</entry>

              <entry>左移</entry>
            </row>

            <row>
              <entry class="operator">&gt;&gt;</entry>

              <entry>右移</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>下面是使用位和移位操作符的示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>final value = 0x22;
final bitmask = 0x0f;

assert((value &amp; bitmask)  == 0x02);  // AND
assert((value &amp; ~bitmask) == 0x20);  // AND NOT
assert((value | bitmask)  == 0x2f);  // OR
assert((value ^ bitmask)  == 0x2d);  // XOR
assert((value &lt;&lt; 4)       == 0x220); // Shift left
assert((value &gt;&gt; 4)       == 0x02);  // Shift right</programlisting>
    </sect2>

    <sect2 id="op-other">
      <title>其他操作符</title>

      <para>其他一些没介绍的操作符，但是大部分你应该在其他地方都看到过了。</para>

      <table class="operatorTable" id="other_operator_table"
             role="keep-together">
        <title>其他操作符</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry style="text-align:center">操作符</entry>

              <entry>名字</entry>

              <entry>描述</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry class="operator">()</entry>

              <entry>方法调用</entry>

              <entry>代表调用一个方法</entry>
            </row>

            <row>
              <entry class="operator">[]</entry>

              <entry>List 访问</entry>

              <entry>获取 list 某个位置的内容</entry>
            </row>

            <row>
              <entry
              class="operator"><replaceable>expr1</replaceable>&nbsp;?&nbsp;<replaceable>expr2</replaceable>&nbsp;:&nbsp;<replaceable>expr3</replaceable></entry>

              <entry>条件表达式</entry>

              <entry>如果 <replaceable>expr1</replaceable> 是 true，执行 
              <replaceable>expr2</replaceable>；否则，执行
              <replaceable>expr3</replaceable></entry>
            </row>

            <row>
              <entry class="operator">.</entry>

              <entry>成员访问</entry>

              <entry>访问一个成员，例如 <literal
              moreinfo="none">foo.bar</literal> 选择属性 ，访问
              <literal
              moreinfo="none">foo</literal>
              对象的 <literal
              moreinfo="none">bar</literal> 属性 </entry>
            </row>

            <row>
              <entry class="operator">..</entry>

              <entry>级联操作符</entry>

              <entry>可以在同一个对象上执行多个炒作 ，参考  <xref
              linkend="classes" /></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect2>
  </sect1>

  <sect1 id="control-flow-statements">
    <title>控制流程语句</title>

    <para>使用如下控制语句可以控制 Dart 代码的执行流程：</para>

    <itemizedlist>
      <listitem>
        <para><literal moreinfo="none">if</literal> 和 <literal
        moreinfo="none">else</literal></para>
      </listitem>

      <listitem>
        <para><literal moreinfo="none">for</literal> 循环</para>
      </listitem>

      <listitem>
        <para><literal moreinfo="none">while</literal> 和 <literal
        moreinfo="none">do</literal>-<literal moreinfo="none">while</literal>
        循环</para>
      </listitem>

      <listitem>
        <para><literal moreinfo="none">break</literal> 和 <literal
        moreinfo="none">continue</literal></para>
      </listitem>

      <listitem>
        <para><literal moreinfo="none">switch</literal> 和 <literal
        moreinfo="none">case</literal></para>
      </listitem>

      <listitem>
        <para><literal moreinfo="none">assert</literal></para>
      </listitem>
    </itemizedlist>

    <para>使用  <literal
    moreinfo="none">try-catch</literal> 和 <literal
    moreinfo="none">throw</literal> 也可以影响执行流程，在 <xref
    linkend="exceptions" /> 中有详细介绍。</para>

    <sect2 id="if-else">
      <title>If 和 Else</title>

      <para>Dart 支持 <literal moreinfo="none">if</literal> 语句和可选的
      <literal moreinfo="none">else</literal> 语句。
      在  <xref linkend="op-other" /> 还介绍了条件表达式 (?:)。</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>if (isRaining()) {
  you.bringRainCoat();
} else if (isSnowing()) {
  you.wearJacket();
} else {
  car.putTopDown();
}</programlisting>

      <para>注意： Dart 和 JavaScript 不同， 在 Dart 中只有
      <literal moreinfo="none">true</literal> 才被当做 true，所有其他对象都是 <literal
      moreinfo="none">false</literal>。详细信息参考 <xref linkend="booleans" /> 。</para>
    </sect2>

    <sect2 id="for-loops">
      <title>For 循环</title>

      <para>如下是标准的 <literal
      moreinfo="none">for</literal> 循环示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/flow_for_loops.dart
</remark>var message = new StringBuffer("Dart is fun");
for (var i = 0; i &lt; 5; i++) {
  message.write('!');
}</programlisting>

      <para> Dart <literal moreinfo="none">for</literal>循环中的闭包捕获
          循环的索引，避免 JavaScript 中出现的弊端。例如：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/flow_for_loops.dart
</remark>var callbacks = [];
for (var i = 0; i &lt; 2; i++) {
  callbacks.add(() =&gt; print(i));
}
callbacks.forEach((c) =&gt; c());</programlisting>

      <para>打印的结果为  <literal moreinfo="none">0</literal> 然后是 
      <literal moreinfo="none">1</literal>，和预期的结果一样。
      而在 JavaScript 中，结果会是  <literal moreinfo="none">2</literal> 和
      <literal moreinfo="none">2</literal> 。</para>

      <para>如果循环的对象是一个 Iterable ，则可以用 <literal><ulink
      url="http://api.dartlang.org/dart_core/Iterable.html#forEach">forEach()</ulink></literal>
      函数。如果无需关心当前的循环索引，则使用 <literal>forEach()</literal>
      是更好的选择：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/flow_for_loops.dart
</remark>candidates.forEach((candidate) =&gt; candidate.interview());</programlisting>

      <para>像 List 和 Set 这种 Iterable 对象还支持 <literal
      moreinfo="none">for-in</literal> 循环，在
      <phrase lang="" role="">in <xref
      linkend="ch03-iteration" /> 有介绍：</phrase></para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/flow_for_loops.dart
</remark>var collection = [0, 1, 2];
for (var x in collection) {
  print(x);
}</programlisting>
    </sect2>

    <sect2 id="while">
      <title>While 和 Do-While</title>

      <para>一个 <literal moreinfo="none">while</literal> 循环会在循环开始之前先
          计算条件的值：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>while(!isDone()) {
  doSomething();
}</programlisting>

      <para>而 一个 <literal moreinfo="none">do</literal>-<literal
      moreinfo="none">while</literal>  循环会先循环后计算
      条件的值：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>do {
  printLine();
} while (!atEndOfPage());</programlisting>
    </sect2>

    <sect2 id="break">
      <title>Break 和 Continue</title>

      <para>使用 <literal moreinfo="none">break</literal> 来终止
          循环：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>while (true) {
  if (shutDownRequested()) break;
  processIncomingRequests();
}</programlisting>

      <para>使用 <literal moreinfo="none">continue</literal> 
	来跳到下一个循环：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>for (int i = 0; i &lt; candidates.length; i++) {
  var candidate = candidates[i];
  if (candidate.yearsExperience &lt; 5) {
    continue;
  }
  candidate.interview();
}</programlisting>

      <para>如果使用  list 或者 set 则实现方式可以有所不同：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>candidates.where((c) =&gt; c.yearsExperience &gt;= 5)
          .forEach((c) =&gt; c.interview());</programlisting>
    </sect2>

    <sect2 id="switch">
      <title>Switch 和 Case</title>

      <para>Dart 中的 Switch 语句用 <literal moreinfo="none">==</literal> 来比较 integer、 string、或者编译期常量
           。被比较的对象必须为同一个类的实例（子类型不可以），并且类必须没有重写 <literal
      moreinfo="none">==</literal> 操作符。</para>

      <para>规则需要每个非空 <literal moreinfo="none">case</literal> 块以
       <literal moreinfo="none">break</literal> 语句结尾。
      其他非空
      <literal
      moreinfo="none">case</literal> 块可以是一个
      <literal
      moreinfo="none">continue</literal>、 <literal
      moreinfo="none">throw</literal>、或者 <literal
      moreinfo="none">return</literal> 语句。</para>

      <para>使用一个 <literal moreinfo="none">default</literal> 语句来执行
          不匹配任何 <literal moreinfo="none">case</literal> 语句的情况：</para>

      <programlisting format="linespecific" role="keep-together"><remark>lang-dart
</remark>var command = 'OPEN';
switch (command) {
  case 'CLOSED':
    executeClosed();
    break;
  case 'PENDING':
    executePending();
    break;
  case 'APPROVED':
    executeApproved();
    break;
  case 'DENIED':
    executeDenied();
    break;
  case 'OPEN':
    executeOpen();
    break;
  default:
    executeUnknown();
}</programlisting>

      <para>下面的示例代码在 <literal
      moreinfo="none">case</literal> 块中忘记添加
       <literal
      moreinfo="none">break</literal> 语句了， 这样会产生一个错误：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var command = 'OPEN';
switch (command) {
  case 'OPEN':
    executeOpen();
    // ERROR: 丢掉 break 语句会抛出一个异常！！

  case 'CLOSED':
    executeClosed();
    break;
}</programlisting>

      <para>然而， Dart 支持空 <literal
      moreinfo="none">case</literal> 块，空快可以允许执行后面一个 case 块的功能：</para>

      <programlisting format="linespecific" role=""><remark>lang-dart
</remark>var command = 'CLOSED';
switch (command) {
  case 'CLOSED':     // 空块会漏到下个块执行
  case 'NOW_CLOSED':
    //  CLOSED 和 NOW_CLOSED 都会执行该代码
    executeNowClosed();
    break;
}</programlisting>

      <para>如果你真的需要执行下一个 case 块中的代码，则可以用一个  <literal
      moreinfo="none">continue</literal> 语句和一个 label 组合：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var command = 'CLOSED';
switch (command) {
  case 'CLOSED':
    executeClosed();
    continue nowClosed; // 继续执行 nowClosed label

nowClosed:
  case 'NOW_CLOSED':
    // CLOSED 和 NOW_CLOSED 都会执行该代码
    executeNowClosed();
    break;
}</programlisting>

      <para> <literal moreinfo="none">case</literal> 块可以有本地变量，
          该变量只在该 case 块中可见。</para>
    </sect2>

    <sect2 id="assert">
      <title>Assert（断言）</title>

      <para>使用 <literal moreinfo="none">assert</literal> 
      语句来检测执行条件，如果提供的条件是 false 则中断执行并抛出异常。下面是一个
      assert 示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>assert(text != null);  // 确保 text 不为 null
assert(number &lt; 100);  // 确保该值小于 100.
assert(urlString.startsWith('https')); // 确保字符串以 https 开头</programlisting>

      <note>
        <para>Assert 语句只在检测模式下有效。
            在生产模式下无任何效果。</para>
      </note>

      <para> <literal
      moreinfo="none">assert</literal> 的参数可以是任何结果为 布尔 值的表达式或者方法。
      如果表达式或者方法的返回值为 true， 则通过断言检测代码继续执行。否则，断言将抛出一个异常  (是一个 <ulink
      url="http://api.dartlang.org/dart_core/AssertionError.html">AssertionError</ulink>)。
      </para>
    </sect2>
  </sect1>

  <sect1 id="exceptions">
    <title>Exceptions（异常）</title>

    <para>
        Dart 代码可以抛出和捕获异常。异常代表不可预期的错误情况。如果没有捕获异常，
        则抛出该异常的 isolate 将被挂起，通常该 isolate 就退出执行了。</para>

    <para>和 Java 语言不同， Dart 的所有异常都是 非检查异常（unchecked exceptions）。
        函数不用声明其可能抛出的异常，并且你也无捕获任何 <phrase
    role="keep-together">exceptions（异常）</phrase>。</para>

    <para>Dart 提供了 <ulink
    url="http://api.dartlang.org/dart_core/Exception.html">Exception</ulink>
    和 <ulink
    url="http://api.dartlang.org/docs/continuous/dart_core/Error.html">Error</ulink>
    类型，和很多预定义的子类。你也可以定义自己的异常类型。
    然而，Dart 程序可以把任意非 null 对象当做异常抛出，而不仅仅是  Exception 和 Error 对象。</para>

    <sect2 id="ch02-exceptions-throw">
      <title>Throw</title>

      <para>下面是 <emphasis>抛出</emphasis> 异常的示例：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>throw new ExpectException('Value must be greater than zero');</programlisting>

      <para>还可以抛出其他任意对象：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>throw 'Out of llamas!';</programlisting>

      <para>
          由于抛出异常是一个表达式，所有在任意可以用表达式的地方都可以抛出异常，
          例如  =&gt; 语句。</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>distanceTo(Point other) =&gt; throw new UnimplementedError();</programlisting>
    </sect2>

    <sect2 id="ch02-exceptions-catch">
      <title>Catch</title>

      <para>捕获异常可以阻止异常继续传递下去。捕获异常提供了一个处理该异常的机会：</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>try {
  breedMoreLlamas();
} on OutOfLlamasException {
  buyMoreLlamas();
}</programlisting>

      <para>
          要处理可能抛出多个类型异常的情况，你可以用多个
          catch 语句。 如果第一个 catch 语句不匹配该异常，则执行下一个。
          如果一个 catch 语句没有
          To handle code that can throw more than one type of exception, you
      can specify multiple catch clauses. The first catch clause that matches
      the thrown object’s type handles the exception. If the catch clause does
      not specify a type, that clause can handle any type of thrown
      object:</para>

      <programlisting format="linespecific" role="keep-together"><remark>lang-dart
</remark>try {
  breedMoreLlamas();
} on OutOfLlamasException {           // A specific exception
  buyMoreLlamas();
} on Exception catch(e) {             // Anything else that is an exception
  print('Unknown exception: $e');
} catch(e) {                          // No specified type, handles all
  print('Something really unknown: $e');
}</programlisting>

      <para>As the preceding code shows, you can use either <literal
      moreinfo="none">on</literal> or <literal moreinfo="none">catch</literal>
      or both. Use <literal moreinfo="none">on</literal> when you need to
      specify the exception type. Use <literal moreinfo="none">catch</literal>
      when your exception handler needs the exception object.</para>
    </sect2>

    <sect2 id="ch02-exceptions-finally">
      <title>Finally</title>

      <para>To ensure that some code runs whether or not an exception is
      thrown, use a <literal moreinfo="none">finally</literal> clause. If no
      <literal>catch</literal> clause matches the exception, the exception is
      propagated after the <literal>finally</literal> clause runs:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>try {
  breedMoreLlamas();
} finally {
  cleanLlamaStalls();  // Always clean up, even if an exception is thrown.
}</programlisting>

      <para>The <literal>finally</literal> clause runs after any matching
      <literal>catch</literal> clauses:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>try {
  breedMoreLlamas();
} catch(e) {
  print('Error: $e');  // Handle the exception first.
} finally {
  cleanLlamaStalls();  // Then clean up.
}</programlisting>

      <para>Learn more by reading <xref linkend="ch03-exceptions" />.</para>
    </sect2>
  </sect1>

  <sect1 id="classes">
    <title>Classes</title>

    <para>Dart is an object-oriented language with classes and single
    inheritance. Every object is an instance of a class, and all classes
    descend from <ulink
    url="http://api.dartlang.org/dart_core/Object.html">Object.</ulink></para>

    <para>To create an object, you can use the <literal
    moreinfo="none">new</literal> keyword with a
    <firstterm>constructor</firstterm> for a class. Constructor names can be
    either <emphasis><replaceable>ClassName</replaceable></emphasis> or
    <replaceable>ClassName.identifier</replaceable>. For example:</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>var jsonData = JSON.decode('{"x":1, "y":2}');

var p1 = new Point(2,2);               // Create a Point using Point().
var p2 = new Point.fromJson(jsonData); // Create a Point using Point.fromJson().</programlisting>

    <para>Objects have <firstterm>members</firstterm> consisting of functions
    and data (<firstterm>methods</firstterm> and <firstterm>instance
    variables</firstterm>, respectively). When you call a method, you
    <emphasis>invoke</emphasis> it on an object: the method has access to that
    object’s functions and data.</para>

    <para>Use a dot (.) to refer to an instance variable or method:</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>var p = new Point(2,2);

p.y = 3;             // Set the value of the instance variable y.
assert(p.y == 3);    // Get the value of y.

num distance = p.distanceTo(new Point(4,4)); // Invoke distanceTo() on p.</programlisting>

    <para>Use the cascade operator (..) when you want to perform a series of
    operations on the members of a single object:</para>

    <programlisting format="linespecific" role="keep-together"><remark>lang-dart
</remark>querySelector('#button')
    ..text = 'Click to Confirm'                        // Get an object. Use its
    ..classes.add('important')                         // instance variables
    ..onClick.listen((e) =&gt; window.alert('Confirmed!')); // and methods.</programlisting>

    <para>Some classes provide constant constructors. To create a compile-time
    constant using a constant constructor, use <literal
    moreinfo="none">const</literal> instead of <literal
    moreinfo="none">new</literal>:</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>var p = const ImmutablePoint(2,2);</programlisting>

    <para>Constructing two identical compile-time constants results in a
    single, canonical <phrase role="keep-together">instance:</phrase></para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>var a = const ImmutablePoint(1, 1);
var b = const ImmutablePoint(1, 1);

assert(identical(a,b)); // They are the same instance!</programlisting>

    <para>The following sections discuss how to implement classes.</para>

    <sect2 id="ch02-instance-variables">
      <title>Instance Variables</title>

      <para>Here’s how you declare instance variables:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/instance_variables.dart
</remark>class Point {
  num x;      // Declare an instance variable (x), initially null.
  num y;      // Declare y, initially null.
  num z = 0;  // Declare z, initially 0.
}</programlisting>

      <para>All uninitialized instance variables have the value <literal
      moreinfo="none">null</literal>.</para>

      <para>All instance variables generate an implicit
      <firstterm>getter</firstterm> method. Non-final instance variables also
      generate an implicit <firstterm>setter</firstterm> method. For details,
      see <xref linkend="classes-getters-and-setters" />.</para>

      <programlisting format="linespecific" role=""><remark>lang-dart
</remark><remark>ch02/instance_variables.dart
</remark>class Point {
  num x;
  num y;
}

main() {
  var point = new Point();
  point.x = 4;             // Use the setter method for x.
  assert(point.x == 4);    // Use the getter method for x.
  assert(point.y == null); // Values default to null.
}</programlisting>

      <para>If you initialize an instance variable where it is declared
      (instead of in a constructor or method), the value is set when the
      instance is created, which is before the constructor and its initializer
      list execute.</para>
    </sect2>

    <sect2 id="ch02-constructors">
      <title>Constructors</title>

      <para>Declare a constructor by creating a function with the same name as
      its class (plus, optionally, an additional identifier as described in
      <xref linkend="ch02-constructors-named" />). The most common form of
      constructor, the generative constructor, creates a new instance of a
      class:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/constructor_long_way.dart
</remark>class Point {
  num x;
  num y;

  Point(num x, num y) {
    // There's a better way to do this, stay tuned.
    this.x = x;
    this.y = y;
  }
}</programlisting>

      <para>The <literal moreinfo="none">this</literal> keyword refers to the
      current instance.</para>

      <note>
        <para>Use <literal moreinfo="none">this</literal> only when there is a
        name conflict. Otherwise, Dart style omits the <literal
        moreinfo="none">this</literal>.</para>
      </note>

      <para>The pattern of assigning a constructor argument to an instance
      variable is so common, Dart has syntactic sugar to make it easy:</para>

      <programlisting format="linespecific" role="keep-together"><remark>lang-dart
</remark>class Point {
  num x;
  num y;

  // Syntactic sugar for setting x and y before the constructor body runs.
  Point(this.x, this.y);
}</programlisting>

      <sect3 id="ch02-constructors-default">
        <title>Default constructors</title>

        <para>If you don’t declare a constructor, a default constructor is
        provided for you. The default constructor has no arguments and invokes
        the no-argument constructor in the <phrase
        role="keep-together">superclass</phrase>.</para>
      </sect3>

      <sect3 id="ch02-constructors-not-inherited">
        <title>Constructors aren’t inherited</title>

        <para>Subclasses don’t inherit constructors from their superclass. A
        subclass that declares no constructors has only the default (no
        argument, no name) constructor.</para>
      </sect3>

      <sect3 id="ch02-constructors-named">
        <title>Named constructors</title>

        <para>Use a named constructor to implement multiple constructors for a
        class or to provide extra clarity:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/named_constructor.dart
</remark>class Point {
  num x;
  num y;

  Point(this.x, this.y);

  // Named constructor
  Point.fromJson(Map json) {
    x = json['x'];
    y = json['y'];
  }
}</programlisting>

        <para>Remember that constructors are not inherited, which means that a
        superclass’s named constructor is not inherited by a subclass. If you
        want a subclass to be created with a named constructor defined in the
        superclass, you must implement that constructor in the
        subclass.</para>
      </sect3>

      <sect3 id="ch02-constructor-non-default-superclass">
        <title>Invoking a non-default superclass constructor</title>

        <para>By default, a constructor in a subclass calls the superclass’s
        unnamed, no-argument constructor. If the superclass doesn’t have such
        a constructor, then you must manually call one of the constructors in
        the superclass. Specify the superclass constructor after a colon
        (<literal>:</literal>), just before the constructor body (if
        any).</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/op_as.dart
</remark>class Person {
  Person.fromJson(Map data) {
    print('in Person');
  }
}

class Employee extends Person {
  // Person does not have a default constructor;
  // you must call super.fromJson(data).
  Employee.fromJson(Map data) : super.fromJson(data) {
    print('in Employee');
  }
}

main() {
  var emp = new Employee.fromJson({});

  // Prints:
  // in Person
  // in Employee
}</programlisting>

        <para>Because the arguments to the superclass constructor are
        evaluated before invoking the constructor, an argument can be an
        expression such as a function call:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/method_then_constructor.dart
</remark>class Employee extends Person {
  ...
  Employee() : super.fromJson(findDefaultData());
}</programlisting>

        <warning>
          <para>Arguments to the superclass constructor do not have access to
          <literal moreinfo="none">this</literal>. For example, arguments can
          call static methods but not instance methods.</para>
        </warning>
      </sect3>

      <sect3 id="ch02-constructor-initializer-list">
        <title>Initializer list</title>

        <para>Besides invoking a superclass constructor, you can also
        initialize instance variables before the constructor body runs.
        Separate initializers with commas.</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/initializer_list.dart
</remark>class Point {
  num x;
  num y;

  Point(this.x, this.y);

  // Initializer list sets instance variables before the constructor body runs.
  Point.fromJson(Map json) : x = json['x'], y = json['y'] {
    print('In Point.fromJson(): ($x, $y)');
  }
}</programlisting>

        <warning>
          <para>The right-hand side of an initializer does not have access to
          <literal moreinfo="none">this</literal>.</para>
        </warning>
      </sect3>

      <sect3 id="ch02-constructor-redirecting">
        <title>Redirecting constructors</title>

        <para>Sometimes a constructor’s only purpose is to redirect to another
        constructor in <phrase role="keep-together">the same class.</phrase> A
        redirecting constructor’s body is empty, with the constructor call
        <phrase role="keep-together">appearing after a colon
        (:).</phrase></para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/along_x_axis.dart
</remark>class Point {
  num x;
  num y;

  Point(this.x, this.y);                // The main constructor for this class.
  Point.alongXAxis(num x) : this(x, 0); // Delegates to the main constructor.
}</programlisting>
      </sect3>

      <sect3 id="ch02-constructor-constant">
        <title>Constant constructors</title>

        <para>If your class produces objects that never change, you can make
        these objects compile-time constants. To do this, define a <literal
        moreinfo="none">const</literal> constructor and make sure that all
        instance variables are <literal
        moreinfo="none">final</literal>.</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/immutable_point.dart
</remark>class ImmutablePoint {
  final num x;
  final num y;
  const ImmutablePoint(this.x, this.y);
  static final ImmutablePoint origin = const ImmutablePoint(0, 0);
}</programlisting>
      </sect3>

      <sect3 id="ch02-constructor-factory">
        <title>Factory constructors</title>

        <para>Use the <literal moreinfo="none">factory</literal> keyword when
        implementing a constructor that doesn’t always create a new instance
        of its class. For example, a factory constructor might return an
        instance from a cache, or it might return an instance of a
        subtype.</para>

        <para>The following example demonstrates a factory constructor
        returning objects from a cache:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/factory_constructor.dart
</remark>class Logger {
  final String name;
  bool mute = false;

  // _cache is library-private, thanks to the _ in front of its name.
  static final Map&lt;String, Logger&gt; _cache = &lt;String, Logger&gt;{};
  
  factory Logger(String name) {
    if (_cache.containsKey(name)) {
      return _cache[name];
    } else {
      final logger = new Logger._internal(name);
      _cache[name] = logger;
      return logger;
    }
  }
  
  Logger._internal(this.name);
  
  void log(String msg) {
    if (!mute) {
      print(msg);
    }
  }
}</programlisting>

        <note>
          <para>Factory constructors have no access to <literal
          moreinfo="none">this</literal>.</para>
        </note>

        <para>To invoke a factory constructor, you use the <literal
        moreinfo="none">new</literal> keyword:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/factory_constructor.dart
</remark>var logger = new Logger('UI');
logger.log('Button clicked');</programlisting>
      </sect3>
    </sect2>

    <sect2 id="ch02-methods">
      <title>Methods</title>

      <para>Methods are functions that provide behavior for an object.</para>

      <sect3 id="ch02-methods-instance">
        <title>Instance methods</title>

        <para>Instance methods on objects can access instance variables and
        <literal moreinfo="none">this</literal>. The
        <literal>distanceTo()</literal> method in the following sample is an
        example of an instance method:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/distance_to.dart
</remark>import 'dart:math';

class Point {
  num x;
  num y;
  Point(this.x, this.y);

  num distanceTo(Point other) {
    var dx = x - other.x;
    var dy = y - other.y;
    return sqrt(dx * dx + dy * dy);
  }
}</programlisting>
      </sect3>

      <sect3 id="classes-getters-and-setters">
        <title>Getters and setters</title>

        <para>Getters and setters are special methods that provide read and
        write access to an object’s properties. Recall that each instance
        variable has an implicit getter, plus a setter if appropriate. You can
        create additional properties by implementing getters and setters,
        using the <literal moreinfo="none">get</literal> and <literal
        moreinfo="none">set</literal> keywords:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/rectangle.dart
</remark>class Rectangle {
  num left;
  num top;
  num width;
  num height;

  Rectangle(this.left, this.top, this.width, this.height);

  // Define two calculated properties: right and bottom.
  num get right             =&gt; left + width;
      set right(num value)  =&gt; left = value - width;
  num get bottom            =&gt; top + height;
      set bottom(num value) =&gt; top = value - height;
}

main() {
  var rect = new Rectangle(3, 4, 20, 15);
  assert(rect.left == 3);
  rect.right = 12;
  assert(rect.left == -8);
}</programlisting>

        <para>With getters and setters, you can start with instance variables,
        later wrapping them with methods, all without changing client
        code.</para>

        <para><note>
            <para>Operators such as increment (++) work in the expected way,
            whether or not a getter is explicitly defined. To avoid any
            unexpected side effects, the operator calls the getter exactly
            once, saving its value in a temporary variable.</para>
          </note></para>
      </sect3>

      <sect3 id="ch02-method-abstract">
        <title>Abstract methods</title>

        <para>Instance, getter, and setter methods can be abstract, defining
        an interface but leaving its implementation up to other classes. To
        make a method abstract, use a semicolon (;) instead of a method
        body:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/doer.dart
</remark>abstract class Doer {
  // ...Define instance variables and methods...
 
  void doSomething(); // Define an abstract method.
}

class EffectiveDoer extends Doer {
  void doSomething() {
    // ...Provide an implementation, so the method is not abstract here...
  }
}</programlisting>

        <para>Calling an abstract method results in a run-time error.</para>

        <para>Also see <xref linkend="ch02-class-abstract" />.</para>
      </sect3>

      <sect3 id="classes-operators">
        <title>Overridable Operators</title>

        <para>You can override the operators shown in <xref
        linkend="overridden_operator_table" />. For example, if you define a
        Vector class, you might define a <literal>+</literal> method to add
        two vectors.</para>

        <table id="overridden_operator_table" role="keep-together">
          <title>Operators that can be overridden</title>

          <tgroup cols="4">
            <tbody>
              <row>
                <entry>&lt;</entry>

                <entry>+</entry>

                <entry>|</entry>

                <entry>[]</entry>
              </row>

              <row>
                <entry>&gt;</entry>

                <entry>/</entry>

                <entry>^</entry>

                <entry>[]=</entry>
              </row>

              <row>
                <entry>&lt;=</entry>

                <entry>~/</entry>

                <entry>&amp;</entry>

                <entry>~</entry>
              </row>

              <row>
                <entry>&gt;=</entry>

                <entry>*</entry>

                <entry>&lt;&lt;</entry>

                <entry>==</entry>
              </row>

              <row>
                <entry>–</entry>

                <entry>%</entry>

                <entry>&gt;&gt;</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Here’s an example of a class that overrides the <literal
        moreinfo="none">+</literal> and <literal moreinfo="none">-</literal>
        operators:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/vector.dart
</remark>class Vector {
  final int x;
  final int y;
  const Vector(this.x, this.y);

  Vector operator +(Vector v) { // Overrides + (a + b).
    return new Vector(x + v.x, y + v.y);
  }

  Vector operator -(Vector v) { // Overrides - (a - b).
    return new Vector(x - v.x, y - v.y);
  }
}

main() {
  final v = new Vector(2,3);
  final w = new Vector(2,2);

  assert(v.x == 2 &amp;&amp; v.y == 3);         // v   == (2,3)
  assert((v+w).x == 4 &amp;&amp; (v+w).y == 5); // v+w == (4,5)
  assert((v-w).x == 0 &amp;&amp; (v-w).y == 1); // v-w == (0,1)
}</programlisting>

        <para>For an example of overriding <literal
        moreinfo="none">==</literal>, see <xref
        linkend="ch03-implementing-map-keys" />. For more information on
        overriding, in general, see <xref
        linkend="ch02-class-extend" />.</para>
      </sect3>
    </sect2>

    <sect2 id="ch02-class-abstract">
      <title>Abstract Classes</title>

      <para>Use the <literal moreinfo="none">abstract</literal> modifier to
      define an <firstterm>abstract class</firstterm>—a class that can’t be
      instantiated. Abstract classes are useful for defining interfaces, often
      with some implementation. If you want your abstract class to appear to
      be instantiable, define a <link
      linkend="ch02-constructor-factory">factory constructor</link>.</para>

      <para>Abstract classes often have <link
      linkend="ch02-method-abstract">abstract methods</link>. Here’s an
      example of declaring an abstract class that has an abstract
      method:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/abstract.dart
</remark>// This class is declared abstract and thus can't be instantiated.
abstract class AbstractContainer {
  // ...Define constructors, fields, methods...

  void updateChildren(); // Abstract method.
}</programlisting>

      <para>The following class isn’t abstract, and thus can be instantiated
      even though it defines an abstract method:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/abstract.dart
</remark>class SpecializedContainer extends AbstractContainer {
  // ...Define more constructors, fields, methods...

  void updateChildren() {
    // ...Implement updateChildren()...
  }
// Abstract method causes a warning but doesn't prevent instantiatation.
  void doSomething(); 
}</programlisting>
    </sect2>

    <sect2 id="ch02-implicit-interfaces">
      <title>Implicit Interfaces</title>

      <para>Every class implicitly defines an interface containing all the
      instance members of the class and of any interfaces it implements. If
      you want to create a class A that supports class B’s API without
      inheriting B’s implementation, class A should implement the B
      interface.</para>

      <para>A class implements one or more interfaces by declaring them in an
      <literal moreinfo="none">implements</literal> clause and then providing
      the APIs required by the interfaces. For example:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/imposter.dart
</remark>// A person. The implicit interface contains greet().
class Person {
  final _name;          // In the interface, but visible only in this library,
  Person(this._name);   // Not in the interface, since this is a constructor.
  String greet(who) =&gt; 'Hello, $who. I am $_name.'; // In the interface.
}

// An implementation of the Person interface.
class Imposter implements Person {
  final _name = "";      // We have to define this, but we don't use it.
  String greet(who) =&gt; 'Hi $who. Do you know who I am?';
}

greetBob(Person person) =&gt; person.greet('bob');

main() {
  print(greetBob(new Person('kathy')));
  print(greetBob(new Imposter()));
}</programlisting>

      <para>Here’s an example of specifying that a class implements multiple
      interfaces:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/point_interfaces.dart
</remark>class Point <emphasis role="bold">implements Comparable, Location</emphasis> {
  // ...
}</programlisting>
    </sect2>

    <sect2 id="ch02-class-extend">
      <title>Extending a Class</title>

      <para>Use <literal moreinfo="none">extends</literal> to create a
      subclass, and <literal moreinfo="none">super</literal> to refer to the
      superclass:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>smart_tv.dart
</remark>class Television {
  void turnOn() {
    _illuminateDisplay();
    _activateIrSensor();
  }
  ...
}

class SmartTelevision extends Television {
  void turnOn() {
    super.turnOn();
    _bootNetworkInterface();
    _initializeMemory();
    _upgradeApps();
  }
  ...
}</programlisting>

      <para>Subclasses can override instance methods, getters, and setters.
      Here’s an example of overriding the Object class’s
      <literal>noSuchMethod()</literal> method, which is called whenever code
      attempts to use a non-existent method or instance variable:</para>

      <programlisting><remark>lang-dart
</remark><remark>ch02/no_such_method.dart
</remark>class A {
  // Unless you override noSuchMethod, using a non-existent member
  // results in a NoSuchMethodError.
  void noSuchMethod(Invocation mirror) {
    print('You tried to use a non-existent member: ${mirror.memberName}');
  }
}</programlisting>

      <para>You can use the <literal>@override</literal> annotation to
      indicate that you are intentionally overriding a member:</para>

      <programlisting><remark>lang-dart
</remark><remark>ch02/ch02_meta/bin/ch02_override.dart
</remark>class A {
  @override
  void noSuchMethod(Invocation mirror) {
    // ...
  }
}</programlisting>

      <para>If you use <literal>noSuchMethod()</literal> to implement every
      possible getter, setter, and method for a class, then you can use the
      <literal>@proxy</literal> annotation to avoid warnings:</para>

      <programlisting><remark>lang-dart
</remark><remark>ch02/ch02_meta/bin/ch02_proxy.dart
</remark>@proxy
class A {
  void noSuchMethod(Invocation mirror) {
    // ...
  }
}</programlisting>

      <para>For more information on annotations, see <xref
      linkend="ch02-metadata" />.</para>
    </sect2>

    <sect2 id="ch02-mixins">
      <title>Adding Features to a Class: Mixins</title>

      <para>Mixins are a way to inject behavior into classes without relying
      on inheritance.</para>

      <para>To use a mixin, use the <literal>with</literal> keyword followed
      by one or more mixin names. The following example shows two classes that
      use mixins:</para>

      <programlisting><remark>lang-dart
</remark><remark>ch02/mixins.dart
</remark>class Musician extends Performer with Musical {
  ...
}

class Maestro extends Person with Musical, Aggressive, Demented {
  Maestro(String maestroName) {
    name = maestroName;
    canConduct = true;
  }
}</programlisting>

      <para>To implement a mixin, create a class that extends Object, declares
      no constructors, and has no calls to <literal>super</literal>. For
      example:</para>

      <programlisting><remark>lang-dart
</remark><remark>ch02/mixins.dart
</remark>abstract class Musical {
  bool canPlayPiano = false;
  bool canCompose = false;
  bool canConduct = false;
  
  void entertainMe() {
    if (canPlayPiano) {
      print('Playing piano');
    } else if (canConduct) {
      print('Waving hands');
    } else {
      print('Humming to self');
    }
  }
}</programlisting>

      <para>For more information, see the article <ulink
      url="http://www.dartlang.org/articles/mixins/">Mixins in
      Dart.</ulink></para>
    </sect2>

    <sect2 id="ch02-class-vars-and-methods">
      <title>Class Variables and Methods</title>

      <para>Use the <literal moreinfo="none">static</literal> keyword to
      implement class-wide variables and methods.</para>

      <sect3 id="ch02-static-variables">
        <title>Static variables</title>

        <para>Static variables (class variables) are useful for class-wide
        state and constants:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/color.dart
</remark>class Color {
  static const RED = const Color('red'); // A constant static variable.
  final String name;                     // An instance variable.
  const Color(this.name);                // A constant constructor.
}

main() {
  assert(Color.RED.name == 'red');
}</programlisting>

        <para>Static variables aren’t initialized until they’re used.</para>
      </sect3>

      <sect3 id="ch02-static-methods">
        <title>Static methods</title>

        <para>Static methods (class methods) do not operate on an instance,
        and thus do not have access to <literal
        moreinfo="none">this</literal>. For example:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/point.dart
</remark>import 'dart:math';

class Point {
  num x;
  num y;
  Point(this.x, this.y);

  static num distanceBetween(Point a, Point b) {
    var dx = a.x - b.x;
    var dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
  }
}

main() {
  var a = new Point(2, 2);
  var b = new Point(4, 4);
  var distance = Point.distanceBetween(a,b);
  assert(distance &lt; 2.9 &amp;&amp; distance &gt; 2.8);
}</programlisting>

        <note>
          <para>Consider using top-level functions, instead of static methods,
          for common or widely used utilities and functionality.</para>
        </note>

        <para>You can use static methods as compile-time constants. For
        example, you can pass a static method as a parameter to a constant
        constructor.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="generics">
    <title>Generics</title>

    <para>If you look at the API documentation for the basic array type,
    <ulink url="http://api.dartlang.org/dart_core/List.html">List,</ulink>
    you’ll see that the type is actually <literal
    moreinfo="none">List&lt;E&gt;</literal>. The &lt;...&gt; notation marks
    List as a <emphasis>generic</emphasis> (or
    <emphasis>parameterized</emphasis>) type—a type that has formal type
    parameters. By convention, type variables have single-letter names, such
    as E, T, S, K, and V.</para>

    <sect2 id="ch02-generics-why">
      <title>Why Use Generics?</title>

      <para>Because types are optional in Dart, you never
      <emphasis>have</emphasis> to use generics. You might
      <emphasis>want</emphasis> to, though, for the same reason you might want
      to use other types in your code: types (generic or not) let you document
      and annotate your code, making your intent clearer.</para>

      <para>For example, if you intend for a list to contain only strings, you
      can declare it as <literal moreinfo="none">List&lt;String&gt;</literal>
      (read that as <quote>list of string</quote>). That way you, your fellow
      programmers, and your tools (such as Dart Editor and the Dart VM in
      checked mode) can detect that assigning a non-string to the list is
      probably a mistake. Here’s an example:</para>

      <programlisting format="linespecific"><remark>lang-dart</remark><remark>
ch02/generics.dart
</remark>var names = new List&lt;String&gt;();
names.addAll(['Seth', 'Kathy', 'Lars']);
// ...
names.add(42); // Fails in checked mode (succeeds in production mode).</programlisting>

      <para>Another reason for using generics is to reduce code duplication.
      Generics let you share a single interface and implementation between
      many types, while still taking advantage of checked mode and static
      analysis early warnings. For example, say you create an interface for
      caching an object:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>abstract class ObjectCache {
  Object getByKey(String key);
  setByKey(String key, Object value);
}</programlisting>

      <para>You discover that you want a string-specific version of this
      interface, so you create another interface:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>abstract class StringCache {
  String getByKey(String key);
  setByKey(String key, String value);
}</programlisting>

      <para>Later, you decide you want a number-specific version of this
      interface... You get the idea.</para>

      <para>Generic types can save you the trouble of creating all these
      interfaces. Instead, you can create a single interface that takes a type
      parameter:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>abstract class Cache&lt;T&gt; {
  T getByKey(String key);
  setByKey(String key, T value);
}</programlisting>

      <para>In this code, T is the stand-in type. It’s a placeholder that you
      can think of as a type that a developer will define later.</para>
    </sect2>

    <sect2 id="generics-literals">
      <title>Using Collection Literals</title>

      <para>List and map literals can be parameterized. Parameterized literals
      are just like the literals you’ve already seen, except that you add
      <literal
      moreinfo="none">&lt;<replaceable>type</replaceable>&gt;</literal> (for
      lists) or <literal
      moreinfo="none">&lt;<replaceable>keyType</replaceable>,
      <replaceable>valueType</replaceable>&gt;</literal> (for maps) before the
      opening bracket. You might use parameterized literals when you want type
      warnings in checked mode. Here is example of using typed
      literals:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var names = &lt;String&gt;['Seth', 'Kathy', 'Lars'];
var pages = &lt;String, String&gt;{
    'index.html':'Homepage',
    'robots.txt':'Hints for web robots',
    'humans.txt':'We are people, not machines' };</programlisting>
    </sect2>

    <sect2 id="generics-constructors">
      <title>Using Parameterized Types with Constructors</title>

      <para>To specify one or more types when using a constructor, put the
      types in angle brackets (<literal moreinfo="none">&lt;...&gt;</literal>)
      just after the class name. For example:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var names = new List&lt;String&gt;();
names.addAll(['Seth', 'Kathy', 'Lars']);
var nameSet = new Set&lt;String&gt;.from(names);</programlisting>

      <para>The following code creates a map that has integer keys and values
      of type View:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var views = new Map&lt;int, View&gt;();</programlisting>
    </sect2>

    <sect2 id="generics-collections">
      <title>Generic Collections and the Types they Contain</title>

      <para>Dart generic types are <emphasis>reified</emphasis>, which means
      that they carry their type information around at runtime. For example,
      you can test the type of a collection, even in production mode:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var names = new List&lt;String&gt;();
names.addAll(['Seth', 'Kathy', 'Lars']);
print(names is List&lt;String&gt;); // true</programlisting>

      <para>However, the <literal moreinfo="none">is</literal> expression
      checks the type of the <emphasis>collection</emphasis> only—not of the
      objects inside it. In production mode, a
      <literal>List&lt;String&gt;</literal> might have some non-string items
      in it. The solution is to either check each item’s type or wrap
      item-manipulation code in an exception handler (see <xref
      linkend="exceptions" />).</para>

      <note>
        <para>In contrast, generics in Java use <emphasis>erasure</emphasis>,
        which means that generic type parameters are removed at runtime. In
        Java, you can test whether an object is a List, but you can’t test
        whether it’s a <literal>List&lt;String&gt;</literal>.</para>
      </note>

      <para>For more information about generics, see <ulink
      url="http://www.dartlang.org/articles/optional-types/">Optional Types in
      Dart.</ulink></para>
    </sect2>
  </sect1>

  <sect1 id="libraries">
    <title>Libraries and Visibility</title>

    <para>The <literal moreinfo="none">import</literal>, <literal
    moreinfo="none">part</literal>, and <literal
    moreinfo="none">library</literal> directives can help you create a modular
    and shareable code base. Libraries not only provide APIs, but are a unit
    of privacy: identifiers that start with an underscore (_) are visible only
    inside the library. <emphasis>Every Dart app is a library</emphasis>, even
    if it doesn’t use a library directive.</para>

    <para>Libraries can be distributed using packages. See <xref
    linkend="ch04-tools-pub" /> for information about pub, a package manager
    included in the SDK.</para>

    <sect2 id="libraries-import">
      <title>Using Libraries</title>

      <para>Use <literal moreinfo="none">import</literal> to specify how a
      namespace from one library is used in the scope of another
      library.</para>

      <para>For example, Dart web apps generally use the <ulink
      url="http://api.dartlang.org/html.html">dart:html</ulink> library, which
      they can import like this:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/libraries/using_libraries.dart
</remark>import 'dart:html';</programlisting>

      <para>The only required argument to <literal
      moreinfo="none">import</literal> is a URI<footnote id="ch02-footnote-1">
          <para>URI stands for <firstterm>uniform resource
          identifier</firstterm>. URLs (<firstterm>uniform resource
          locators</firstterm>) are a common kind of URI.</para>
        </footnote> specifying the library. For built-in libraries, the URI
      has the special <literal moreinfo="none">dart:</literal> scheme. For
      other libraries, you can use a file system path or the <literal
      moreinfo="none">package:</literal> scheme. The <literal
      moreinfo="none">package:</literal> scheme specifies libraries provided
      by a package manager such as the pub tool. For example:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/libraries/using_schemes.dart, mylib, utils
</remark>import 'dart:io';
import 'package:mylib/mylib.dart';
import 'package:utils/utils.dart';</programlisting>

      <sect3 id="libraries-prefix">
        <title>Specifying a library prefix</title>

        <para>If you import two libraries that have conflicting identifiers,
        then you can specify a prefix for one or both libraries. For example,
        if library1 and library2 both have an Element class, then you might
        have code like this:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/libraries/library_prefix.dart, lib1, lib2
</remark>import 'package:lib1/lib1.dart';
import 'package:lib2/lib2.dart' as lib2;
// ...
var element1 = new Element();      // Uses Element from lib1.
var element2 = new lib2.Element(); // Uses Element from lib2.</programlisting>
      </sect3>

      <sect3 id="ch02-library-import-part">
        <title>Importing only part of a library</title>

        <para>If you want to use only part of a library, you can selectively
        import the library. For example:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/libraries/library_partil.dart, lib1, lib2
</remark>import 'package:lib1/lib1.dart' show foo; // Import only foo.
import 'package:lib2/lib2.dart' hide foo; // Import all names EXCEPT foo.</programlisting>
      </sect3>
    </sect2>

    <sect2 id="libraries-implementing">
      <title>Implementing Libraries</title>

      <para>Use <literal moreinfo="none">library</literal> to name a library,
      and <literal moreinfo="none">part</literal> to specify additional files
      in the library.</para>

      <note>
        <para>You don’t have to use <literal>library</literal> in an app (a
        file that has a top-level main() function), but doing so lets you
        implement the app in multiple files.</para>
      </note>

      <sect3 id="libraries-library">
        <title>Declaring a library</title>

        <para>Use <literal moreinfo="none">library
        <replaceable>identifier</replaceable></literal> to specify the name of
        the current library:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/ballgame.dart
</remark>library ballgame;   // Declare that this is a library named ballgame.

import 'dart:html'; // This app uses the HTML library.
// ...Code goes here...
</programlisting>
      </sect3>

      <sect3 id="libraries-source">
        <title>Associating a file with a library</title>

        <para>To add an implementation file, put <literal>part
        <replaceable>fileUri</replaceable></literal> in the file that has the
        <literal>library</literal> statement, where
        <emphasis>fileUri</emphasis> is the path to the implementation file.
        Then in the implementation file, put <literal>part of
        <replaceable>identifier</replaceable></literal>, where
        <emphasis>identifier</emphasis> is the name of the library. The
        following example uses <literal>part</literal> and <literal>part
        of</literal> to implement a library in three files.</para>

        <para>The first file, <literal>ballgame.dart</literal>, declares the
        ballgame library, imports other libraries it needs, and specifies that
        <literal>ball.dart</literal> and <literal>util.dart</literal> are
        parts of this library:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/ballgame.dart
</remark>library ballgame;

import 'dart:html';
// ...Other imports go here...

part 'ball.dart';
part 'util.dart';

// ...Code might go here...</programlisting>

        <para>The second file, <literal>ball.dart</literal>, implements part
        of the ballgame library:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/ball.dart
</remark>part of ballgame;

// ...Code goes here...</programlisting>

        <para>The third file, <literal>util.dart</literal>, implements the
        rest of the ballgame library:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/util.dart
</remark>part of ballgame;

// ...Code goes here...</programlisting>
      </sect3>

      <sect3 id="ch02-library-reexport">
        <title>Re-exporting libraries</title>

        <para>You can combine or repackage libraries by re-exporting part or
        all of them. For example, you might have a huge library that you
        implement as a set of smaller libraries. Or you might create a library
        that provides a subset of methods from another library.</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/french.dart, togo.dart, french_togo.dart
</remark><emphasis>// In french.dart:</emphasis>
library french;
hello() =&gt; print('Bonjour!');
goodbye() =&gt; print('Au Revoir!');

<emphasis>// In togo.dart:</emphasis>
library togo;
import 'french.dart';
export 'french.dart' show hello;

<emphasis>// In another .dart file:
</emphasis>import 'togo.dart';

void main() {
  hello();   //print bonjour
  goodbye(); //FAIL
}</programlisting>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="isolates">
    <title>Isolates</title>

    <para>Modern web browsers, even on mobile platforms, run on multi-core
    CPUs. To take advantage of all those cores, developers traditionally use
    shared-memory threads running concurrently. However, shared-state
    concurrency is error prone and can lead to complicated code.</para>

    <para>Instead of threads, all Dart code runs inside of
    <emphasis>isolates</emphasis>. Each isolate has its own memory heap,
    ensuring that no isolate’s state is accessible from any other
    isolate.</para>
  </sect1>

  <sect1 id="typedefs">
    <title>Typedefs</title>

    <para>In Dart, functions are objects, just like strings and numbers are
    objects. A <emphasis>typedef</emphasis>, or <emphasis>function-type
    alias</emphasis>, gives a function type a name that you can use when
    declaring fields and return types. A typedef retains type information when
    a function type is assigned to a variable.</para>

    <para>Consider the following code, which does not use a typedef:</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/sorted_collection.dart
</remark>class SortedCollection {
  Function compare;

  SortedCollection(int f(Object a, Object b)) {
    compare = f;
  }
}

int sort(Object a, Object b) =&gt; ... ; // Initial, broken implementation.

main() {
  SortedCollection collection = new SortedCollection(sort);

  // All we know is that compare is a function, but what type of function?
  assert(collection.compare is Function);
}</programlisting>

    <para>Type information is lost when assigning <literal
    moreinfo="none">f</literal> to <literal moreinfo="none">compare</literal>.
    The type of <literal moreinfo="none">f</literal> is <literal
    moreinfo="none">(Object, </literal><phrase role="keep-together"><literal
    moreinfo="none">Object)</literal> <phrase role="unicode">→</phrase>
    <literal moreinfo="none">int</literal></phrase> (where <phrase
    role="unicode">→</phrase> means returns), yet the type of <literal
    moreinfo="none">compare</literal> is Function. If we change the code to
    use explicit names and retain type information, both developers and tools
    can use that information.</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark><emphasis role="">typedef int Compare(Object a, Object b);</emphasis>

class SortedCollection {
  Compare compare;

  SortedCollection(this.compare);
}

int sort(Object a, Object b) =&gt; ... ; // Initial, broken implementation.

main() {
  SortedCollection collection = new SortedCollection(sort);
  assert(collection.compare is Function);
  assert(collection.compare is Compare);
}</programlisting>

    <note>
      <para>Currently, typedefs are restricted to function types. We expect
      this to change.</para>
    </note>

    <para>Because typedefs are simply aliases, they offer a way to check the
    type of any function. For example:</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>typedef int Compare(int a, int b);

int sort(int a, int b) =&gt; a - b;

main() {
  assert(sort is Compare);  // True!
}</programlisting>
  </sect1>

  <sect1 id="ch02-metadata">
    <title>Metadata</title>

    <para>Use metadata to give additional information about your code. A
    metadata annotation begins with the character <literal>@</literal>,
    followed by either a reference to a compile-time constant (such as
    <literal>deprecated</literal>) or a call to a constant constructor.</para>

    <para>Three annotations are available to all Dart code:
    <literal>@deprecated</literal>, <literal>@override</literal>, and
    <literal>@proxy</literal>. For examples of using
    <literal>@override</literal> and <literal>@proxy</literal>, see <xref
    linkend="ch02-class-extend" />. Here’s an example of using the
    <literal>@deprecated</literal> annotation:</para>

    <programlisting format="linespecific"><remark>lang-dart
ch02/ch02_meta/bin/ch02_meta.dart
</remark>class Television {
  /// _Deprecated: Use [turnOn] instead._
  @deprecated      // Metadata; makes Dart Editor warn about using activate().
  void activate() {
    turnOn();
  }

  /// Turns the TV's power on.
  void turnOn() {
    print('on!');
  }
}</programlisting>

    <para>You can define your own metadata annotations. Here’s an example of
    defining a @todo annotation that takes two arguments:</para>

    <programlisting><remark>lang-dart
</remark><remark>ch02/ch02_meta_create/todo.dart
</remark>library todo;

class todo {
  final String who;
  final String what;
  
  const todo(this.who, this.what);
}</programlisting>

    <para>And here’s an example of using that @todo annotation:</para>

    <programlisting><remark>lang-dart</remark><remark>
ch02/ch02_meta_create/metadata_user.dart
</remark>import 'todo.dart';

@todo('seth', 'make this do something')
void doSomething() {
  print('do something');
}</programlisting>

    <para>Metadata can appear before a library, class, typedef, type
    parameter, constructor, factory, function, field, parameter, or variable
    declaration and before an import or export directive. In the future,
    you’ll be able to retrieve metadata at runtime using reflection.<remark>
    Status: <ulink
    url="https://code.google.com/p/dart/issues/detail?id=6614">issue
    #6614</ulink>.</remark></para>
  </sect1>

  <sect1 id="comments">
    <title>Comments</title>

    <para>Dart supports single-line comments, multi-line comments, and
    documentation <phrase role="keep-together">comments.</phrase></para>

    <sect2 id="ch02-comments-single-line">
      <title>Single-Line Comments</title>

      <para>A single-line comment begins with <literal
      moreinfo="none">//</literal>. Everything between <literal
      moreinfo="none">//</literal> and the end of line is ignored by the Dart
      compiler.</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>main() {
  // TODO: refactor into an AbstractLlamaGreetingFactory?
  print('Welcome to my Llama farm!');
}</programlisting>
    </sect2>

    <sect2 id="ch02-comments-multi-line">
      <title>Multi-Line Comments</title>

      <para>A multi-line comment begins with <literal
      moreinfo="none">/*</literal> and ends with <literal
      moreinfo="none">*/</literal>. Everything between <literal
      moreinfo="none">/*</literal> and <literal moreinfo="none">*/</literal>
      is ignored by the Dart compiler (unless the comment is a documentation
      comment; see the next section). Multi-line comments can nest.</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/multi_line_comments.dart
</remark>main() {
  /*
   * This is a lot of work. Consider raising chickens.

  Llama larry = new Llama();
  larry.feed();
  larry.exercise();
  larry.clean();
   */
}</programlisting>
    </sect2>

    <sect2 id="comments-doc">
      <title>Documentation Comments</title>

      <para>Documentation comments are multi-line or single-line comments that
      begin with <literal moreinfo="none">/**</literal> or <literal
      moreinfo="none">///</literal>. Using <literal
      moreinfo="none">///</literal> on consecutive lines has the same effect
      as a multi-line doc comment.</para>

      <para>Inside a documentation comment, the Dart compiler ignores all text
      unless it is enclosed in brackets. Using brackets, you can refer to
      classes, methods, fields, top-level variables, functions, and
      parameters. The names in brackets are resolved in the lexical scope of
      the documented program element.</para>

      <para>Here is an example of documentation comments with references to
      other classes and arguments:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/doc_comments.dart
</remark>/**
 * A domesticated South American camelid (Lama glama).
 * 
 * Andean cultures have used llamas as meat and pack animals
 * since pre-Hispanic times.
 */
class Llama {
  String name;

  /**
   * Feeds your llama [Food].
   * 
   * The typical llama eats one bale of hay per week.
   */
  void feed(Food food) {
    // ...
  }

  /// Exercises your llama with an [activity] for
  /// [timeLimit] minutes.
  void exercise(Activity activity, int timeLimit) {
    // ...
  }
}</programlisting>

      <para>In the generated documentation, <literal
      moreinfo="none">[Food]</literal> becomes a link to the API docs for the
      Food class.</para>

      <para>To parse Dart code and generate HTML documentation, you can use
      Dart Editor, which in turn uses the SDK’s dartdoc package. For an
      example of generated documentation, see the <ulink
      url="http://api.dartlang.org">Dart API documentation.</ulink> For advice
      on how to structure your comments, see <ulink
      url="http://www.dartlang.org/articles/doc-comment-guidelines/">Guidelines
      for Dart Doc Comments.</ulink></para>
    </sect2>
  </sect1>

  <sect1 id="ch02-summary">
    <title>Summary</title>

    <para>This chapter summarized the commonly used features in the Dart
    language. More features are being implemented<ulink
    url="http://www.dartlang.org/articles/mixins/">,</ulink> but we expect
    that they won’t break existing code. For more information, see the <ulink
    url="http://www.dartlang.org/docs/spec/">Dart Language
    Specification</ulink> and <ulink
    url="http://www.dartlang.org/articles/">articles</ulink> such as <ulink
    url="http://www.dartlang.org/articles/idiomatic-dart/"
    userlevel="">Idiomatic Dart.</ulink></para>
  </sect1>
</chapter>
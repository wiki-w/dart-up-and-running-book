<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="ch03">
  <?dbhtml stop-chunking?>

  <title>Dart 库概览</title>

  <para>本章介绍如何使用 Dart 库中的主要功能。
  这里只是一个概要介绍，并不全面。当你想查看一个类的
  详细信息的时候，请参考 <ulink
  url="http://api.dartlang.org/">Dart API 文档。</ulink></para>

  <sect1 id="ch03-dartcore---strings-collections-and-more">
    <title>dart:core - 数字、集合、 String、以及更多</title>

    <para>Dart 核心库提供了少量关键的功能。
    该库自动导入到每个 Dart 程序中。</para>

    <sect2 id="ch03-numbers">
      <title>Numbers</title>

      <para>dart:core 库定义了 num、 int、 和 double 类，
      这些类提供了一些基本的数字操作功能。</para>

      <para>通过 int 或者 double 的
      <literal>parse()</literal> 函数可以把字符串转化为 int 或者 double：
       </para>

      <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/number-tests.dart
</remark>assert(int.parse('42') == 42);
assert(int.parse('0x42') == 66);
assert(double.parse('0.50') == 0.5);</screen>

      <para>要指定是几进制数，用可选的 <literal>radix</literal>
      参数：</para>

      <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/number-tests.dart
</remark>assert(int.parse('42', radix: 16) == 66);</screen>

      <para>用 <literal>toString()</literal> 函数 (<ulink
      url="http://api.dartlang.org/dart_core/Object.html">Object</ulink> 类定义
      的函数) 可以把 int 或者 double 转化为 string。
      通过 <literal>toStringAsFixed()</literal>
      (num 类定义的函数) 可以指定保留几位小数。
      通过 <phrase
      role="keep-together"><literal>toStringAsPrecision()</literal>
      </phrase>(也是 num 类定义) 可以指定几位有效数字：</para>

      <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/number-tests.dart
</remark>// Convert an int to a string.
assert(42.toString() == '42');

// Convert a double to a string.
assert(123.456.toString() == '123.456');

// Specify the number of digits after the decimal.
assert(123.456.toStringAsFixed(2) == '123.46');

// Specify the number of significant figures.
assert(123.456.toStringAsPrecision(2) == '1.2e+2');
assert(double.parse('1.2e+2') == 120.0);</screen>

      <para>详细信息参考 <ulink
      url="http://api.dartlang.org/dart_core/int.html">int,</ulink> <ulink
      url="http://api.dartlang.org/dart_core/double.html">double,</ulink> 和
      <ulink url="http://api.dartlang.org/dart_core/num.html">num 的 API 文档。</ulink>
      也可以参考下 <xref lang="" linkend="ch03-dart-math" />。</para>
    </sect2>

    <sect2 id="ch03-strings-and-regular-expressions">
      <title>字符串（String）和正则表达式</title>

      <para>Dart 中的字符串是一个不可变的 UTF-16 编码单元（code units） 序列。
          在语言概览中详细介绍了 <link
      linkend="strings">strings</link>。还可以用正则表达式
      (RegExp 对象) 来在字符串内搜索和替换部分
      字符串
      。</para>

      <para>String 类有一些函数：
      <literal>split()</literal>、 <literal>contains()</literal>、
      <literal>startsWith()</literal>、 <phrase
      role="keep-together"><literal>endsWith()</literal></phrase>、 等等。</para>

      <sect3 id="ch03-searching-inside-a-string">
        <title>在字符串内搜索</title>

        <para>你可以查找字符串内匹配字符的开始位置，也可以
            检查字符串是否以某个特定的模式开始和结束。
            例如：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/string-tests.dart
</remark>// 检测一个字符串是否包含另外一个字符串
assert('Never odd or even'.contains('odd'));

// 一个字符串是否以另外一个字符串开始？
assert('Never odd or even'.startsWith('Never'));

// 一个字符串是否以另外一个字符串结束？
assert('Never odd or even'.endsWith('even'));

// 查找一个字符串在另外一个字符串中出现的位置。
assert('Never odd or even'.indexOf('odd') == 6);</screen>
      </sect3>

      <sect3 id="ch03-extracting-data-from-a-string">
        <title>从字符串中提取数据</title>

        <para>可以从字符串中获取每个独立的字符或者 UTF-16 编码单元。
            </para>

        <para>还可以从字符串中截取一个子字符串或者把一个
            字符串分割为一个字符串数组：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/string-tests.dart
</remark>// 截取一个子字符串
assert('Never odd or even'.substring(6, 9) == 'odd');

// 使用一个模式来分割字符串
var parts = 'structured web apps'.split(' ');
assert(parts.length == 3);
assert(parts[0] == 'structured');

// 通过下标索引获取一个字符（String 对象）
assert('Never odd or even'[0] == 'N');

// 使用 空字符串作为参数调用 split() 函数可以获取字符串中的
// 所有单个字符，结果为一个内容为 String 的 list
for (var char in 'hello'.split('')) {
  print(char);
}

// 获取一个字符串所有字符的 UTF-16 编码单元
// 有些字符可能需要用两个编码单元来表达
var codeUnitList = 'Never odd or even'.codeUnits.toList();
assert(codeUnitList[0] == 78);</screen>
      </sect3>

      <sect3 id="ch03-converting-to-uppercase-or-lowercase">
        <title>大小写转换</title>

        <para>字符串大小写转换非常简单：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/string-tests.dart
</remark>// 转换为大小
assert('structured web apps'.toUpperCase() == 'STRUCTURED WEB APPS');

// 转换为小写
assert('STRUCTURED WEB APPS'.toLowerCase() == 'structured web apps');</screen>

        <note>
          <para>注意：上面的函数并不适用于所有的语言。
              例如  ，土耳其语言中的   <emphasis>I</emphasis> 用上面的函数转换会得到错误的结果。</para>
        </note>
      </sect3>

      <sect3 id="ch03-trimming-and-empty-strings">
        <title>删除字符串首尾空白字符和检测空字符串</title>

        <para>用
        <literal>trim()</literal> 函数删除字符串首尾的空白字符。
        用 <literal>isEmpty</literal> 来检测字符串是否为空（长度为 0 ）。</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/string-tests.dart
</remark>// 删除字符串首尾空白字符
assert('  hello  '.trim() == 'hello');

// 检测字符串是否为空
assert(''.isEmpty);

// 只有空白字符的字符串并不为空
assert(!'  '.isEmpty);</screen>
      </sect3>

      <sect3 id="_replacing_part_of_a_string">
        <title>替代部分字符</title>

        <para>String 是不可变对象，所以你只能创建 String 对象而无法修改他们。
            如果你仔细的查看  <ulink
        url="http://api.dartlang.org/dart_core/String.html">String API
        文档</ulink>，你会发现所有的函数都没有修改 String 的状态。例如，
        函数
        <literal>replaceAll()</literal> 返回一个
        新的 String 对象而不是修改原来的对象：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/string-tests.dart
</remark>var greetingTemplate = 'Hello, NAME!';
var greeting = greetingTemplate.replaceAll(new RegExp('NAME'), 'Bob');

assert(greeting != greetingTemplate); // greetingTemplate didn't change.</screen>
      </sect3>

      <sect3 id="_building_a_string">
        <title>创建一个 string</title>

        <para>要在代码中生成一个 string， 你可以用 StringBuffer。
        只有调用 
        <literal>toString()</literal> 函数的时候 StringBuffer 才生成
        String 。</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/string-tests.dart
</remark>var sb = new StringBuffer();

sb..write('Use a StringBuffer ')
  ..writeAll(['for ', 'efficient ', 'string ', 'creation'])
  ..write('.');

var fullString = sb.toString();

assert(fullString ==
    'Use a StringBuffer for efficient string creation.');</screen>
      </sect3>

      <sect3 id="ch03-regular-expressions">
        <title>正则表达式</title>

        <para>RegExp 类提供了 JavaScript 正则表达式的功能。
            用正则表达式搜索字符串和匹配符合某个规则的字符串更加高效。</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/string-tests.dart
</remark>// 匹配一个或者多个数字的规则
var numbers = new RegExp(r'\d+');

var allCharacters = 'llamas live fifteen to twenty years';
var someDigits = 'llamas live 15 to 20 years';

// contains() 可以用正则表达式作为参数
assert(!allCharacters.contains(numbers));
assert(someDigits.contains(numbers));

// 用一个字符串替换所有匹配的字符
var exedOut = someDigits.replaceAll(numbers, 'XX');
assert(exedOut == 'llamas live XX to XX years');</screen>

        <para>你也可以直接操作 RegExp 对象。
            Match 类提供了访问匹配一个表达式的结果：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/string-tests.dart
</remark>var numbers = new RegExp(r'\d+');
var someDigits = 'llamas live 15 to 20 years';

// 检测字符串中是否有匹配的项
assert(numbers.hasMatch(someDigits));

// 遍历所有匹配的项
for (var match in numbers.allMatches(someDigits)) {
  print(match.group(0)); // 15, then 20
}</screen>
      </sect3>

      <sect3 id="ch03-more-information-8">
        <title>更多信息</title>

        <para>参考  <ulink
        url="http://api.dartlang.org/dart_core/String.html">String API
        文档</ulink> 来查看 String 的所有函数。同时参考
        <ulink
        url="http://api.dartlang.org/dart_core/StringBuffer.html">StringBuffer,</ulink>
        <ulink
        url="http://api.dartlang.org/dart_core/Pattern.html">Pattern,</ulink>
        <ulink
        url="http://api.dartlang.org/dart_core/RegExp.html">RegExp,</ulink>
        and <ulink
        url="http://api.dartlang.org/dart_core/Match.html">Match</ulink> 类的 API 文档来了解这些类的更多功能。</para>
      </sect3>
    </sect2>

    <sect2 id="ch03-collections">
      <title>集合</title>

      <para>Dart 包含了一个核心的集合 API，这些 API 包含
      lists、 sets、和  maps。</para>

      <sect3 id="ch03-lists">
        <title>Lists</title>

        <para>在语言概览中已经介绍过用 字符字面量来创建 <link linkend="lists">lists</link> 的方法。
            另外也可以用 List 的构造函数。 List 还定义了一些函数可以添加或者删除 List 中的内容。
        </para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/list-tests.dart
</remark>// 使用 List 构造函数
var vegetables = new List();

// 使用 list 字符字面量 创建 List
var fruits = ['apples', 'oranges'];

// 添加到 list 中
fruits.add('kiwis');

// 一次添加多个项到 list 中
fruits.addAll(['grapes', 'bananas']);

// 查询 list 的长度
assert(fruits.length == 5);

// 删除一个项
var appleIndex = fruits.indexOf('apples');
fruits.removeAt(appleIndex);
assert(fruits.length == 4);

// 删除 list 中的所有项
fruits.clear();
assert(fruits.length == 0);</screen>

        <para>用 <literal>indexOf()</literal> 函数来查找 list 中
            某个位置的对象：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/list-tests.dart
</remark>var fruits = ['apples', 'oranges'];

// 通过索引访问 list 中的对象
assert(fruits[0] == 'apples');

// 查找 list 中是否包含该对象
assert(fruits.indexOf('apples') == 0);</screen>

        <para>用 <literal>sort()</literal> 函数可以排序 list 中的内容。
            该函数的参数为一个用来比较两个对象的方法。该方法的返回值需要满足如下要求：
            比较的结果为 <emphasis>小于</emphasis>的话，则返回值必需  &lt; 0，
            如果<emphasis>相等</emphasis>的话，则必需返回 0，如果结果为
            <emphasis>大于</emphasis>的话，则返回值必需为  &gt; 0 。
           下面的示例使用了  <ulink
        url="http://api.dartlang.org/dart_core/Comparable.html">Comparable</ulink>
        接口定义的函数 <literal>compareTo()</literal>， String 类实现了该函数。</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/list-tests.dart
</remark>var fruits = ['bananas', 'apples', 'oranges'];

// 排序 list 中的对象
fruits.sort((a, b) =&gt; a.compareTo(b));
assert(fruits[0] == 'apples');</screen>

        <para>List 支持泛型，所以你可以设置一个 List 中对象的类型：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/list-tests.dart
</remark>// 这个 list 应该只包含 String 对象
var fruits = new List&lt;String&gt;();

fruits.add('apples');
var fruit = fruits[0];
assert(fruit is String);

// 将有一个静态分析警告， num 不是一个 String
fruits.add(5);  // BAD: 在检测模式（Checked mode）下会抛出异常。</screen>

        <para>参考 <ulink
        url="http://api.dartlang.org/dart_core/List.html">List API
        文档</ulink> 来了解 List 对象的所有函数，</para>
      </sect3>

      <sect3 id="ch03-sets">
        <title>Sets</title>

        <para>Dart 中的 Set 是包含唯一对象的无序集合。
            由于 set 中的对象都是没有顺序的，所以无法用位置索引来
            访问里面的对象。</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/set-tests.dart
</remark>var ingredients = new Set();
ingredients.addAll(['gold', 'titanium', 'xenon']);
assert(ingredients.length == 3);

// 添加一个重复的对象不起作用
ingredients.add('gold');
assert(ingredients.length == 3);

// 从 set 中删除一个对象
ingredients.remove('gold');
assert(ingredients.length == 2);</screen>

        <para>用 <literal>contains()</literal> 和
        <literal>containsAll()</literal> 来检测 set 中是否包含一个或者多个对象：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/set-tests.dart
</remark>var ingredients = new Set();
ingredients.addAll(['gold', 'titanium', 'xenon']);

// 检测一个对象是否在 set 中
assert(ingredients.contains('titanium'));

// 检测是否 set 包含多个对象
assert(ingredients.containsAll(['titanium', 'xenon']));</screen>

        <para>交集是两个 set 中都包含的对象集合。</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/set-tests.dart
</remark>var ingredients = new Set();
ingredients.addAll(['gold', 'titanium', 'xenon']);

// 创建两个 set 的交集
var nobleGases = new Set.from(['xenon', 'argon']);
var intersection = ingredients.intersection(nobleGases);
assert(intersection.length == 1);
assert(intersection.contains('xenon'));</screen>

        <para>参考 <ulink
        url="http://api.dartlang.org/dart_core/Set.html">Set API 文档</ulink>
        了解 set 的更多功能。</para>
      </sect3>

      <sect3 id="ch03-maps-aka-dictionaries-or-hashes">
        <title>Maps</title>

        <para>map 通常被称之为 <emphasis>dictionary</emphasis> 或者
        <emphasis>hash</emphasis>， map 是一个无序的 key-value（键-值） 对。
        map 中每个值都有一个对应的键便于访问。和 JavaScript 不同， Dart 对象不是 map。
        </para>

        <para><phrase role="keep-together">
            可以通过字符字面量定义 map 也可以通过 map 构造函数来定义 map：
        </phrase></para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/map-1.dart
</remark>// map 通常都是用 String 做为 key
var hawaiianBeaches = {
  'oahu'       : ['waikiki', 'kailua', 'waimanalo'],
  'big island' : ['wailea bay', 'pololu beach'],
  'kauai'      : ['hanalei', 'poipu']
};

// 用构造函数创建 map
var searchTerms = new Map();

// map 支持泛型，所以可以指定 map 的 key 和 value 的类型：
var nobleGases = new Map&lt;int, String&gt;();</screen>

        <para>使用方括号来添加、设置和访问 map 中的值。用
        <literal>remove()</literal> 函数从 map 中删除
        对应的 key 和 value。<remark> [注意 下面的示例中使用了 尚未见到过的 containsKey 函数]</remark></para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/map-1.dart
</remark>var nobleGases = { 54: 'xenon' };

// 通过 key 获取对应的 value
assert(nobleGases[54] == 'xenon');

// 检测 map 中是否包含一个 key
assert(nobleGases.containsKey(54));

// 删除一个 key 和对应的 value
nobleGases.remove(54);
assert(!nobleGases.containsKey(54));</screen>

        <para>可以获取 map 的所有 key 或者所有 value：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/map-1.dart
</remark>var hawaiianBeaches = {
  'oahu' : ['waikiki', 'kailua', 'waimanalo'],
  'big island' : ['wailea bay', 'pololu beach'],
  'kauai' : ['hanalei', 'poipu']
};

// 获取所有的 key，结果为一个无序集合 ( 一个 Iterable).
var keys = hawaiianBeaches.keys;

assert(keys.length == 3);
assert(new Set.from(keys).contains('oahu'));

// 获取 map 所有 value 的集合 (an Iterable of Iterables).
var values = hawaiianBeaches.values;
assert(values.length == 3);
assert(values.any((v) =&gt; v.indexOf('waikiki') != -1));</screen>

        <para>用
        <literal>containsKey()</literal> 函数检测
        map 中是否包含一个 key。由于 map 的 value 可以为 null，
        所以你不能通过判断 key 来判断是否包含一个 value。
        </para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/map-1.dart
</remark>var hawaiianBeaches = {
  'oahu' : ['waikiki', 'kailua', 'waimanalo'],
  'big island' : ['wailea bay', 'pololu beach'],
  'kauai' : ['hanalei', 'poipu']
};

assert(hawaiianBeaches.containsKey('oahu'));
assert(!hawaiianBeaches.containsKey('florida'));</screen>

        <para>如果你想在 key 不存在的时候
            才设置该值，则可以用  <literal>putIfAbsent()</literal> 函数。该函数
            的参数为返回设置的值的方法：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/map-1.dart
</remark>var teamAssignments = {};
teamAssignments.putIfAbsent('Catcher', () =&gt; pickToughestKid());
assert(teamAssignments['Catcher'] != null);</screen>

        <para>参考 <ulink
        url="http://api.dartlang.org/dart_core/Map.html">Map API 文档</ulink>
        查看 Map 的所有函数。</para>
      </sect3>

      <sect3 id="ch03-common-collection-methods">
        <title>常用的集合方法</title>

        <para>List、 Set、 和 Map 公用一些常用的
            集合操作。有些函数定义在 Iterable 类中， List 和 Set 实现了该类。</para>

        <note>
          <para>虽然  Map 没有实现 Iterable，但是通过 Map 的
              <literal>keys</literal> 和
          <literal>values</literal> 属性可以得到一个 Iterable 对象。 </para>
        </note>

        <para>用 <literal>isEmpty</literal> 函数来检查
            集合是否为空：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/collection-isEmpty.dart
</remark>var teas = ['green', 'black', 'chamomile', 'earl grey'];
assert(!teas.isEmpty);</screen>

        <para>要在 list、 set、 或者 map 中的每个元素上使用一个方法，则可以用
         <literal>forEach()</literal> 函数：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/collection-apply-function.dart
</remark>var teas = ['green', 'black', 'chamomile', 'earl grey'];

teas.forEach((tea) =&gt; print('I drink $tea'));</screen>

        <para>当调用 Map 的 <literal>forEach()</literal> 函数的时候，
            方法参数必须有两个参数（分别为 key 和 value）：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/map-1.dart
</remark>// 注意：遍历集合是无序的
hawaiianBeaches.forEach((k,v) {
  print('I want to visit $k and swim at $v');
  // I want to visit oahu and swim at [waikiki, kailua, waimanalo], etc.
});</screen>

        <para>还有一个用来遍历集合的方法：<literal>map()</literal>
        ，该函数把所有的结果放到一个对象中：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/collection-apply-function.dart
</remark>var teas = ['green', 'black', 'chamomile', 'earl grey'];

var loudTeas = teas.map((tea) =&gt; tea.toUpperCase());
loudTeas.forEach(print);</screen>

        <note>
          <para>注意： <literal>map()</literal> 函数返回的 Iterable 对象是
           <emphasis>lazily evaluated（懒惰加载的）</emphasis>：
           只有当你使用返回对象的时候，你的方法才被调用。</para>
        </note>

        <para>要强制立刻在每个对象上调用你的方法，则可以用 <literal>map().toList()</literal> 
或者
        <literal>map().toSet()</literal> 函数：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/collection-apply-function.dart
</remark>var loudTeaList = teas.map((tea) =&gt; tea.toUpperCase()).toList();</screen>

        <para>Iterable 的 <literal>where()</literal> 函数用户过滤集合中的对象，
            返回符合条件的所有对象。
            Iterable 的 <literal>any()</literal>
        和 <literal>every()</literal> 函数用来检查是否一些对象或者所有对象都满足
        一个条件。</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/collection-any-every.dart
</remark>var teas = ['green', 'black', 'chamomile', 'earl grey'];

// Chamomile is not caffeinated.
bool isDecaffeinated(String teaName) =&gt; teaName == 'chamomile';

// Use where() to find only the items that return true
// from the provided function.
var decaffeinatedTeas = teas.where((tea) =&gt; isDecaffeinated(tea));
// or teas.where(isDecaffeinated)

// Use any() to check whether at least one item in the collection
// satisfies a condition.
assert(teas.any(isDecaffeinated));

// Use every() to check whether all the items in a collection
// satisfy a condition.
assert(!teas.every(isDecaffeinated));</screen>

        <para>参考 <ulink
        url="http://api.dartlang.org/dart_core/Iterable.html">Iterable API
        文档</ulink> 和 List、 Set、 以及 Map 的文档来了解集合的所有函数。</para>
      </sect3>
    </sect2>

    <sect2 id="ch03-uri">
      <title>URIs</title>

      <para><ulink url="http://api.dartlang.org/dart_core/Uri.html">Uri
      类</ulink> 提供了用来编码和解码 URI 字符串的函数。
      这些函数处理 URI 中的特殊字符，例如 <literal
      moreinfo="none">&amp;</literal> 和 <literal
      moreinfo="none">=</literal>。 Uri 类还提供了获取 URI 组件的函数，
      例如 URI 的 主机地址、端口号、协议 等等。
      </para>

      <sect3 id="ch03-uri-fully-qualified">
        <title>编码和解码完整的 URI</title>

        <para>使用 <literal>encodeFull()</literal>
        和 <literal>decodeFull()</literal> 函数来编码和解码
        <emphasis>除了</emphasis> 特殊字符的 URI（例如这些特殊字符：<literal
        moreinfo="none">/</literal>, <literal moreinfo="none">:</literal>,
        <literal moreinfo="none">&amp;</literal>, <literal
        moreinfo="none">#</literal>）。
        这些函数<phrase
        role="keep-together">特别擅长</phrase> 
        用来编码和解码一个完整的 URI，保留 <phrase
        role="keep-together">特殊的 URI 字符。</phrase></para>

        <screen format="linespecific"><remark>lang-dart
code/ch03/encodeUri.dart
</remark>main() {
  var uri = 'http://example.org/api?foo=some message';
  var encoded = Uri.encodeFull(uri);
  assert(encoded == 'http://example.org/api?foo=some%20message');

  var decoded = Uri.decodeFull(encoded);
  assert(uri == decoded);
}</screen>

        <para>注意，上面的代码中，只有位于 <literal
        moreinfo="none">some</literal> 和 <literal
        moreinfo="none">message</literal> 之间的空格给编码了。</para>
      </sect3>

      <sect3 id="ch03-uri-components">
        <title>编码和解码 URI 组件</title>

        <para>使用<literal>encodeComponent()</literal> 和
        <literal>decodeComponent()</literal> 函数来编码和解码 URI 组件，
        URI 组件中的特殊字符（例如 <literal
        moreinfo="none">/</literal>, <literal moreinfo="none">&amp;</literal>,
        and <literal moreinfo="none">:</literal>）会被
        正确的编码。
        <screen format="linespecific"><remark>lang-dart
code/ch03/encodeUriComponents.dart
</remark>main() {
  var uri = 'http://example.org/api?foo=some message';
  var encoded = Uri.encodeComponent(uri);
  assert(encoded == 'http%3A%2F%2Fexample.org%2Fapi%3Ffoo%3Dsome%20message');

  var decoded = Uri.decodeComponent(encoded);
  assert(uri == decoded);
}</screen>

        <para>注意上面特殊的字符是如何编码的。例如
        <literal moreinfo="none">/</literal> 被编码为 <literal
        moreinfo="none">%2F</literal>。</para>
      </sect3>

      <sect3 id="ch03-uri-parsing">
        <title>解析 URI</title>

        <para>如果你有一个 Uri 对象或者一个 URI 字符串，使用 Uri 的变量可以
            获取 Uri 的组成部分，例如 <literal>path（路径）</literal>。
            使用 <literal>parse()</literal> 静态函数把 URI 字符串解析为 Uri 对象。</para>

        <screen format="linespecific"><remark>lang-dart
code/ch03/parseUri.dart
</remark>main() {
  var uri = Uri.parse('http://example.org:8080/foo/bar#frag');

  assert(uri.scheme   == 'http');
  assert(uri.host     == 'example.org');
  assert(uri.path     == '/foo/bar');
  assert(uri.fragment == 'frag');
  assert(uri.origin   == 'http://example.org:8080');
}</screen>

        <para>参考 <ulink
        url="http://api.dartlang.org/dart_core/Uri.html">Uri API 文档</ulink>
       了解 Uri 的所有函数。</para>
      </sect3>

      <sect3 id="ch03-uri-building">
        <title>创建 URI</title>

        <para>可以用
        <literal>Uri()</literal> <phrase role="keep-together"
        security="">构造函数</phrase>来创建一个 URI：</para>

        <programlisting role="keep-together"><remark>lang-dart
code/ch03/uriFromComponents.dart
</remark>main() {
  var uri = new Uri(scheme: 'http', host: 'example.org', 
                    path: '/foo/bar', fragment: 'frag');
  assert(uri.toString() == 'http://example.org/foo/bar#frag');
}</programlisting>
      </sect3>
    </sect2>

    <sect2 id="ch03-dates-and-times">
      <title>日期和时间</title>

      <para>DateTime 对象代表某个时间。时区不是 UTC 就是 本地时区。</para>

      <para>可以用如下构造函数创建 DateTime 对象：</para>

      <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/date.dart
</remark>// 获取当前的日期和时间
var now = new DateTime.now();

// 使用本地时区创建一个 DateTime 对象
var y2k = new DateTime(2000);   // January 1, 2000

// 设置年月日
y2k = new DateTime(2000, 1, 2); // January 2, 2000

// 创建一个 UTC 时间
y2k = new DateTime.utc(2000);   // January 1, 2000, UTC

// 用从 Unix epoch 开始的毫秒数来设置时间
y2k = new DateTime.fromMillisecondsSinceEpoch(946684800000, isUtc: true);

// 解析 ISO 8601 格式日期
y2k = DateTime.parse('2000-01-01T00:00:00Z');</screen>

      <para> <literal moreinfo="none">millisecondsSinceEpoch</literal>
      的值为 从 “Unix
      epoch”—1970年1月1号 UTC 时区 开始的毫秒数值：</para>

      <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/date.dart
</remark>var y2k = new DateTime.utc(2000);           // 1/1/2000, UTC
assert(y2k.millisecondsSinceEpoch == 946684800000);
var unixEpoch = new DateTime.utc(1970); // 1/1/1970, UTC
assert(unixEpoch.millisecondsSinceEpoch == 0);</screen>

      <para>用 Duration 类来计算两个日期之间的间隔，或者在当前时间上加减时间：</para>

      <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/date.dart
</remark>var y2k = new DateTime.utc(2000);

// 在当前时间上加一年
var y2001 = y2k.add(const Duration(days: 366));
assert(y2001.year == 2001);

// 减去30天
var december2000 = y2001.subtract(const Duration(days: 30));
assert(december2000.year == 2000);
assert(december2000.month == 12);

// 计算两个日期之间的间隔
// 返回一个 Duration 对象
var duration = y2001.difference(y2k);
assert(duration.inDays == 366); // y2k 是闰年</screen>

      <para>参考  <ulink
      url="http://api.dartlang.org/dart_core/DateTime.html">DateTime</ulink>
      和 <ulink
      url="http://api.dartlang.org/dart_core/Duration.html">Duration</ulink>
      的 API 文档来了解这些类的所有函数。</para>
    </sect2>

    <sect2 id="ch03-utility-interfaces">
      <title>常用工具类</title>

      <para>核心库还包含用来拍下、map 的 key 和遍历对象的各种工具类。</para>

      <sect3 id="ch03-comparing-objects">
        <title>比较对象</title>

        <para>实现 <ulink
        url="http://api.dartlang.org/dart_core/Comparable.html">Comparable</ulink>
        接口的对象可以和另外一个对象比较，通常用来排序。 <literal>compareTo()</literal> 函数
        的返回结果如下：<emphasis>小于</emphasis> 的返回值为 &lt; 0；<emphasis>相等</emphasis>
        的返回值为 0；<emphasis>大于</emphasis> 的返回值为 &gt; 0。</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/comparable.dart
</remark>class Line implements Comparable {
  final length;
  const Line(this.length);
  int compareTo(Line other) =&gt; length - other.length;
}

main() {
  var short = const Line(1);
  var long = const Line(100);
  assert(short.compareTo(long) &lt; 0);
}</screen>
      </sect3>

      <sect3 id="ch03-implementing-map-keys">
        <title>实现 map 的 key</title>

        <para>Dart 中的每个对象都自动带有一个整数的 哈希值，所有可以用作 map 中的 key。
            你还可以重写（override）
        <literal>hashCode</literal> getter 函数来生成一个自定义
        的哈希值。如果你自定义了哈希值，记得同时还要重写 <literal moreinfo="none">==</literal>
        操作符。相等的对象 (用 <literal
        moreinfo="none">==</literal> 来比较) 必须具有同样的哈希值。
        一个哈希值不一定是唯一的，但是应该具有合理的分布。</para>

        <remark>注意： 在 == 实现中包含 identical() 是有争议的。虽然这样可以
            提高速度。但是通常 NaN != NaN ，所以 对象默认并不是 identical() 的。</remark>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/map-keys.dart
</remark>class Person {
  String firstName, lastName;

  Person(this.firstName, this.lastName);

  // 使用 Effective Java 第 11 章 中的方法来重写 hashCode 函数
  int get hashCode {
    int result = 17;
    result = 37 * result + firstName.hashCode;
    result = 37 * result + lastName.hashCode;
    return result;
  }

  // 如果重写了 hashCode 则需要同时重写 operator== 
  bool operator==(other) {
    if (identical(other, this)) return true;
    return (other.firstName == firstName &amp;&amp; other.lastName == lastName);
  }
}

main() {
  var p1 = new Person('bob', 'smith');
  var p2 = new Person('bob', 'smith');
  assert(p1.hashCode == p2.hashCode);
}</screen>
      </sect3>

      <sect3 id="ch03-iteration">
        <title>Iteration（遍历）</title>

        <para> <ulink
        url="http://api.dartlang.org/dart_core/Iterable.html">Iterable</ulink>
        和 <ulink
        url="http://api.dartlang.org/dart_core/Iterator.html">Iterator</ulink>
        类支持 for-in 循环。
        如果你创建的对象需要支持 for-in 循环，则可以继承（Extends）或者实现（Implements） Iterable 接口。
        实现 Iterator 来定义遍历的功能。</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/iterator.dart
</remark>class Process {
  // Represents a process...
}

class ProcessIterator implements Iterator&lt;Process&gt; {
  Process current;
  bool moveNext() {
    return false;
  }
}

// 一个可以遍历所有 Process 的虚构类
// 继承 Iterable 类。
class Processes extends DoubleLinkedQueue&lt;Process&gt; {
  final Iterator&lt;Process&gt; iterator = new ProcessIterator();
}

main() {
  // Iterable 对象可以在 for-in 循环中使用
  for (var process in new Processes()) {
    // Do something with the process.
  }
}</screen>
      </sect3>
    </sect2>

    <sect2 id="ch03-exceptions">
      <title>异常（Exceptions）</title>

      <para>Dart 核心库定义了很多常用的异常（exception）和错误（error）。
          异常是一些你可以提前预料和处理的错误情况。而错误则是你没有料到或者没有处理的情况。</para>

      <para>一些常见的错误如下：</para>

      <variablelist>
        <varlistentry>
          <term><ulink
          url="http://api.dartlang.org/dart_core/NoSuchMethodError.html">NoSuchMethodError</ulink></term>

          <listitem>
            <para>当一个对象(可能为 null) 没有实现一个
            <phrase
            role="keep-together">被调用的函数</phrase> 时抛出该错误。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><ulink
          url="http://api.dartlang.org/dart_core/ArgumentError.html">ArgumentError</ulink></term>

          <listitem>
            <para>当用错误的参数调用一个函数的时候，由该函数抛出。</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>抛出一个应用相关的异常是表明发生错误的常见做法。
          你可以通过实现 Exception  <phrase
      role="keep-together">接口</phrase> 来定义自己的异常：</para>

      <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/exceptions.dart
</remark>class FooException implements Exception {
  final String msg;
  const FooException([this.msg]);
  String toString() =&gt; msg == null ? 'FooException' : msg;
}</screen>

      <para>更多信息请参考 <xref linkend="exceptions" /> 和
      <ulink url="http://api.dartlang.org/dart_core/Exception.html">Exception
      API 文档.</ulink></para>
    </sect2>
  </sect1>

  <sect1 id="ch03-asynchronous-programming">
    <title>dart:async - 异步编程</title>

    <para>异步编程通常使用回调函数，而 Dart 
        提供了另外一种选择：<ulink
    url="http://api.dartlang.org/dart_async/Future.html">Future</ulink> 和
    <ulink url="http://api.dartlang.org/dart_async/Stream.html">Stream</ulink>
    对象。一个 Future 对象保证在未来的某个时间返回一个结果。
    Stream 对象是获取一系列值的方法，例如 输入事件序列。
     <ulink
    url="http://api.dartlang.org/dart_async.html">dart:async</ulink>
    库提供了 Future、 Stream、和其他更多异步编程支持。</para>

    <para>在命令行应用和 web 应用中都可以使用 dart:async 库。
    要使用该库，只需要导入 dart:async：</para>

    <screen format="linespecific"><remark>lang-dart</remark><remark>
</remark>import 'dart:async';</screen>

    <sect2 id="ch03-futures">
      <title>Future</title>

      <para>在 Dart 库中到处都可以看到 Future 对象，
          通常都是作为异步函数的返回值出现。
      当一个 future
      <emphasis>完成的时候</emphasis>，返回的值就可以使用了。</para>

      <sect3 id="ch03-future-example">
        <title>基础用法</title>

        <para><phrase role="keep-together">使用 <literal>then()</literal>
            来设置当 future 完成时执行的代码。
            例如，由于 HTTP 请求可以消耗一些时间，所以
        <literal>HttpRequest.getString()</literal> 返回一个 Future。
       使用 <literal>then()</literal> 你可以在 Future 完成的时候来执行一些代码：
        </phrase></para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/ch03_4_async/web/ch03_4_async.dart
</remark>HttpRequest.getString(url)
  .then((String result) {
    print(result); });
  // 在这里处理错误情况</screen>

        <para>用 <literal>catchError()</literal> 来处理 Future 对象
            抛出的异常。
            注意：要在 <literal>then()</literal> 函数的返回值对象上调用
        <literal>catchError()</literal> 才能处理 Future 的异常；
        如果在 原来的 Future 对象上调用 <literal>catchError()</literal> 则不能处理 Future 抛出
        的异常。
        <remark>{待定：当你调用错了的时候会发生何种现象？}</remark></para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/ch03_4_async/web/ch03_4_async.dart
</remark>HttpRequest.getString(url)
  .then((String result) {  // 回调函数
    print(result); })
  .catchError((e) {
    // 处理或者忽略错误情况
  });</screen>

        <para>这里的 <literal>then().catchError()</literal> 模式是
            异步版本的
        <literal>try</literal>-<literal>catch</literal> 模式。</para>
      </sect3>

      <sect3 id="ch03-chaining-multiple-async-methods">
        <title>串联多个异步函数</title>

        <para>由于 <literal>then()</literal> 函数返回一个 Future ，
            所以提供了一种按照顺序执行多个异步方法的方式。
            如果 <literal>then()</literal> 的回调函数返回一个 Future，
            则 <literal>then()</literal> 直接返回该对象。
            如果回调函数返回其他类型的值，则 返回一个新的 Future 对象，该 Future 对象完成时候
            返回回调函数返回的值。
        </para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/futures.dart
</remark>Future result = costlyQuery();

return result.then((value) =&gt; expensiveWork())
             .then((value) =&gt; lengthyComputation())
             .then((value) =&gt; print('done!'))
             .catchError((exception) =&gt; print('DOH!'));</screen>

        <para>上面的示例代码中，按照如下顺序执行：</para>

        <orderedlist continuation="restarts" inheritnum="ignore"
                     numeration="arabic">
          <listitem>
            <para><literal>costlyQuery()</literal></para>
          </listitem>

          <listitem>
            <para><literal>expensiveWork()</literal></para>
          </listitem>

          <listitem>
            <para><literal>lengthyComputation()</literal></para>
          </listitem>
        </orderedlist>
      </sect3>

      <sect3 id="ch03-waiting-for-multiple-futures">
        <title>等待多个 Futures 完成</title>

        <para>有时，你的算法要求调用多个异步
            方法并且等待所有的方法都完成。使用
        <ulink
        url="http://api.dartlang.org/dart_async/Future.html#wait"><literal>Future.wait()</literal></ulink>
        静态函数来管理多个 Future 并等待所有 Future 一起完成：</para>

        <screen format="linespecific"><remark>lang-dart
<remark>ch03/futures.dart</remark>
</remark>Future deleteDone = deleteLotsOfFiles();
Future copyDone = copyLotsOfFiles();
Future checksumDone = checksumLotsOfOtherFiles();

Future.wait([deleteDone, copyDone, checksumDone]).then((List values) {
  print('Done with all the long steps');
});</screen>
      </sect3>
    </sect2>

    <sect2 id="ch03-streams">
      <title>Stream</title>

      <para>Stream 对象代表数据序列，也经常在 Dart API 中出现。
          例如， HTML 的按钮点击事件就是用 stream 来传输的。
          你也可以用 stream 来读取文件。</para>

      <sect3 id="ch03-streams-listen">
        <title>监听 Stream 数据流</title>

        <para>要获取每个 Stream 中的数据，则可以用 <code>listen()</code> 函数：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>// 通过 ID 查找按钮并注册事件
querySelector('#submitInfo').onClick.listen((e) {
  // 当按钮点击的时候，执行下面代码
  submitData();
});</screen>

        <para>上面的例子中，'submitInfo' 按钮的 <literal>onClick</literal> 
           属性为一个 Stream 对象。</para>

        <para>如果你只关心第一个事件，则可以用 <literal>first</literal>、
             <literal>last</literal> 或者
        <literal>single</literal> 属性。
        用 <literal>firstWhere()</literal>、
        <literal>lastWhere()</literal>、或者 <literal>singleWhere()</literal>
        函数在处理数据之前测试事件发生的位置。
        <remark>{待定：示例。}</remark></para>

        <para>如果你关心一段数据，则可以用
         <literal>skip()</literal>、 <literal>skipWhile()</literal>、
        <literal>take()</literal>、 <literal>takeWhile()</literal>、 和
        <literal>where()</literal> 函数。 <remark>{PENDING: example}</remark></para>
      </sect3>

      <sect3 id="ch03-streams-transform">
        <title>转换 Stream 数据</title>

        <para>通常，在使用 Stream 数据之前都需要先转换为可用形式。
             用 <literal>transform()</literal> 函数来把 Stream 数据转换为其他
             形式：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/readFile.dart
</remark>var config = new File('config.txt');
Stream&lt;List&lt;int&gt;&gt; inputStream = config.openRead();

inputStream
  .transform(UTF8.decoder)
  .transform(new LineSplitter())
  .listen(
    (String line) {...} ...);</screen>

        <para>这里用了两个转换器。 第一个转换器 UTF8.decoder
        把 <literal>Stream&lt;List&lt;int&gt;&gt;</literal> 转换为
        一个 <literal>Stream&lt;String&gt;</literal>。然后用
       一个 LineSplitter
        把 <literal>Stream&lt;String&gt;</literal> 转换为 
        <literal>Stream&lt;List&lt;String&gt;&gt;</literal> 对象。
    这些转换器来自于 dart:convert 库。        
(参考 <xref
        linkend="ch03-dart-convert" />)。<remark> PENDING: add onDone and
        onError. (See "Streaming file contents".)</remark></para>
      </sect3>
    </sect2>

    <sect2 id="ch03-more-information-9">
      <title>更多信息</title>

      <para>在命令行应用中使用 Future 和 Stream 的例子请参考
        <xref
      linkend="ch03-dartio---file-and-socket-io-for-command-line-apps" />。
      下面还有一些可以参考的文章：</para>

      <itemizedlist>
        <listitem>
          <para><ulink
          url="http://www.dartlang.cc/articles/using-future-based-apis/">使用
          Future APIs</ulink></para>
        </listitem>

        <listitem>
          <para><ulink
          url="http://www.dartlang.cc/articles/futures-and-error-handling/">Futures
          和 错误处理</ulink></para>
        </listitem>

        <listitem>
          <para><ulink url="http://www.dartlang.cc/articles/event-loop/">Dart
              中的事件循环</ulink></para>
        </listitem>

        <listitem>
          <para><ulink
          url="http://www.dartlang.cc/articles/feet-wet-streams/">使用
          Stream </ulink></para>
        </listitem>

        <listitem>
          <para><ulink
          url="http://www.dartlang.cc/articles/creating-streams/">
          在 Dart 中创建 Stream</ulink></para>
        </listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="ch03-dart-math">
    <title>dart:math - Math 和 Random</title>

    <para>Math 库提供了数学运算的常用公式，例如  sine 和
    cosine、 最大值和最小值、另外还有一些常量 <emphasis>pi</emphasis>
    和 <emphasis>e</emphasis> 等。
    Math 库中的大部分方法都是顶级方法。</para>

    <para>在代码中 import dart:math 即可使用 Math 库。
        下面的示例中，使用前缀 <literal moreinfo="none">math</literal> 来表明
        使用了 Math 库中的顶级函数和常量，这样使代码看起来
        更加清晰：</para>

    <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/math-tests.dart
</remark>import 'dart:math' as math;</screen>

    <sect2 id="ch03-trigonometry">
      <title>三角函数</title>

      <para>Math 库提供了常用的三角函数：</para>

      <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/math-tests.dart
</remark>// Cosine
assert(math.cos(math.PI) == -1.0);

// Sine
var degrees = 30;
var radians = degrees * (math.PI / 180);
// radians is now 0.52359.
var sinOf30degrees = math.sin(radians);

// Truncate the decimal places to 2.
assert(double.parse(sinOf30degrees.toStringAsPrecision(2)) == 0.5);</screen>

      <note>
        <para>这些函数的参数为弧度不是角度！</para>
      </note>
    </sect2>

    <sect2 id="ch03-maximum-and-minimum">
      <title>最大值和最小值</title>

      <para>Math 库还提供了优化过的 <literal>max()</literal> 和
      <literal>min()</literal> 函数：</para>

      <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/math-tests.dart
</remark>assert(math.max(1, 1000) == 1000);
assert(math.min(1, -1000) == -1000);</screen>
    </sect2>

    <sect2 id="ch03-math-constants">
      <title>数学常量</title>

      <para>Math 库提供了很多常量，例如 <emphasis>pi</emphasis>、
      <emphasis>e</emphasis> 等：</para>

      <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/math-tests.dart
</remark>// See the Math library for additional constants.
print(math.E);     // 2.718281828459045
print(math.PI);    // 3.141592653589793
print(math.SQRT2); // 1.4142135623730951</screen>
    </sect2>

    <sect2 id="ch03-random-numbers">
      <title>随机数</title>

      <para>用 <ulink
      url="http://api.dartlang.org/dart_math/Random.html">Random</ulink>
      类来生成随机数。
      还可以用一个种子来构造一个 Random 对象。</para>

      <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/math-tests.dart
</remark>var random = new math.Random();
random.nextDouble(); // 返回值在 0.0 和 1.0 之间： [0, 1)
random.nextInt(10);  // 返回值在 0 和 9 之间</screen>

      <para>甚至还可以生成一个随机布尔值：</para>

      <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/math-tests.dart
</remark>var random = new math.Random();
random.nextBool();  // true or false</screen>
    </sect2>

    <sect2 id="ch03-more-information-7">
      <title>更多信息</title>

      <para>参考 <ulink
      url="http://api.dartlang.org/dart_math/index.html">Math API 文档</ulink>
      以及 <phrase
      role="keep-together"> <ulink
      url="http://api.dartlang.org/dart_core/num.html">num、</ulink></phrase>
      <ulink url="http://api.dartlang.org/dart_core/int.html">int、</ulink> 和
      <ulink
      url="http://api.dartlang.org/dart_core/double.html">double</ulink> 来 查看所有的函数。</para>
    </sect2>
  </sect1>

  <sect1 id="ch03-dart-html-using-html5-apis">
    <title>dart:html - 基于浏览器的应用</title>

    <para>使用 <ulink
    url="http://api.dartlang.org/dart_html.html">dart:html 库</ulink> 
    来编写浏览器应用，该库提供了操作 DOM 元素和访问 HTML5 API 的功能。 <firstterm>DOM</firstterm> 
    是
    <emphasis>Document Object Model</emphasis> 的缩写，DOM 描述了
    HTML 页面的文档结构。</para>

    <para>使用 dart:html 库还可以用来操作
    (<emphasis>CSS</emphasis>)、用 HTTP 请求获取数据、以及
    用 <link linkend="ch03-websockets">WebSockets</link> 来传输数据。
    HTML5 (和 dart:html) 还有很多本节没有介绍的 API。
    注意： 只有 Web 应用可以使用  dart:html 库，命令行应用无法使用。
    </para>

    <note>
      <para>使用  <ulink
      url="http://www.dartlang.cc/polymer-dart/">Polymer.dart</ulink> 和
      <ulink
      url="http://pub.dartlang.org/packages/angular">AngularDart</ulink>
      可以创建更灵活、更具扩展性的 web 应用 UI。
      </para>
    </note>

    <para>导入 dart:html 库即可使用该库：</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>import 'dart:html';</programlisting>

    <note>
      <para>有些 dart:html 库的功能还是试验性质的，在 API
    文档中有注明。</para>
    </note>

    <sect2 id="ch03-manipulating-the-dom">
      <title>操作 DOM</title>

      <para>要使用 DOM 你需要了解
      <emphasis>windows（窗口）</emphasis>、 <emphasis>documents（文档）</emphasis>、
      <emphasis>elements（元素）</emphasis>、 和 <emphasis>nodes（节点）</emphasis>。</para>

      <para>一个 <ulink
      url="http://api.dartlang.org/html/Window.html">Window</ulink> 对象代表
      浏览器的真实窗口。 每个 Window 都有一个
      <literal moreinfo="none">document</literal> 属性( 一个 Document
      对象)，该对象代表当前加载的页面内容。
      Window 对象还包含了访问各种 API 的能力，例如  IndexedDB (用来
      存储数据)、 <literal>requestAnimationFrame()</literal> (用来实现动画)、以及更多。
    在支持标签页（tab）的浏览器中，每个标签页都有自己的 Window 对象。</para>

      <para>使用 <ulink
      url="http://api.dartlang.org/html/Document.html">Document</ulink>
      对象可以操作文档中的  <ulink
      url="http://api.dartlang.org/html/Element.html">Elements</ulink> 。
      注意 Document 本身也是一个 element，也可以被修改。</para>

      <para>DOM 是一个 <ulink
      url="http://api.dartlang.org/html/Node.html">Nodes</ulink> 树模型。
      这些 Node 通常都是 Element，有些是 attributes（属性）、 text（文本）、 comments（注释）、
      以及其他类型。除了根 Node 没有父节点外，DOM 中的所有 Node 都有一个父节点，每个节点都可能有多个子节点。</para>

      <sect3 id="ch03-finding-elements">
        <title>查找 elements</title>

        <para>你需要先找到一个 element 才能修改该 element。
            你可以用各种条件查找一个 element 对象。</para>

        <para>使用顶级方法 
        <literal>querySelector()</literal> 和<literal>
        querySelectorAll()</literal> 来查找一个或者多个 element。
        可以用 ID、类（class）、tag（标签）、name（名字）、或者其组合来查找 Element。        
        <ulink
        url="http://www.w3.org/TR/css3-selectors/">CSS Selector Specification
        guide</ulink> 定义了选择器的规范。
        例如，用 # 前缀指定 ID；用 . 指定 CSS 类。</para>

        <para> <literal>querySelector()</literal> 方法返回第一个匹配
            的 Element，而
        <phrase
        role="keep-together"><literal>querySelectorAll()</literal>
        </phrase> 返回匹配的所有 Element。</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>Element elem1 = querySelector('#an-id');           // Find an element by id (an-id).
Element elem2 = querySelector('.a-class');         // Find an element by class (a-class).
List&lt;Element&gt; elems1 = querySelectorAll('div');    // Find all elements by tag (&lt;div&gt;).
List&lt;Element&gt; elems2 = querySelectorAll('input[type="text"]'); // Find all text inputs.

// Find all elements with the CSS class 'class' inside of a &lt;p&gt;
// that is inside an element with the ID 'id'.
List&lt;Element&gt; elems3 = querySelectorAll('#id p.class');</screen>
      </sect3>

      <sect3 id="ch03-manipulating-elements">
        <title>操控 elements</title>

        <para>
            可以用 properties（属性） 来修改 element 的状态。
            Node 和子类型 Element 定义了所有 element 都有的 属性。
            例如， 所有的 element 都有
         <literal
        moreinfo="none">classes</literal>、 <literal
        moreinfo="none">hidden</literal>、 <literal
        moreinfo="none">id</literal>、 <literal
        moreinfo="none">style</literal>、 和 <literal
        moreinfo="none">title</literal> 属性，可以用这些属性来
        设置 element 的状态。 Element 的子类定义了其他属性，例如
          <ulink
        url="http://api.dartlang.org/html/AnchorElement.html">AnchorElement</ulink>
        定义了 <literal moreinfo="none">href</literal> 属性。
        </para>

        <para>下面是一个设置 HTML 超链接的示例：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>&lt;a id="example" href="http://example.com"&gt;link text&lt;/a&gt;</screen>

        <para>这个 &lt;a&gt; 标签定义了一个带有
            <literal
        moreinfo="none">href</literal> 属性和
        文本节点（ text node） (通过  <literal moreinfo="none">text</literal> 属性访问该文本)
        的 链接。 可以使用 AnchorElement 的 <literal moreinfo="none">href</literal> 属性来
        修改该链接打开的 URL 地址：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>querySelector('#example').href = 'http://dartlang.org';</screen>

        <para>通常你需要修改多个 element 的属性。
            例如，下面的代码设置使用类 “mac”、 “win”、 或者 “linux” 元素的 <literal
        moreinfo="none">hidden</literal> 属性。
        把
        <literal
        moreinfo="none">hidden</literal> 属性设置为 true 和
        在 <phrase
        role="keep-together">CSS 样式上</phrase>
        添加 <literal moreinfo="none">display:none</literal>  是一样的效果。</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>&lt;!-- In HTML: --&gt;
&lt;p&gt;
  &lt;span class="os linux"&gt;Words for Linux&lt;/span&gt;
  &lt;span class="os mac"&gt;Words for Mac&lt;/span&gt;
  &lt;span class="os win"&gt;Words for Windows&lt;/span&gt;
&lt;/p&gt;
<remark>
</remark>// In Dart:
final osList = ['mac', 'win', 'linux'];

var userOs = 'linux'; // In real code you'd programmatically determine this.

for (var os in osList) {            // For each possible OS...
  bool shouldShow = (os == userOs); // Does this OS match the user's OS?
  for (var elem in querySelectorAll('.$os')) { // Find all elements for this OS.
    elem.hidden = !shouldShow;      // Show or hide each element.
  }
}</screen>

        <para>
            当所需要的属性不可用或者不方便使用的话，可以用
          Element 对象的 <literal moreinfo="none">attributes</literal> 属性。
    该属性为一个 <literal>Map&lt;String, String&gt;</literal> 对象，
    key 为 attribute 的名字。 参考
         <ulink
        url="https://developer.mozilla.org/en/HTML/Attributes">MDN Attributes
        页面</ulink> 来查看每个属性代表的意义。
         下面是一个设置 attribute 值的示例：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>elem.attributes['someAttribute'] = 'someValue';</screen>
      </sect3>

      <sect3 id="ch03-creating-elements">
        <title>创建 elements</title>

        <para>创建一个新的 elements 并添加到
            DOM 树中可以往 HTML 页面中添加内容。
            下面是一个创建 段落（(&lt;p&gt;)） 的示例：
        </para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>var elem = new ParagraphElement();
elem.text = 'Creating is easy!';</screen>

        <para>通过解析 HTML 文本也可以创建 Element 对象。 所有的子 element
            也会被解析并创建。</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>var elem2 = new Element.html('&lt;p&gt;Creating &lt;em&gt;is&lt;/em&gt; easy!&lt;/p&gt;');</screen>

        <para>注意：上面示例中的 elem2 对象为 ParagraphElement 。</para>

        <para> 通过设置新创建 element 对象的父节点来把该 element 添加到
            文档中。你可以把一个 element 添加到现有 element 的子节点上。
            下面的示例中，
        <literal
        moreinfo="none">body</literal> 是一个 element，
        使用  <literal
        moreinfo="none">children</literal> property（属性）可以
        访问 body 的子元素（as a List&lt;Element&gt;）。</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>document.body.children.add(elem2);</screen>
      </sect3>

      <sect3 id="ch03-adding-replacing-and-removing-nodes">
        <title>添加、替换、删除节点（ node ）</title>

        <para>还记得 element 是 node 的子类型吗。使用 Node 的
        moreinfo="none">nodes</literal> 属性可以获取该 node 的所有子节点，
        返回值为
        List&lt;Node&gt;。 获取到该 list 后，就可以用
        List 的函数和操作符来操作 node 的子节点了。</para>

        <para>使用 List 的
        <literal>add()</literal> 函数把一个节点添加到父节点的所有子节点的最后：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>// Find the parent by ID, and add elem as its last child.
querySelector('#inputs').nodes.add(elem);</screen>

        <para>用 Node 的<literal>replaceWith()</literal>
        函数来替换一个 node：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>// Find a node by ID, and replace it in the DOM.
querySelector('#status').replaceWith(elem);</screen>

        <para>使用 Node 的 <literal>remove()</literal>
        函数来删除节点：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>// Find a node by ID, and remove it from the DOM.
querySelector('#expendable').remove();</screen>
      </sect3>

      <sect3 id="ch03-manipulating-styles">
        <title>控制 CSS 样式</title>

        <para>CSS （<emphasis>cascading style sheets</emphasis>）定义了
            DOM 元素的显示样式。 通过设置 ID 和 类属性可以修改
            一个 element 的显示样式。</para>

        <para>每个 element 都有一个 <literal moreinfo="none">classes</literal>
        变量，该变量是一个 list 对象。
        在该 list 中添加、删除 字符串就可以实现 添加和删除 CSS 类的功能。
    例如，下面的示例在 element 中添加一个
        <literal moreinfo="none">warning</literal>  CSS 类：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>var element = querySelector('#message');
element.classes.add('warning');</screen>

        <para>通过 ID 来查找 element 一般都是比较高效的。
            通过
         <literal
        moreinfo="none">id</literal> property（属性） 可以
        动态的设置一个 element 的 ID。</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>var message = new DivElement();
message.id = 'message2';
message.text = 'Please subscribe to the Dart mailing list.';</screen>

        <para>通过级联操作符可以减少输入敲键盘的次数：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>var message = new DivElement()
    ..id = 'message2'
    ..text = 'Please subscribe to the Dart mailing list.';</screen>

        <para>
            使用 ID 或者 类来设置 element 的样式是最好的做法，但是有时候你也需要
            直接在 element 上设置样式：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>message.style
    ..fontWeight = 'bold'
    ..fontSize = '3em';</screen>
      </sect3>

      <sect3 id="ch03-handling-events">
        <title>处理事件</title>

        <para>要响应外部事件，例如 鼠标点击、焦点改变和选择 等，需要注册一个事件监听器（event listener）。
        你可以在页面的任意 element 上注册事件监听器。 如果你初次接触 web 编程，请参考     
        <ulink
        url="http://www.w3.org/TR/DOM-Level-3-Events/#dom-event-architecture">这里了解事件分发和传播 机制。</ulink>
         </para>

        <para>使用  <literal
        moreinfo="none">element.on<replaceable>Event</replaceable>.listen(<replaceable>function</replaceable>)</literal>
        来注册事件监听器，这里的
          <literal
        moreinfo="none"><replaceable>Event</replaceable></literal> 
        是事件的名字， <literal
        moreinfo="none"><replaceable>function</replaceable></literal> 是事件
        处理函数。</para>

        <para>例如，下面是一次处理按钮点击事件的示例：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>// Find a button by ID and add an event handler.
querySelector('#submitInfo').onClick.listen((e) {
  // When the button is clicked, it runs this code.
  submitData();
});</screen>

        <para>事件可以在  DOM 树中上下传递。
            使用
        <literal
        moreinfo="none">e.target</literal> 来判断是哪个 element 触发了该事件：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>document.body.onClick.listen((e) {
  var clickedElem = e.target;
  print('You clicked the ${clickedElem.id} element.');
});</screen>

        <para>通过查看<ulink
        url="http://api.dartlang.org/dart_html/Element.html">Element</ulink>
        和其子类的   "on<replaceable>EventType</replaceable>" 属性可以了解都有
        那些事件类型。一些常见的示例类型如下：</para>

        <itemizedlist>
          <listitem>
            <para>change</para>
          </listitem>

          <listitem>
            <para>blur</para>
          </listitem>

          <listitem>
            <para>keyDown</para>
          </listitem>

          <listitem>
            <para>keyUp</para>
          </listitem>

          <listitem>
            <para>mouseDown</para>
          </listitem>

          <listitem>
            <para>mouseUp</para>
          </listitem>
        </itemizedlist>
      </sect3>
    </sect2>

    <sect2 id="ch03-httprequest">
      <title>用 HttpRequest 请求 HTTP 资源</title>

      <para> <ulink
      url="http://api.dartlang.org/dart_html/HttpRequest.html">HttpRequest</ulink>
      类（之前被称之为 XMLHttpRequest ） 可以在浏览器中访问 HTTP 资源。
      传统的 AJAX 风格应用非常依赖 HttpRequest。 用 HttpRequest 来从服务器动态加载 JSON 数据或者其他资源。
      还可以动态的给服务器发送数据。
      </para>

      <para>
          下面的示例中假设所请求的资源和 脚本本事位于同一个 服务器。
          由于浏览器的安全策略限制，HttpRequest 类不能简单的使用不再同一个主机的资源。
          如果你需要访问不同主机的资源，你可以用 JSONP 技术或者启用 远程资源的 CORS 头（header）。
</para>

      <sect3 id="_getting_data_from_the_server">
        <title>从服务器获取数据</title>

        <para>HttpRequest 类的静态函数 <literal>getString()</literal> 
        是从服务器获取数据的一个方法。在 <literal>getString()</literal> 的返回值上使用    
        <literal>then()</literal> 来异步处理返回的结果。</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_2_html.dart
</remark>import 'dart:html';
import 'dart:async';

// A JSON-formatted file in the same location as this page.
var uri = 'data.json';

main() {
  // Read a JSON file.
  HttpRequest.getString(uri).then(processString);
}

processString(String jsonText) {
  parseText(jsonText);
}</screen>

        <para>
            上面设置的方法 <literal>processString()</literal> 会在请求完成的时候执行。
            上面的示例中，动态的加载一个 JSON 文件。在
        <xref linkend="ch03-json" /> 介绍了 JSON API。</para>

        <para>在  
        <literal>.then()</literal> 后面通过 <literal>.catchError()</literal>
        来设置一个错误处理方法：</para>

        <programlisting role="keep-together"><remark>lang-dart
</remark><remark>ch03_html/ch03_2_html.dart
</remark>...
HttpRequest.getString(uri)
    .then(processString)
    .catchError(handleError);
...
handleError(error) {
  print('Uh oh, there was an error.');
  print(error.toString());
}</programlisting>

        <para>如果你的 HttpRequest 返回的结果不是一个字符串，则
            可以用 <literal>request()</literal> 静态函数。
            下面是读取 XML 数据的一个示例：
             </para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_2_html.dart
</remark>import 'dart:html';
import 'dart:async';

// An XML-formatted file in the same location as this page.
var xmlUri = 'data.xml';

main() {
  // Read an XML file.
  HttpRequest.request(xmlUri)
      .then(processRequest)
      .catchError(handleError);
}

processRequest(HttpRequest request) {
  var xmlDoc = request.responseXml;
  try {
    var license = xmlDoc.querySelector('license').text;
    print('License: $license');
  } catch(e) {
    print('$xmlUri doesn\'t have correct XML formatting.');
  }
}
...</screen>

        <para>还可以用完整的 API（full API） 来实现不同的功能， 例如读取请求头信息。</para>

        <para>下面是使用 完整 API 的流程：</para>

        <orderedlist continuation="restarts" inheritnum="ignore"
                     numeration="arabic">
          <listitem>
            <para>创建一个 HttpRequest 对象：</para>
          </listitem>

          <listitem>
            <para>用  <literal
            moreinfo="none">GET</literal> 或者 <literal
            moreinfo="none">POST</literal> 打开一个 URL。</para>
          </listitem>

          <listitem>
            <para>添加事件处理函数。</para>
          </listitem>

          <listitem>
            <para>发送该请求。</para>
          </listitem>
        </orderedlist>

        <para>例如：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>dart-tutorials-samples/web/portmanteaux/portmanteaux.dart
</remark>import 'dart:html';
...
var httpRequest = new HttpRequest()
    ..open('POST', dataUrl)
    ..onLoadEnd.listen((_) =&gt; requestComplete(httpRequest))
    ..send(encodedData);
</screen>
      </sect3>

      <sect3 id="_sending_data_to_the_server">
        <title>往服务器发送数据</title>

        <para>HttpRequest 用 HTTP POST 可以往服务器发送数据。
            例如：你可能需要从 form 表单中动态的提交数据。 往 RESTful  web 服务 发送 JSON 数据是另外
            一个常见的情景。</para>

        <para>
            提交 form 表单数据需要提供一个 URI 编码过的 name-value 字符串。
            （<xref linkend="ch03-uri" /> 介绍了 URI。）另外还要设置
        <literal moreinfo="none">Content-type</literal> 头为 <literal
        moreinfo="none">application/x-www-form-urlencode</literal>。</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/ch03/ch03_3_html/json-send-to-server.dart
</remark>import 'dart:html';

String encodeMap(Map data) {
  return data.keys.map((k) {
    return '${Uri.encodeComponent(k)}=${Uri.encodeComponent(data[k])}';
  }).join('&amp;');
}

loadEnd(HttpRequest request) {
  if (request.status != 200) {
    print('Uh oh, there was an error of ${request.status}');
  } else {
    print('Data has been posted');
  }
}

main() {
  var dataUrl = '/registrations/create';
  var data = {'dart': 'fun', 'editor': 'productive'};
  var encodedData = encodeMap(data);

  var httpRequest = new HttpRequest();
  httpRequest.open('POST', dataUrl);
  httpRequest.setRequestHeader('Content-type', 
                               'application/x-www-form-urlencoded');
  httpRequest.onLoadEnd.listen((e) =&gt; loadEnd(httpRequest));
  httpRequest.send(encodedData);
}</screen>
      </sect3>
    </sect2>

    <sect2 id="ch03-websockets">
      <title>用 WebSocket 来发送和接收实时数据</title>

      <para>WebSocket 可以和服务器实时的交换数据，不用轮询。 服务器通过监听
          <emphasis
      role="strong">ws://</emphasis> 开头的 URL 来启动 WebSocket，例如
      ws://127.0.0.1:1337/ws。
      通过 WebSocket 可以传输 字符串、二进制数据和
      一个<ulink
      url="http://api.dartlang.org/html/ArrayBuffer.html">ArrayBuffer 对象。</ulink>
      通常情况下使用的都是 JSON 格式的字符串。</para>

      <para>要在 web 应用中使用 WebSocket ，先创建一个 <ulink
      url="http://api.dartlang.org/html/WebSocket.html">WebSocket</ulink>
      对象，参数为 WebSocket URL 地址：</para>

      <screen format="linespecific"><remark>lang-dart
github.com/dart-lang/dart-samples/.../web/html5/websockets/basics/websocket_sample.dart
</remark>var ws = new WebSocket('ws://echo.websocket.org');</screen>

      <sect3 id="ch03-sending-data">
        <title>发送数据</title>

        <para>用 
        <literal>send()</literal> 函数发送字符串：</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>github.com/dart-lang/dart-samples/.../web/html5/websockets/basics/websocket_sample.dart
</remark>ws.send('Hello from Dart!');</screen>
      </sect3>

      <sect3 id="ch03-receiving-data">
        <title>接收数据</title>

        <para>在 WebSocket 上注册监听器来接收数据：</para>

        <screen format="linespecific"><remark>lang-dart
<remark>github.com/dart-lang/dart-samples/.../web/html5/websockets/basics/websocket_sample.dart
</remark></remark>ws.onMessage.listen((MessageEvent e) {
  print('Received message: ${e.data}');
});</screen>

        <para>消息事件监听器接收一个  <ulink
        url="http://api.dartlang.org/html/MessageEvent.html">MessageEvent</ulink>
        对象。该对象的 <literal moreinfo="none">data</literal> 变量包含了服务器发送的数据。</para>
      </sect3>

      <sect3 id="ch03-handling-websocket-events">
        <title>处理 WebSocket 事件</title>

        <para><ulink
        url="http://api.dartlang.org/html/WebSocketEvents.html">WebSocketEvents</ulink>
        定义了你的应用可以处理的事件： open、 close、 error、
        和 (上面所演示的) message 事件。
        下面是创建一个 WebSocket 对象并注册  open、 close、 error、和 message 事件的示例：</para>

        <screen format="linespecific"><remark>lang-dart
<remark>github.com/dart-lang/dart-samples/.../web/html5/websockets/basics/websocket_sample.dart
</remark></remark>void initWebSocket([int retrySeconds = 2]) {
  var reconnectScheduled = false;

  print("Connecting to websocket");
  ws = new WebSocket('ws://echo.websocket.org');

  void scheduleReconnect() {
    if (!reconnectScheduled) {
      new Timer(new Duration(milliseconds: 1000 * retrySeconds), () =&gt; initWebSocket(retrySeconds * 2));
    }
    reconnectScheduled = true;
  }

  ws.onOpen.listen((e) {
    print('Connected');
    ws.send('Hello from Dart!');
  });

  ws.onClose.listen((e) {
    print('Websocket closed, retrying in $retrySeconds seconds');
    scheduleReconnect();
  });

  ws.onError.listen((e) {
    print("Error connecting to ws");
    scheduleReconnect();
  });

  ws.onMessage.listen((MessageEvent e) {
    print('Received message: ${e.data}');
  });
}</screen>

        <para>关于 WebSocket 的更多信息和示例代码请参考 
        <ulink url="http://www.dartlang.cc/samples/">Dart 代码示例。</ulink></para>
      </sect3>
    </sect2>

    <sect2 id="ch03-more-information-html">
      <title>更多信息</title>

      <para>这节内容之上蜻蜓点水般的介绍了 dart:html
        库，更多信息请参考 <ulink
      url="http://api.dartlang.org/dart_html.html">dart:html</ulink> 
      和 <ulink
      url="http://www.dartlang.cc/samples/">Dart 代码示例。</ulink> Dart 
      还有一些库专门处理特殊的 web API，例如：
      <ulink
      url="http://api.dartlang.org/dart_web_audio.html">web audio、</ulink>
      <ulink
      url="http://api.dartlang.org/dart_indexed_db.html">IndexedDB</ulink>、
      和 <ulink
      url="http://api.dartlang.org/dart_web_gl.html">WebGL</ulink> 等。</para>
    </sect2>
  </sect1>

  <sect1 id="ch03-dartio---file-and-socket-io-for-command-line-apps">
    <title>dart:io - 用于命令行应用的 I/O 操作 </title>

    <para> <ulink url="http://api.dartlang.org/io.html">dart:io
    库</ulink> 提供了访问文件、目录、进程、socket 和 HTTP 通信的功能。
    只有命令行应用才能使用 dart:io 库。</para>

    <para>In general, the dart:io library implements and promotes an
    asynchronous API. Synchronous methods can easily block the event loop,
    making it difficult to scale server applications. Therefore, most
    operations return results via callbacks or Future objects, a pattern
    common with modern server platforms such as Node.js.</para>

    <para>The few synchronous methods in the dart:io library are clearly
    marked with a Sync suffix on the method name. We don’t cover them
    here.</para>

    <note>
      <para>Only command-line apps can import and use <literal
      moreinfo="none">dart:io</literal>.</para>
    </note>

    <sect2 id="ch03-files-and-directories">
      <title>Files and Directories</title>

      <para>The I/O library enables command-line apps to read and write files
      and browse directories. You have two choices for reading the contents of
      a file: all at once, or streaming. Reading a file all at once requires
      enough memory to store all the contents of the file. If the file is very
      large or you want to process it while reading it, you should use a
      Stream, as described in <xref
      linkend="ch03-streaming-file-contents" />.</para>

      <sect3 id="ch03-reading-a-file-as-text">
        <title>Reading a file as text</title>

        <para>When reading a text file, you can read the entire file contents
        with <literal>readAsString()</literal>. When the individual lines are
        important, you can use <literal>readAsLines()</literal>. In both
        cases, a Future object is returned that provides the contents of the
        file as one or more strings.</para>

        <screen format="linespecific"><remark>lang-dart
ch03/textRead.dart
</remark>import 'dart:io';

main() {
  var config = new File('config.txt');

  // Put the whole file in a single string.
  config.readAsString().then((String contents) {
    print('The entire file is ${contents.length} characters long');
  });

  // Put each line of the file into its own string.
  config.readAsLines().then((List&lt;String&gt; lines) {
    print('The entire file is ${lines.length} lines long');
  });
}</screen>
      </sect3>

      <sect3 id="ch03-reading-a-file-as-binary">
        <title>Reading a file as binary</title>

        <para>The following code reads an entire file as bytes into a list of
        ints. The call to <phrase
        role="keep-together"><literal>readAsBytes()</literal></phrase> returns
        a Future, which provides the result when it’s available.</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/binaryRead.dart
</remark>import 'dart:io';

main() {
  var config = new File('config.txt');

  config.readAsBytes().then((List&lt;int&gt; contents) {
    print('The entire file is ${contents.length} bytes long');
  });
}</screen>
      </sect3>

      <sect3 id="ch03-handling-errors">
        <title>Handling errors</title>

        <para>To capture errors so they don't result in exceptions, you can
        register a <literal moreinfo="none">catchError</literal>
        handler:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/fileErrors.dart
</remark>import 'dart:io';

main() {
  var config = new File('config.txt');
  config.readAsString().then((String contents) {
    print(contents);
  }).catchError((e) {
    print(e);
  });
}</screen>
      </sect3>

      <sect3 id="ch03-streaming-file-contents">
        <title>Streaming file contents</title>

        <para>Use a Stream to read a file, a little at a time. The <literal
        moreinfo="none">listen()</literal> method specifies a handler to be
        called when data is available. When the Stream is finished reading the
        file, the <literal moreinfo="none">onDone</literal> callback
        executes.</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/readFile.dart
</remark>import 'dart:io';
import 'dart:convert';
import 'dart:async';

main() {
  var config = new File('config.txt');
  Stream&lt;List&lt;int&gt;&gt; inputStream = config.openRead();

  inputStream
    .transform(UTF8.decoder)
    .transform(new LineSplitter())
    .listen(
      (String line) { 
        print('Read ${line.length} bytes from stream');
      },
      onDone: () { print('file is now closed'); },
      onError: (e) { print(e.toString()); });
}</screen>
      </sect3>

      <sect3 id="ch03-writing-file-contents">
        <title>Writing file contents</title>

        <para>You can use an <ulink
        url="http://api.dartlang.org/dart_io/IOSink.html">IOSink</ulink> to
        write data to a file. Use the File <literal>openWrite()</literal>
        method to declare a mode and get an IOSink that you can write to. The
        default mode, <literal moreinfo="none">FileMode.WRITE</literal>,
        completely overwrites existing data in the file.</para>

        <programlisting role="keep-together"><remark>lang-dart
</remark><remark>ch03/writeFile.dart
</remark>var logFile = new File('log.txt');
var sink = logFile.openWrite();
sink.write('FILE ACCESSED ${new DateTime.now()}\n');
sink.close();</programlisting>

        <para>To add to the end of the file, use the optional
        <literal>mode</literal> parameter to specify
        <literal>FileMode.APPEND</literal>:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/writeFile.dart
</remark>var sink = logFile.openWrite(mode: FileMode.APPEND); </screen>

        <para>To write binary data, use <literal
        moreinfo="none">add(List&lt;int&gt; data)</literal>.</para>
      </sect3>

      <sect3 id="ch03-listing-files-in-a-directory">
        <title>Listing files in a directory</title>

        <para>Finding all files and subdirectories for a directory is an
        asynchronous operation. The <literal>list()</literal> method returns a
        Stream on which you can register handlers (using
        <literal>listen()</literal>) to be notified when a file or directory
        is encountered.</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/listFiles.dart
</remark>import 'dart:io';
import 'dart:async';

main() {
  var dir = new Directory('/tmp');
  var contentsStream = dir.list(recursive:true);
  contentsStream.listen(
    (FileSystemEntity f) {
      if (f is File) {
        print('Found file ${f.path}');
      } else if (f is Directory) {
        print('Found dir ${f.path}');
      }
    },
    onError: (e) { print(e.toString()); }
  );
}</screen>
      </sect3>

      <sect3 id="ch03-other-common-functionality">
        <title>Other common functionality</title>

        <para>The File and Directory classes contain other functionality,
        including but not limited to:</para>

        <itemizedlist role="keep-together">
          <listitem>
            <para>Creating a file or directory: <literal>create()</literal> in
            File and Directory</para>
          </listitem>

          <listitem>
            <para>Deleting a file or directory: <literal>delete()</literal> in
            File and Directory</para>
          </listitem>

          <listitem>
            <para>Getting the length of a file: <literal>length()</literal> in
            File</para>
          </listitem>

          <listitem>
            <para>Getting random access to a file: <literal>open()</literal>
            in File</para>
          </listitem>
        </itemizedlist>

        <para>Refer to the API docs for <ulink
        url="http://api.dartlang.org/io/File.html">File</ulink> and <ulink
        url="http://api.dartlang.org/io/Directory.html">Directory</ulink> for
        a full list of methods.</para>
      </sect3>
    </sect2>

    <sect2 id="ch03-io-http">
      <title>HTTP Clients and Servers</title>

      <para>The dart:io library provides classes that command-line apps can
      use for accessing HTTP resources, as well as running HTTP
      servers.</para>

      <sect3 id="_http_server">
        <title>HTTP server</title>

        <para>The <ulink
        url="http://api.dartlang.org/dart_io/HttpServer.html">HttpServer</ulink>
        class provides the low-level functionality for building web servers.
        You can match request handlers, set headers, stream data, and
        more.</para>

        <para>The following sample web server can return only simple text
        information. This server listens on port 8888 and address 127.0.0.1
        (localhost), responding to requests for the path <literal
        moreinfo="none">/languages/dart</literal>. All other requests are
        handled by the default request handler, which returns a response code
        of 404 (not found).</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/httpServer.dart
</remark>import 'dart:io';

main() {
  dartHandler(HttpRequest request) {
    print('New request');
    request.response.write('Dart is optionally typed');
    request.response.close();
  };

  HttpServer.bind('127.0.0.1', 8888).then((HttpServer server) {
    server.listen((request) { 
      print("got request");
      if (request.uri.path == '/languages/dart') {
        dartHandler(request);
      } else {
        request.response.write('Not found');
        request.response.statusCode = HttpStatus.NOT_FOUND;
        request.response.close();
      }
    });
  });
}</screen>

        <para>For a more comprehensive HTTP server, see the <ulink
        url="https://code.google.com/p/dart/source/browse/branches/bleeding_edge/dart/samples/dartiverse_search/">dartiverse_search</ulink>
        example, which uses additional packages such as <ulink
        url="https://pub.dartlang.org/packages/http_server">http_server</ulink>
        and <ulink
        url="http://pub.dartlang.org/packages/route">route</ulink>.<remark>
        {PENDING: point to the <ulink
        url="http://www.dartlang.cc/samples/">Dart Code Samples</ulink>
        instead? Need to come up with a good way of pointing to
        samples.}</remark></para>
      </sect3>

      <sect3 id="_http_client">
        <title>HTTP client</title>

        <para>The <ulink
        url="http://api.dartlang.org/dart_io/HttpClient.html">HttpClient</ulink>
        class helps you connect to HTTP resources from your Dart command-line
        or server-side application. You can set headers, use HTTP methods, and
        read and write data. The HttpClient class does not work in
        browser-based apps. When programming in the browser, use the <link
        linkend="ch03-httprequest">HttpRequest class</link>. Here’s an example
        of using HttpClient:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/httpClient.dart
</remark>import 'dart:io';
import 'dart:convert';

main() {
  var url = Uri.parse('http://127.0.0.1:8888/languages/dart');
  var httpClient = new HttpClient();
  httpClient.getUrl(url)
    .then((HttpClientRequest request) {
      print('have request');
      return request.close();
    })
    .then((HttpClientResponse response) {
      print('have response');
      response.transform(UTF8.decoder).toList().then((data) {
        var body = data.join('');
        print(body);
        httpClient.close();
      });
    });
}</screen>
      </sect3>
    </sect2>

    <sect2 id="ch03-more-information-io">
      <title>More Information</title>

      <para>Besides the APIs discussed in this section, the dart:io library
      also provides APIs for <ulink
      url="http://api.dartlang.org/io/Process.html">processes,</ulink> <ulink
      url="http://api.dartlang.org/io/Socket.html">sockets,</ulink> and <ulink
      url="http://api.dartlang.org/io/WebSocket.html">web
      sockets.</ulink></para>

      <para>For more examples of using dart:io, see the <ulink
      url="http://www.dartlang.cc/samples/">Dart Code Samples.</ulink></para>
    </sect2>
  </sect1>

  <sect1 id="ch03-dart-convert">
    <title>dart:convert - Decoding and Encoding JSON, UTF-8, and more</title>

    <para>The <ulink
    url="http://api.dartlang.org/dart_convert.html">dart:convert
    library</ulink> has converters for JSON and UTF-8, as well as support for
    creating additional converters. JSON is a simple text format for
    representing structured objects and collections. UTF-8 is a common
    variable-width encoding that can represent every character in the Unicode
    character set.</para>

    <para>The dart:convert library works in both web apps and command-line
    apps. To use it, import dart:convert.</para>

    <sect2 id="ch03-json">
      <title>Decoding and Encoding JSON</title>

      <para>Decode a JSON-encoded string into a Dart object with
      <literal>JSON.decode()</literal>:</para>

      <screen format="linespecific"><remark>lang-dart
ch03/jsonParse.dart
</remark>import 'dart:convert' show JSON;

main() {
  // NOTE: Be sure to use double quotes ("), not single quotes ('),
  // inside the JSON string. This string is JSON, not Dart.
  var jsonString = '''
  [
    {"score": 40},
    {"score": 80}
  ]
  ''';

  var scores = JSON.decode(jsonString);
  assert(scores is List);

  var firstScore = scores[0];
  assert(firstScore is Map);
  assert(firstScore['score'] == 40);
}</screen>

      <para>Encode a supported Dart object into a JSON-formatted string with
      <literal>JSON.encode()</literal>:</para>

      <programlisting role="keep-together"><remark>lang-dart
ch03/jsonStringify.dart
</remark>import 'dart:convert' show JSON;

main() {
  var scores = [
    {'score': 40},
    {'score': 80},
    {'score': 100, 'overtime': true, 'special_guest': null}
  ];

  var jsonText = JSON.encode(scores);
  assert(jsonText == '[{"score":40},{"score":80},'
                     '{"score":100,"overtime":true,'
                     '"special_guest":null}]');
}</programlisting>

      <para>Only objects of type int, double, String, bool, null, List, or Map
      (with string keys) are directly encodable into JSON. List and Map
      objects are encoded recursively.</para>

      <para>You have two options for encoding objects that aren't directly
      encodable. The first is to invoke <literal>encode()</literal> with a
      second argument: a function that returns an object that is directly
      encodable. Your second option is to omit the second argument, in which
      case the encoder calls the object's <literal>toJson()</literal>
      method.</para>
    </sect2>

    <sect2 id="ch03-utf">
      <title>Decoding and Encoding UTF-8 Characters</title>

      <para>Use <literal>UTF8.decode()</literal> to decode UTF8-encoded bytes
      to a Dart string:</para>

      <screen format="linespecific"><remark>lang-dart
ch03/decodeUtf8.dart
</remark>import 'dart:convert' show UTF8;

main() {
  var string = UTF8.decode([0xc3, 0x8e, 0xc3, 0xb1, 0xc5, 0xa3, 0xc3, 0xa9,
                           0x72, 0xc3, 0xb1, 0xc3, 0xa5, 0xc5, 0xa3, 0xc3,
                           0xae, 0xc3, 0xb6, 0xc3, 0xb1, 0xc3, 0xa5, 0xc4,
                           0xbc, 0xc3, 0xae, 0xc5, 0xbe, 0xc3, 0xa5, 0xc5,
                           0xa3, 0xc3, 0xae, 0xe1, 0xbb, 0x9d, 0xc3, 0xb1]);
  print(string); // 'Îñţérñåţîöñåļîžåţîờñ'
}</screen>

      <para>To convert a stream of UTF-8 characters into a Dart string,
      specify <literal>UTF8.decoder</literal> to the Stream
      <literal>transform()</literal> method:</para>

      <screen format="linespecific"><remark>lang-dart
ch03/readFile.dart
</remark>inputStream
  .transform(UTF8.decoder)
  .transform(new LineSplitter())
  .listen(
    (String line) { 
      print('Read ${line.length} bytes from stream');
    });</screen>

      <para>Use <literal>UTF8.encode()</literal> to encode a Dart string as a
      list of UTF8-encoded bytes:</para>

      <screen format="linespecific"><remark>lang-dart
ch03/encodeUtf8.dart
</remark>import 'dart:convert' show UTF8;

main() {
  List&lt;int&gt; expected = [0xc3, 0x8e, 0xc3, 0xb1, 0xc5, 0xa3, 0xc3, 0xa9, 0x72,
                        0xc3, 0xb1, 0xc3, 0xa5, 0xc5, 0xa3, 0xc3, 0xae, 0xc3,
                        0xb6, 0xc3, 0xb1, 0xc3, 0xa5, 0xc4, 0xbc, 0xc3, 0xae,
                        0xc5, 0xbe, 0xc3, 0xa5, 0xc5, 0xa3, 0xc3, 0xae, 0xe1,
                        0xbb, 0x9d, 0xc3, 0xb1];

  List&lt;int&gt; encoded = UTF8.encode('Îñţérñåţîöñåļîžåţîờñ');

  assert(() {
    if (encoded.length != expected.length) return false;
    for (int i = 0; i &lt; encoded.length; i++) {
      if (encoded[i] != expected[i]) return false;
    }
    return true;
  });
}</screen>
    </sect2>

    <sect2 id="ch03-utf-other">
      <title>Other Functionality</title>

      <para>The dart:convert library also has converters for ASCII and ISO
      Latin 1. For details, see the <ulink
      url="http://api.dartlang.org/dart_convert.html">API docs for the
      dart:convert library.</ulink></para>
    </sect2>
  </sect1>

  <sect1 id="ch03-mirrors">
    <title>dart:mirrors - Reflection</title>

    <para>The dart:mirrors library provides basic reflection abilities to
    Dart. Use mirrors to query the structure of your program and to
    dynamically invoke functions or methods at runtime. </para>

    <para>The dart:mirrors library works in both web apps and command-line
    apps. To use it, import dart:mirrors.</para>

    <warning>
      <para>Using dart:mirrors can cause dart2js to generate very large
      JavaScript files.</para>

      <para>The current workaround is to add a <literal>@MirrorsUsed</literal>
      annotation before the import of dart:mirrors. For details, see the
      <ulink
      url="http://api.dartlang.org/dart_mirrors/MirrorsUsed.html">MirrorsUsed</ulink>
      API documentation. This workaround might change, as the dart:mirrors
      library is still under development.</para>
    </warning>

    <sect2 id="ch03-mirrors-symbols">
      <title>Symbols</title>

      <para>The mirror system represents the names of Dart declarations
      (classes, fields, and so on) by instances of the class <ulink
      url="http://api.dartlang.org/dart_core/Symbol.html">Symbol</ulink>.
      Symbols help compilers like dart2js produce efficient output, even when
      minified.</para>

      <para>When you know the name of the symbol ahead of time, use a symbol
      literal. This way, repeated uses of the same symbol can use the same
      canonicalized instance. If the name of the symbol is determined
      dynamically at runtime, use the Symbol constructor.</para>

      <screen format="linespecific"><remark>lang-dart
ch03/mirrors.dart
</remark>import 'dart:mirrors';

// If the symbol name is known at compile time.
const className = #MyClass;

// If the symbol name is dynamically determined.
var userInput = askUserForNameOfFunction();
var functionName = new Symbol(userInput);</screen>

      <para>During minification, a compiler might replace a symbol name with a
      different (often smaller) name. To convert from a symbol back to a
      string, use <literal>MirrorSystem.getName()</literal>. This function
      returns the correct name, even if the code was minified.</para>

      <screen format="linespecific"><remark>lang-dart
ch03/mirrors.dart
</remark>import 'dart:mirrors';

const className = #MyClass;
assert('MyClass' == MirrorSystem.getName(className));
</screen>
    </sect2>

    <sect2 id="ch03-mirrors-introspection">
      <title>Introspection</title>

      <para>Use mirrors to introspect the running program's structure. You can
      inspect classes, libraries, instances, and more.</para>

      <para>The examples in this section use the following Person
      class:</para>

      <screen format="linespecific"><remark>lang-dart
ch03/mirrors.dart
</remark>class Person {
  String firstName;
  String lastName;
  int age;
  
  Person(this.firstName, this.lastName, this.age);

  String get fullName =&gt; '$firstName $lastName';

  void greet(String other) {
    print('Hello there, $other!');
  }
}</screen>

      <para>To begin, you need to <emphasis>reflect</emphasis> on a class or
      object to get its <emphasis>mirror</emphasis>.</para>

      <sect3 id="ch03-mirrors-class-inspect">
        <title>Class Mirrors</title>

        <para>Reflect on a Type to get its ClassMirror.</para>

        <screen format="linespecific"><remark>lang-dart
ch03/mirrors.dart
</remark>ClassMirror mirror = reflectClass(Person);

assert('Person' == MirrorSystem.getName(mirror.simpleName));</screen>

        <para>You can also call <literal>runtimeType</literal> to get a Type
        from an instance.</para>

        <screen format="linespecific"><remark>lang-dart
ch03/mirrors.dart
</remark>var person = new Person('Bob', 'Smith', 33);
ClassMirror mirror = reflectClass(person.runtimeType);

assert('Person' == MirrorSystem.getName(mirror.simpleName));</screen>

        <para>Once you have a ClassMirror, you can get a class's constructors,
        fields, and more. Here is an example of listing the constructors of a
        class.</para>

        <screen format="linespecific"><remark>lang-dart
ch03/mirrors.dart
</remark>showConstructors(ClassMirror mirror) {
  var methods = mirror.declarations.values.where((m) =&gt; m is MethodMirror);
  var constructors = methods.where((m) =&gt; m.isConstructor);
  
  constructors.forEach((m) {
    print('The constructor ${m.simpleName} has ${m.parameters.length} parameters.');
  });
}</screen>

        <para>Here is an example of listing all of the fields declared by a
        class.</para>

        <screen><remark>lang-dart
ch03/mirrors.dart
</remark>showFields(ClassMirror mirror) {
  var fields = mirror.declarations.values.where((m) =&gt; m is VariableMirror);

  fields.forEach((VariableMirror m) {
    var finalStatus = m.isFinal ? 'final' : 'not final';
    var privateStatus = m.isPrivate ? 'private' : 'not private';
    var typeAnnotation = m.type.simpleName;

    print('The field ${m.simpleName} is $privateStatus and $finalStatus and is annotated '
          'as $typeAnnotation');
  });
}</screen>

        <para>For a full list of methods, consult the <ulink
        url="http://api.dartlang.org/dart_mirrors/ClassMirror.html">API docs
        for ClassMirror</ulink>.</para>
      </sect3>

      <sect3 id="ch03-mirrors-instance-inspect">
        <title>Instance Mirrors</title>

        <para>Reflect on an object to get an InstanceMirror.</para>

        <screen><remark>lang-dart
ch03/mirrors.dart
</remark>var p = new Person('Bob', 'Smith', 42);
InstanceMirror mirror = reflect(p);</screen>

        <para>If you have an InstanceMirror and you want to get the object
        that it reflects, use <literal>reflectee</literal>.</para>

        <screen><remark>lang-dart
ch03/mirrors.dart
</remark>var person = mirror.reflectee;
assert(identical(p, person));</screen>
      </sect3>
    </sect2>

    <sect2 id="ch03-mirrors-invocation">
      <title>Invocation</title>

      <para>Once you have an InstanceMirror, you can invoke methods and call
      getters and setters. For a full list of methods, consult the <ulink
      url="http://api.dartlang.org/dart_mirrors/InstanceMirror.html">API docs
      for InstanceMirror</ulink>.</para>

      <sect3 id="ch03-mirrors-invoke">
        <title>Invoke Methods</title>

        <para>Use InstanceMirror's <literal>invoke()</literal> method to
        invoke a method on an object. The first parameter specifies the method
        to be invoked, and the second is a list of positional arguments to the
        method. An optional third parameter lets you specify named
        arguments.</para>

        <screen><remark>lang-dart
ch03/mirrors.dart
</remark>var p = new Person('Bob', 'Smith', 42);
InstanceMirror mirror = reflect(p);

mirror.invoke(#greet, ['Shailen']);</screen>
      </sect3>

      <sect3 id="ch03-mirrors-getset-fields">
        <title>Get and Set Properties</title>

        <para>Use InstanceMirror's <literal>getField()</literal> and
        <literal>setField()</literal> methods to get and set properties of an
        object.</para>

        <screen><remark>lang-dart
ch03/mirrors.dart
</remark>
var p = new Person('Bob', 'Smith', 42);
InstanceMirror mirror = reflect(p);

// Get the value of a property.
var fullName = mirror.getField(#fullName).reflectee;
assert(fullName == 'Bob Smith');
  
// Set the value of a property.
mirror.setField(#firstName, 'Mary');
assert(p.firstName == 'Mary');</screen>
      </sect3>
    </sect2>

    <sect2 id="ch03-more-information-mirrors">
      <title>More Information</title>

      <para>The article <ulink
      url="https://www.dartlang.cc/articles/reflection-with-mirrors/">Reflection
      in Dart with Mirrors</ulink> has more information and examples. Also see
      the API docs for <ulink
      url="http://api.dartlang.org/dart_mirrors.html">dart:mirror,</ulink>
      especially <ulink
      url="http://api.dartlang.org/dart_mirrors/MirrorsUsed.html">MirrorsUsed</ulink>,
      <ulink
      url="http://api.dartlang.org/dart_mirrors/ClassMirror.html">ClassMirror,</ulink>
      and <ulink
      url="http://api.dartlang.org/dart_mirrors/InstanceMirror.html">InstanceMirror.</ulink></para>
    </sect2>
  </sect1>

  <sect1 id="ch03-summary">
    <title>Summary</title>

    <para>This chapter introduced you to the most commonly used functionality
    in many of Dart’s built-in libraries. It didn’t cover all the built-in
    libraries, however. Others that you might want to look into include <ulink
    url="http://api.dartlang.org/dart_collection.html">dart:collection,</ulink>
    <ulink
    url="http://api.dartlang.org/dart_isolate.html">dart:isolate,</ulink>
    <ulink url="http://api.dartlang.org/dart_js.html">dart:js,</ulink> and
    <ulink
    url="http://api.dartlang.org/dart_typed_data.html">dart:typed_data.</ulink>
    You can get yet more libraries by using the pub tool, discussed in the
    next chapter. The <ulink
    url="http://pub.dartlang.org/packages/args">args,</ulink> <ulink
    url="http://api.dartlang.org/logging.html">logging,</ulink> <ulink
    url="http://pub.dartlang.org/packages/polymer">polymer,</ulink> and <ulink
    url="http://api.dartlang.org/unittest.html" wordsize=""><phrase
    role="keep-together">unittest</phrase></ulink> libraries are just a
    sampling of what you can install using pub.</para>
  </sect1>
</chapter>
